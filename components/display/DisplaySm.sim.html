<!-- 
  -- This file was generated by StateSmith.
  -- It serves as an example of how to use the generated state machine in a web page.
  -- It also serves as an interactive console that you can use to validate the
  -- state machine's behavior.
  --
  -- Using DisplaySm.js generally looks like:
  --   var sm = new DisplaySm();
  --   sm.start();
  --
  -- And then using sm.dispatchEvent() to dispatch events to the state machine.
  -->
<html>
  <head>
    <link rel='icon' type='image/png' href='https://statesmith.github.io/favicon.png'>
    <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined'>
    <style>
      body {
        display: flex;
        flex-direction: row;
        margin: 0px;
      }

      /* Fix for mermaid content requiring scroll bars https://github.com/StateSmith/StateSmith/issues/288 */
      pre.mermaid {
        margin: 0px;
      }

      .wrapper {
        height: 100vh;
        width: 100vw;
        display: flex;
      }

      .pane {
        padding: 1em;
        min-width: 200px;
      }

      .titlebar-icon {
        font-family: 'Material Symbols Outlined', sans-serif;
        font-size: 16px;
        color: #777;
        border-radius: 5px;
      }

      .gutter {
        width: 10px;
        height: 100%;
        background: #ccc;
        position: absolute;
        top: 0;
        left: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1;
        overflow: auto;
        padding: 10px;
      }

      .sidebar {
        width: 300px;
        padding-top: 0px;
        position: relative;
        background-color: #f0f0f0;
        border-left: 1px solid #ccc;
        display: flex;
        flex-direction: column;
      }

      #buttons {
        display: flex;
        flex-direction: column;
      }

      .titlebar {
        background-color: #ddd;
        border-bottom: 1px solid #ccc;
        font-weight: bold;
        padding: 5px;
        display: flex;
      }

      .console {
        border-collapse: collapse;
        margin-top: 10px;
        width: 100%;
      }

      table.console td.timestamp {
        display: none;
      }

      table.console.timestamps td.timestamp {
        display: table-cell;
      }

      table.console td {
          color: rgba(0, 0, 0, 0.7);
      }

      table.console td .dispatched {
          font-weight: bold;
          color: rgba(0, 0, 0, 1);
      }

      table.console tr:has(+tr td .dispatched) {
          border-bottom: 0px;
      }

      table.console tr:has(+tr td .dispatched) td {
          padding-bottom: 25px;
      }

      .console th {
        background-color: #f0f0f0;
        border-bottom: 1px solid #ccc;
        font-weight: normal;
        padding: 5px;
        text-align: left;
      }

      .console tbody {
        font-family: monospace;
      }

      .console tr {
        border-bottom: 1px solid #ccc;
      }

      .console td {
        padding: 5px;
      }
  
      .console td.timestamp {
        font-size: small;
      }

      .history {
        margin-top: 30px;       
        display: flex;
        overflow: auto;    
        flex-direction: column-reverse;
      }

      .console tr:last-child td {
        border-bottom: none;
      }

      .dispatched {
        font-weight: bold;
      }

      .dispatched > .trigger {
        border: 1px solid #000;
        border-radius: 4px;
        padding: 2px 10px 2px 10px;
      }

      button {
        margin: 5px;
      }

      .dropbtn {
        border: none;
        cursor: pointer;
      }

      .dropbtn:hover, .dropbtn:focus {
        background-color: #f1f1f1;
      }

      .dropdown {
        position: relative;
        display: inline-block;
        margin-left: auto;
      }

      .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        background-color: #f1f1f1;
        min-width: 160px;
        overflow: auto;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }

      .dropdown-content .dropdown-item {
        padding: 12px 16px;
        font-weight: normal;
      }

      .show {display: block;}

      .transition.active {
        stroke: #fff5ad !important;
        stroke-width: 5px !important;
        filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));
      }

      .statediagram-state.active > * {
        fill: #fff5ad !important;
        stroke-width: 2px !important;
      }

    </style>
  </head>

  <body>
    <div class="wrapper">
    <div class="pane main">
        <pre class="mermaid">
stateDiagram

state DISPLAY_STATE {

        BOOT_ANIMATION_STATE

        BOOT_ANIMATION_STATE : BOOT_ANIMATION_STATE

        BOOT_ANIMATION_STATE : enter / #123; startBootupTimer()#59; #125;

        BOOT_ANIMATION_STATE : exit / #123;  #125;

        state WIFI_IMPROV_STATE_UI {

                IMPROV_AWAITING_AUTH_STATE_UI

                IMPROV_AWAITING_AUTH_STATE_UI : IMPROV_AWAITING_AUTH_STATE_UI

                IMPROV_AWAITING_AUTH_STATE_UI : enter / #123; showImprovConfirmationScreen()#59; #125;

                IMPROV_STARTED_STATE

                IMPROV_STARTED_STATE : IMPROV_STARTED_STATE

                IMPROV_STARTED_STATE : enter / #123; showImprovScreen()#59; #125;

                IMPROV_AUTHORIZED_STATE_UI

                IMPROV_AUTHORIZED_STATE_UI : IMPROV_AUTHORIZED_STATE_UI

                IMPROV_AUTHORIZED_STATE_UI : enter / #123; showImprovAuthorizedScreen()#59; #125;

                IMPROV_PROVISIONED_STATE_UI

                IMPROV_PROVISIONED_STATE_UI : IMPROV_PROVISIONED_STATE_UI

                IMPROV_PROVISIONED_STATE_UI : enter / #123; showImprovDoneScreen()#59; #125;

                IMPROV_PROVISIONING_STATE_UI

                IMPROV_PROVISIONING_STATE_UI : IMPROV_PROVISIONING_STATE_UI

                IMPROV_PROVISIONING_STATE_UI : enter / #123; showImprovConnectingScreen()#59; #125;

        }

        state IR_LEARNING_STATE {

                IR_LEARNED_OK_STATE

                IR_LEARNED_OK_STATE : IR_LEARNED_OK_STATE

                IR_LEARNED_OK_STATE : enter / #123; showIrLearnedOkScreen()#59;\nstartIrLearnedOkTimer()#59; #125;

                IR_LEARNED_FAILED_STATE

                IR_LEARNED_FAILED_STATE : IR_LEARNED_FAILED_STATE

                IR_LEARNED_FAILED_STATE : enter / #123; showIrLearnedFailedScreen()#59; #125;

                IR_LEARNING_STARTED_STATE

                IR_LEARNING_STARTED_STATE : IR_LEARNING_STARTED_STATE

                IR_LEARNING_STARTED_STATE : enter / #123; showIrLearningScreen()#59; #125;

        }

        state OTA_STATE {

                OTA_PROGRESS_STATE

                OTA_PROGRESS_STATE : OTA_PROGRESS_STATE

                OTA_PROGRESS_STATE : enter / #123; startOtaTimer()#59;\nupdateOtaScreen()#59; #125;

                OTA_SUCCESS_STATE

                OTA_SUCCESS_STATE : OTA_SUCCESS_STATE

                OTA_SUCCESS_STATE : enter / #123; stopTimer()#59;\nshowOtaSuccessScreen()#59; #125;

                OTA_FAIL_STATE

                OTA_FAIL_STATE : OTA_FAIL_STATE

                OTA_FAIL_STATE : enter / #123; stopTimer()#59;\nshowOtaFailScreen()#59; #125;

                OTA_STARTED_STATE

                OTA_STARTED_STATE : OTA_STARTED_STATE

                OTA_STARTED_STATE : enter / #123; startOtaTimer()#59;\nshowOtaScreen()#59; #125;

                %% Initial state name as "." so that it fits in black circle shape.
                %% See https://github.com/StateSmith/StateSmith/issues/404
                state "." as OTA_STATE.(InitialState)

        }

        state CONNECTING_STATE {

                SHOW_CONNECTED_STATE

                SHOW_CONNECTED_STATE : SHOW_CONNECTED_STATE

                SHOW_CONNECTED_STATE : enter / #123; updateNetworkScreen()#59; #125;

                state "$HC" as CONNECTING_STATE.(HistoryContinue)

                SHOW_CONNECTING_STATE

                SHOW_CONNECTING_STATE : SHOW_CONNECTING_STATE

                SHOW_CONNECTING_STATE : enter / #123; connectingTimerReset()#59;\nupdateConnectingScreen()#59; #125;

        }

        state RUNNING_STATE {

                IDENTIFY_STATE

                IDENTIFY_STATE : IDENTIFY_STATE

                IDENTIFY_STATE : enter / #123; showIdentifyScreen()#59;\nstartRunningTimer()#59; #125;

                IDLE_STATE

                IDLE_STATE : IDLE_STATE

                IDLE_STATE : enter / #123; clearScreen()#59; #125;

                CHARGING_STATE

                CHARGING_STATE : CHARGING_STATE

                CHARGING_STATE : enter / #123; showChargingScreen()#59;\nstartRunningTimer()#59; #125;

                CHARGING_OFF_STATE

                CHARGING_OFF_STATE : CHARGING_OFF_STATE

                CHARGING_OFF_STATE : enter / #123; showChargingOffScreen()#59;\nstartRunningTimer()#59; #125;

                INFO_STATE

                INFO_STATE : INFO_STATE

                INFO_STATE : enter / #123; showInfoScreen()#59;\nstartRunningTimer()#59; #125;

                INFO_NEXT_STATE

                INFO_NEXT_STATE : INFO_NEXT_STATE

                INFO_NEXT_STATE : enter / #123; showNextInfoScreen()#59;\nstartRunningTimer()#59; #125;

        }

        state "$H" as DISPLAY_STATE.(History)

        %% Initial state name as "." so that it fits in black circle shape.
        %% See https://github.com/StateSmith/StateSmith/issues/404
        state "." as DISPLAY_STATE.(InitialState)

}

%% Initial state name as "." so that it fits in black circle shape.
%% See https://github.com/StateSmith/StateSmith/issues/404
state "." as ROOT.(InitialState)

ERROR_STATE

ERROR_STATE : ERROR_STATE

ERROR_STATE : enter / #123; showErrorScreen()#59; #125;

FACTORY_RESET_STATE

FACTORY_RESET_STATE : FACTORY_RESET_STATE

FACTORY_RESET_STATE : enter / #123; resetTimerRestart()#59;\nfactoryReset()#59; #125;

RESET_COUNTDOWN_STATE

RESET_COUNTDOWN_STATE : RESET_COUNTDOWN_STATE

RESET_COUNTDOWN_STATE : enter / #123; resetTimerRestart()#59;\nupdateFactoryResetScreen()#59; #125;

state ROOT.(ChoicePoint)() <<choice>>

REBOOT_STATE

REBOOT_STATE : REBOOT_STATE

REBOOT_STATE : enter / #123; clearScreen()#59; #125;

DISPLAY_STATE --> ERROR_STATE : ERROR

DISPLAY_STATE --> RESET_COUNTDOWN_STATE : BUTTON_LONG_PRESS_START / #123; startFactoryResetScreen()#59; #125;

DISPLAY_STATE --> FACTORY_RESET_STATE : FACTORY_RESET

DISPLAY_STATE --> REBOOT_STATE : REBOOT

BOOT_ANIMATION_STATE --> CONNECTING_STATE : TIMER

WIFI_IMPROV_STATE_UI --> RUNNING_STATE : CONNECTED

WIFI_IMPROV_STATE_UI --> IMPROV_AWAITING_AUTH_STATE_UI : IMPROV_AUTH_REQUIRED

WIFI_IMPROV_STATE_UI --> IMPROV_AUTHORIZED_STATE_UI : IMPROV_AUTHORIZED

WIFI_IMPROV_STATE_UI --> IMPROV_PROVISIONED_STATE_UI : IMPROV_END

WIFI_IMPROV_STATE_UI --> IMPROV_PROVISIONING_STATE_UI : IMPROV_PROVISIONING

WIFI_IMPROV_STATE_UI --> IMPROV_STARTED_STATE : IMPROV_START

IR_LEARNING_STATE --> RUNNING_STATE : IR_LEARNING_STOP

IR_LEARNING_STATE --> CONNECTING_STATE : LOST_CONNECTION

IR_LEARNING_STATE --> OTA_STATE : OTA_START

IR_LEARNING_STATE --> IR_LEARNED_OK_STATE : IR_LEARNING_OK

IR_LEARNING_STATE --> IR_LEARNED_FAILED_STATE : IR_LEARNING_FAILED

IR_LEARNED_OK_STATE --> IR_LEARNING_STARTED_STATE : TIMER

IR_LEARNED_FAILED_STATE --> IR_LEARNING_STARTED_STATE : BUTTON_CLICK

IR_LEARNING_STARTED_STATE --> RUNNING_STATE : BUTTON_CLICK

OTA_STATE --> OTA_PROGRESS_STATE : OTA_PROGRESS

OTA_STATE --> OTA_SUCCESS_STATE : OTA_SUCCESS

OTA_STATE --> OTA_FAIL_STATE : OTA_FAIL

OTA_STATE --> OTA_FAIL_STATE : TIMER

OTA_STATE.(InitialState) --> OTA_STARTED_STATE

CONNECTING_STATE --> IMPROV_STARTED_STATE : IMPROV_START

CONNECTING_STATE --> RUNNING_STATE : CONNECTED

CONNECTING_STATE --> SHOW_CONNECTED_STATE : CONNECTED

CONNECTING_STATE --> SHOW_CONNECTING_STATE : CONNECTING

SHOW_CONNECTED_STATE --> RUNNING_STATE : do

SHOW_CONNECTING_STATE --> SHOW_CONNECTED_STATE : CONNECTED

SHOW_CONNECTING_STATE --> SHOW_CONNECTING_STATE : do [connectingTimerAfter(300)]

RUNNING_STATE --> IR_LEARNING_STARTED_STATE : IR_LEARNING_START

RUNNING_STATE --> CONNECTING_STATE : LOST_CONNECTION

RUNNING_STATE --> OTA_STATE : OTA_START

RUNNING_STATE --> IDENTIFY_STATE : IDENTIFY

RUNNING_STATE --> IDLE_STATE : TIMER

RUNNING_STATE --> CHARGING_STATE : CHARGING_ON

RUNNING_STATE --> CHARGING_OFF_STATE : CHARGING_OFF

RUNNING_STATE --> INFO_STATE : BUTTON_CLICK

INFO_STATE --> INFO_NEXT_STATE : BUTTON_CLICK

INFO_NEXT_STATE --> INFO_NEXT_STATE : BUTTON_CLICK

DISPLAY_STATE.(History) --> BOOT_ANIMATION_STATE

DISPLAY_STATE.(InitialState) --> DISPLAY_STATE.(History)

ROOT.(InitialState) --> DISPLAY_STATE

ERROR_STATE --> DISPLAY_STATE : do

FACTORY_RESET_STATE --> REBOOT_STATE : REBOOT

FACTORY_RESET_STATE --> REBOOT_STATE : do [resetTimerAfter(1000)]

RESET_COUNTDOWN_STATE --> RESET_COUNTDOWN_STATE : do [resetTimerAfter(1000)]

RESET_COUNTDOWN_STATE --> ROOT.(ChoicePoint)() : BUTTON_LONG_PRESS_UP / #123; updateBtnHoldtime()#59; #125;

ROOT.(ChoicePoint)() --> DISPLAY_STATE : [btn_holdtime < kFactoryResetTimeoutMs] / #123; clearScreen()#59; #125;

ROOT.(ChoicePoint)() --> FACTORY_RESET_STATE : else



        </pre>
    </div>

    <div class="pane sidebar">
        <div id="buttons">
            <div class="titlebar">Events            
              <div class='dropdown'>
                <span id='dropbtn' class='titlebar-icon dropbtn'>settings</span>
                <div id='myDropdown' class='dropdown-content'>
                  <div class='dropdown-item'>
                    <input type='checkbox' id='timestamps' name='timestamps' value='Timestamps'>
                    <label for='timestamps'>Timestamps</label>
                  </div>
                </div>
              </div>            
          </div>
        </div>

        <div class="history">
          <table class="console">
            <tbody>
            </tbody>
          </table>
        </div>

        <div class="gutter"></div>
    </div>
    </div>

<script>
// Autogenerated with StateSmith 0.17.1+9cb7486c1587230c52d22d8b6faadd8e2219313c.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class DisplaySm
{
// Null by default.
// May be overridden to override guard evaluation (eg. in a simulator)
evaluateGuard = null;
    static EventId = 
    {
        DO : 0, // The `do` event is special. State event handlers do not consume this event (ancestors all get it too) unless a transition occurs.
        BUTTON_CLICK : 1,
        BUTTON_LONG_PRESS_START : 2,
        BUTTON_LONG_PRESS_UP : 3,
        CHARGING_OFF : 4,
        CHARGING_ON : 5,
        CONNECTED : 6,
        CONNECTING : 7,
        ERROR : 8,
        EXT_PORT_MODE : 9,
        FACTORY_RESET : 10,
        IDENTIFY : 11,
        IMPROV_AUTH_REQUIRED : 12,
        IMPROV_AUTHORIZED : 13,
        IMPROV_END : 14,
        IMPROV_PROVISIONING : 15,
        IMPROV_START : 16,
        IR_LEARNING_FAILED : 17,
        IR_LEARNING_OK : 18,
        IR_LEARNING_START : 19,
        IR_LEARNING_STOP : 20,
        LOST_CONNECTION : 21,
        OTA_FAIL : 22,
        OTA_PROGRESS : 23,
        OTA_START : 24,
        OTA_SUCCESS : 25,
        REBOOT : 26,
        TIMER : 27,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 28;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        DISPLAY_STATE : 1,
        BOOT_ANIMATION_STATE : 2,
        CONNECTING_STATE : 3,
        SHOW_CONNECTED_STATE : 4,
        SHOW_CONNECTING_STATE : 5,
        IR_LEARNING_STATE : 6,
        IR_LEARNED_FAILED_STATE : 7,
        IR_LEARNED_OK_STATE : 8,
        IR_LEARNING_STARTED_STATE : 9,
        OTA_STATE : 10,
        OTA_FAIL_STATE : 11,
        OTA_PROGRESS_STATE : 12,
        OTA_STARTED_STATE : 13,
        OTA_SUCCESS_STATE : 14,
        RUNNING_STATE : 15,
        CHARGING_OFF_STATE : 16,
        CHARGING_STATE : 17,
        IDENTIFY_STATE : 18,
        IDLE_STATE : 19,
        INFO_NEXT_STATE : 20,
        INFO_STATE : 21,
        WIFI_IMPROV_STATE_UI : 22,
        IMPROV_AUTHORIZED_STATE_UI : 23,
        IMPROV_AWAITING_AUTH_STATE_UI : 24,
        IMPROV_PROVISIONED_STATE_UI : 25,
        IMPROV_PROVISIONING_STATE_UI : 26,
        IMPROV_STARTED_STATE : 27,
        ERROR_STATE : 28,
        FACTORY_RESET_STATE : 29,
        REBOOT_STATE : 30,
        RESET_COUNTDOWN_STATE : 31,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 32;
    static { Object.freeze(this.StateIdCount); }
    
    static DISPLAY_STATE_HistoryId = 
    {
        BOOT_ANIMATION_STATE : 0, // default transition
        OTA_STATE : 1,
        CONNECTING_STATE : 2,
        RUNNING_STATE : 3,
        SHOW_CONNECTED_STATE : 4,
        SHOW_CONNECTING_STATE : 5,
    }
    static { Object.freeze(this.DISPLAY_STATE_HistoryId); }

    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Variables. Can be used for inputs, outputs, user variables...
    vars = {
        DISPLAY_STATE_history: undefined,
    };
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition("edge43"); } TransitionTo(DISPLAY_STATE)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition("edge43");`.
                this.tracer?.edgeTransition("edge43");
                
                // Step 3: Enter/move towards transition target `DISPLAY_STATE`.
                this.#DISPLAY_STATE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#DISPLAY_STATE_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: DisplaySm
            case DisplaySm.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: DISPLAY_STATE
            case DisplaySm.StateId.DISPLAY_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break;
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break;
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break;
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break;
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break;
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break;
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break;
                }
                break;
            
            // STATE: BOOT_ANIMATION_STATE
            case DisplaySm.StateId.BOOT_ANIMATION_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.TIMER: this.#BOOT_ANIMATION_STATE_timer(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: CONNECTING_STATE
            case DisplaySm.StateId.CONNECTING_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.IMPROV_START: this.#CONNECTING_STATE_improv_start(); break;
                    case DisplaySm.EventId.CONNECTED: this.#CONNECTING_STATE_connected(); break;
                    case DisplaySm.EventId.CONNECTING: this.#CONNECTING_STATE_connecting(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SHOW_CONNECTED_STATE
            case DisplaySm.StateId.SHOW_CONNECTED_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.DO: this.#SHOW_CONNECTED_STATE_do(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CONNECTED: this.#CONNECTING_STATE_connected(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_START: this.#CONNECTING_STATE_improv_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CONNECTING: this.#CONNECTING_STATE_connecting(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SHOW_CONNECTING_STATE
            case DisplaySm.StateId.SHOW_CONNECTING_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CONNECTED: this.#SHOW_CONNECTING_STATE_connected(); break;
                    case DisplaySm.EventId.DO: this.#SHOW_CONNECTING_STATE_do(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_START: this.#CONNECTING_STATE_improv_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CONNECTING: this.#CONNECTING_STATE_connecting(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IR_LEARNING_STATE
            case DisplaySm.StateId.IR_LEARNING_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.IR_LEARNING_STOP: this.#IR_LEARNING_STATE_ir_learning_stop(); break;
                    case DisplaySm.EventId.LOST_CONNECTION: this.#IR_LEARNING_STATE_lost_connection(); break;
                    case DisplaySm.EventId.OTA_START: this.#IR_LEARNING_STATE_ota_start(); break;
                    case DisplaySm.EventId.IR_LEARNING_OK: this.#IR_LEARNING_STATE_ir_learning_ok(); break;
                    case DisplaySm.EventId.IR_LEARNING_FAILED: this.#IR_LEARNING_STATE_ir_learning_failed(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IR_LEARNED_FAILED_STATE
            case DisplaySm.StateId.IR_LEARNED_FAILED_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.BUTTON_CLICK: this.#IR_LEARNED_FAILED_STATE_button_click(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_STOP: this.#IR_LEARNING_STATE_ir_learning_stop(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#IR_LEARNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#IR_LEARNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_OK: this.#IR_LEARNING_STATE_ir_learning_ok(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_FAILED: this.#IR_LEARNING_STATE_ir_learning_failed(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IR_LEARNED_OK_STATE
            case DisplaySm.StateId.IR_LEARNED_OK_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.TIMER: this.#IR_LEARNED_OK_STATE_timer(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_STOP: this.#IR_LEARNING_STATE_ir_learning_stop(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#IR_LEARNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#IR_LEARNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_OK: this.#IR_LEARNING_STATE_ir_learning_ok(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_FAILED: this.#IR_LEARNING_STATE_ir_learning_failed(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IR_LEARNING_STARTED_STATE
            case DisplaySm.StateId.IR_LEARNING_STARTED_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.BUTTON_CLICK: this.#IR_LEARNING_STARTED_STATE_button_click(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_STOP: this.#IR_LEARNING_STATE_ir_learning_stop(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#IR_LEARNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#IR_LEARNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_OK: this.#IR_LEARNING_STATE_ir_learning_ok(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_FAILED: this.#IR_LEARNING_STATE_ir_learning_failed(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: OTA_STATE
            case DisplaySm.StateId.OTA_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.OTA_PROGRESS: this.#OTA_STATE_ota_progress(); break;
                    case DisplaySm.EventId.OTA_SUCCESS: this.#OTA_STATE_ota_success(); break;
                    case DisplaySm.EventId.OTA_FAIL: this.#OTA_STATE_ota_fail(); break;
                    case DisplaySm.EventId.TIMER: this.#OTA_STATE_timer(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: OTA_FAIL_STATE
            case DisplaySm.StateId.OTA_FAIL_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#OTA_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_PROGRESS: this.#OTA_STATE_ota_progress(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_SUCCESS: this.#OTA_STATE_ota_success(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_FAIL: this.#OTA_STATE_ota_fail(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: OTA_PROGRESS_STATE
            case DisplaySm.StateId.OTA_PROGRESS_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#OTA_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_PROGRESS: this.#OTA_STATE_ota_progress(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_SUCCESS: this.#OTA_STATE_ota_success(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_FAIL: this.#OTA_STATE_ota_fail(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: OTA_STARTED_STATE
            case DisplaySm.StateId.OTA_STARTED_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#OTA_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_PROGRESS: this.#OTA_STATE_ota_progress(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_SUCCESS: this.#OTA_STATE_ota_success(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_FAIL: this.#OTA_STATE_ota_fail(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: OTA_SUCCESS_STATE
            case DisplaySm.StateId.OTA_SUCCESS_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#OTA_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_PROGRESS: this.#OTA_STATE_ota_progress(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_SUCCESS: this.#OTA_STATE_ota_success(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_FAIL: this.#OTA_STATE_ota_fail(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: RUNNING_STATE
            case DisplaySm.StateId.RUNNING_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.IR_LEARNING_START: this.#RUNNING_STATE_ir_learning_start(); break;
                    case DisplaySm.EventId.LOST_CONNECTION: this.#RUNNING_STATE_lost_connection(); break;
                    case DisplaySm.EventId.OTA_START: this.#RUNNING_STATE_ota_start(); break;
                    case DisplaySm.EventId.IDENTIFY: this.#RUNNING_STATE_identify(); break;
                    case DisplaySm.EventId.TIMER: this.#RUNNING_STATE_timer(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#RUNNING_STATE_charging_on(); break;
                    case DisplaySm.EventId.CHARGING_OFF: this.#RUNNING_STATE_charging_off(); break;
                    case DisplaySm.EventId.BUTTON_CLICK: this.#RUNNING_STATE_button_click(); break;
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: CHARGING_OFF_STATE
            case DisplaySm.StateId.CHARGING_OFF_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#RUNNING_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_CLICK: this.#RUNNING_STATE_button_click(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_START: this.#RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IDENTIFY: this.#RUNNING_STATE_identify(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: CHARGING_STATE
            case DisplaySm.StateId.CHARGING_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#RUNNING_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_CLICK: this.#RUNNING_STATE_button_click(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_START: this.#RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IDENTIFY: this.#RUNNING_STATE_identify(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IDENTIFY_STATE
            case DisplaySm.StateId.IDENTIFY_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#RUNNING_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_CLICK: this.#RUNNING_STATE_button_click(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_START: this.#RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IDENTIFY: this.#RUNNING_STATE_identify(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IDLE_STATE
            case DisplaySm.StateId.IDLE_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#RUNNING_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_CLICK: this.#RUNNING_STATE_button_click(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_START: this.#RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IDENTIFY: this.#RUNNING_STATE_identify(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: INFO_NEXT_STATE
            case DisplaySm.StateId.INFO_NEXT_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.BUTTON_CLICK: this.#INFO_NEXT_STATE_button_click(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#RUNNING_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_START: this.#RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IDENTIFY: this.#RUNNING_STATE_identify(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: INFO_STATE
            case DisplaySm.StateId.INFO_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.BUTTON_CLICK: this.#INFO_STATE_button_click(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.TIMER: this.#RUNNING_STATE_timer(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.LOST_CONNECTION: this.#RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.OTA_START: this.#RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IR_LEARNING_START: this.#RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IDENTIFY: this.#RUNNING_STATE_identify(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_IMPROV_STATE_UI
            case DisplaySm.StateId.WIFI_IMPROV_STATE_UI:
                switch (eventId)
                {
                    case DisplaySm.EventId.CONNECTED: this.#WIFI_IMPROV_STATE_UI_connected(); break;
                    case DisplaySm.EventId.IMPROV_AUTH_REQUIRED: this.#WIFI_IMPROV_STATE_UI_improv_auth_required(); break;
                    case DisplaySm.EventId.IMPROV_AUTHORIZED: this.#WIFI_IMPROV_STATE_UI_improv_authorized(); break;
                    case DisplaySm.EventId.IMPROV_END: this.#WIFI_IMPROV_STATE_UI_improv_end(); break;
                    case DisplaySm.EventId.IMPROV_PROVISIONING: this.#WIFI_IMPROV_STATE_UI_improv_provisioning(); break;
                    case DisplaySm.EventId.IMPROV_START: this.#WIFI_IMPROV_STATE_UI_improv_start(); break;
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_AUTHORIZED_STATE_UI
            case DisplaySm.StateId.IMPROV_AUTHORIZED_STATE_UI:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CONNECTED: this.#WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTH_REQUIRED: this.#WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTHORIZED: this.#WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_END: this.#WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_PROVISIONING: this.#WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_START: this.#WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_AWAITING_AUTH_STATE_UI
            case DisplaySm.StateId.IMPROV_AWAITING_AUTH_STATE_UI:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CONNECTED: this.#WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTH_REQUIRED: this.#WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTHORIZED: this.#WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_END: this.#WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_PROVISIONING: this.#WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_START: this.#WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_PROVISIONED_STATE_UI
            case DisplaySm.StateId.IMPROV_PROVISIONED_STATE_UI:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CONNECTED: this.#WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTH_REQUIRED: this.#WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTHORIZED: this.#WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_END: this.#WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_PROVISIONING: this.#WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_START: this.#WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_PROVISIONING_STATE_UI
            case DisplaySm.StateId.IMPROV_PROVISIONING_STATE_UI:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CONNECTED: this.#WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTH_REQUIRED: this.#WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTHORIZED: this.#WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_END: this.#WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_PROVISIONING: this.#WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_START: this.#WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_STARTED_STATE
            case DisplaySm.StateId.IMPROV_STARTED_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.CHARGING_ON: this.#DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CHARGING_OFF: this.#DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.EXT_PORT_MODE: this.#DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.ERROR: this.#DISPLAY_STATE_error(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_START: this.#DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.FACTORY_RESET: this.#DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.REBOOT: this.#DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.CONNECTED: this.#WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTH_REQUIRED: this.#WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_AUTHORIZED: this.#WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_END: this.#WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_PROVISIONING: this.#WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                    case DisplaySm.EventId.IMPROV_START: this.#WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ERROR_STATE
            case DisplaySm.StateId.ERROR_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.DO: this.#ERROR_STATE_do(); break;
                }
                break;
            
            // STATE: FACTORY_RESET_STATE
            case DisplaySm.StateId.FACTORY_RESET_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.REBOOT: this.#FACTORY_RESET_STATE_reboot(); break;
                    case DisplaySm.EventId.DO: this.#FACTORY_RESET_STATE_do(); break;
                }
                break;
            
            // STATE: REBOOT_STATE
            case DisplaySm.StateId.REBOOT_STATE:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: RESET_COUNTDOWN_STATE
            case DisplaySm.StateId.RESET_COUNTDOWN_STATE:
                switch (eventId)
                {
                    case DisplaySm.EventId.DO: this.#RESET_COUNTDOWN_STATE_do(); break;
                    case DisplaySm.EventId.BUTTON_LONG_PRESS_UP: this.#RESET_COUNTDOWN_STATE_button_long_press_up(); break;
                }
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case DisplaySm.StateId.DISPLAY_STATE: this.#DISPLAY_STATE_exit(); break;
                
                case DisplaySm.StateId.BOOT_ANIMATION_STATE: this.#BOOT_ANIMATION_STATE_exit(); break;
                
                case DisplaySm.StateId.CONNECTING_STATE: this.#CONNECTING_STATE_exit(); break;
                
                case DisplaySm.StateId.SHOW_CONNECTED_STATE: this.#SHOW_CONNECTED_STATE_exit(); break;
                
                case DisplaySm.StateId.SHOW_CONNECTING_STATE: this.#SHOW_CONNECTING_STATE_exit(); break;
                
                case DisplaySm.StateId.IR_LEARNING_STATE: this.#IR_LEARNING_STATE_exit(); break;
                
                case DisplaySm.StateId.IR_LEARNED_FAILED_STATE: this.#IR_LEARNED_FAILED_STATE_exit(); break;
                
                case DisplaySm.StateId.IR_LEARNED_OK_STATE: this.#IR_LEARNED_OK_STATE_exit(); break;
                
                case DisplaySm.StateId.IR_LEARNING_STARTED_STATE: this.#IR_LEARNING_STARTED_STATE_exit(); break;
                
                case DisplaySm.StateId.OTA_STATE: this.#OTA_STATE_exit(); break;
                
                case DisplaySm.StateId.OTA_FAIL_STATE: this.#OTA_FAIL_STATE_exit(); break;
                
                case DisplaySm.StateId.OTA_PROGRESS_STATE: this.#OTA_PROGRESS_STATE_exit(); break;
                
                case DisplaySm.StateId.OTA_STARTED_STATE: this.#OTA_STARTED_STATE_exit(); break;
                
                case DisplaySm.StateId.OTA_SUCCESS_STATE: this.#OTA_SUCCESS_STATE_exit(); break;
                
                case DisplaySm.StateId.RUNNING_STATE: this.#RUNNING_STATE_exit(); break;
                
                case DisplaySm.StateId.CHARGING_OFF_STATE: this.#CHARGING_OFF_STATE_exit(); break;
                
                case DisplaySm.StateId.CHARGING_STATE: this.#CHARGING_STATE_exit(); break;
                
                case DisplaySm.StateId.IDENTIFY_STATE: this.#IDENTIFY_STATE_exit(); break;
                
                case DisplaySm.StateId.IDLE_STATE: this.#IDLE_STATE_exit(); break;
                
                case DisplaySm.StateId.INFO_NEXT_STATE: this.#INFO_NEXT_STATE_exit(); break;
                
                case DisplaySm.StateId.INFO_STATE: this.#INFO_STATE_exit(); break;
                
                case DisplaySm.StateId.WIFI_IMPROV_STATE_UI: this.#WIFI_IMPROV_STATE_UI_exit(); break;
                
                case DisplaySm.StateId.IMPROV_AUTHORIZED_STATE_UI: this.#IMPROV_AUTHORIZED_STATE_UI_exit(); break;
                
                case DisplaySm.StateId.IMPROV_AWAITING_AUTH_STATE_UI: this.#IMPROV_AWAITING_AUTH_STATE_UI_exit(); break;
                
                case DisplaySm.StateId.IMPROV_PROVISIONED_STATE_UI: this.#IMPROV_PROVISIONED_STATE_UI_exit(); break;
                
                case DisplaySm.StateId.IMPROV_PROVISIONING_STATE_UI: this.#IMPROV_PROVISIONING_STATE_UI_exit(); break;
                
                case DisplaySm.StateId.IMPROV_STARTED_STATE: this.#IMPROV_STARTED_STATE_exit(); break;
                
                case DisplaySm.StateId.ERROR_STATE: this.#ERROR_STATE_exit(); break;
                
                case DisplaySm.StateId.FACTORY_RESET_STATE: this.#FACTORY_RESET_STATE_exit(); break;
                
                case DisplaySm.StateId.REBOOT_STATE: this.#REBOOT_STATE_exit(); break;
                
                case DisplaySm.StateId.RESET_COUNTDOWN_STATE: this.#RESET_COUNTDOWN_STATE_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        this.stateId = DisplaySm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DISPLAY_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #DISPLAY_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.DISPLAY_STATE;
        
        // DISPLAY_STATE behavior
        // uml: enter / { this.tracer?.enterState('DISPLAY_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('DISPLAY_STATE');`
            this.tracer?.enterState('DISPLAY_STATE');
        } // end of behavior for DISPLAY_STATE
        
        // DISPLAY_STATE behavior
        // uml: enter
        {
            // Step 1: execute action ``
        } // end of behavior for DISPLAY_STATE
    }
    
    #DISPLAY_STATE_exit()
    {
        // DISPLAY_STATE behavior
        // uml: exit / { this.tracer?.exitState('DISPLAY_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('DISPLAY_STATE');`
            this.tracer?.exitState('DISPLAY_STATE');
        } // end of behavior for DISPLAY_STATE
        
        this.stateId = DisplaySm.StateId.ROOT;
    }
    
    #DISPLAY_STATE_button_long_press_start()
    {
        // DISPLAY_STATE behavior
        // uml: BUTTON_LONG_PRESS_START / { this.tracer?.log("⚡ FSM would execute action: " + "startFactoryResetScreen();");this.tracer?.edgeTransition("edge1"); } TransitionTo(RESET_COUNTDOWN_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.log("⚡ FSM would execute action: " + "startFactoryResetScreen();");this.tracer?.edgeTransition("edge1");`.
            this.tracer?.log("⚡ FSM would execute action: " + "startFactoryResetScreen();");this.tracer?.edgeTransition("edge1");
            
            // Step 3: Enter/move towards transition target `RESET_COUNTDOWN_STATE`.
            this.#RESET_COUNTDOWN_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE
        
        // No ancestor handles this event.
    }
    
    #DISPLAY_STATE_charging_off()
    {
        // DISPLAY_STATE behavior
        // uml: CHARGING_OFF / { this.tracer?.log("⚡ FSM would execute action: " + "charging = false;"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "charging = false;");`
            this.tracer?.log("⚡ FSM would execute action: " + "charging = false;");
        } // end of behavior for DISPLAY_STATE
        
        // No ancestor handles this event.
    }
    
    #DISPLAY_STATE_charging_on()
    {
        // DISPLAY_STATE behavior
        // uml: CHARGING_ON / { this.tracer?.log("⚡ FSM would execute action: " + "charging = true;"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "charging = true;");`
            this.tracer?.log("⚡ FSM would execute action: " + "charging = true;");
        } // end of behavior for DISPLAY_STATE
        
        // No ancestor handles this event.
    }
    
    #DISPLAY_STATE_error()
    {
        // DISPLAY_STATE behavior
        // uml: ERROR / { this.tracer?.edgeTransition("edge0"); } TransitionTo(ERROR_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge0");`.
            this.tracer?.edgeTransition("edge0");
            
            // Step 3: Enter/move towards transition target `ERROR_STATE`.
            this.#ERROR_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE
        
        // No ancestor handles this event.
    }
    
    #DISPLAY_STATE_ext_port_mode()
    {
        // DISPLAY_STATE behavior
        // uml: EXT_PORT_MODE / { this.tracer?.log("⚡ FSM would execute action: " + "updateExtPortMode();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "updateExtPortMode();");`
            this.tracer?.log("⚡ FSM would execute action: " + "updateExtPortMode();");
        } // end of behavior for DISPLAY_STATE
        
        // No ancestor handles this event.
    }
    
    #DISPLAY_STATE_factory_reset()
    {
        // DISPLAY_STATE behavior
        // uml: FACTORY_RESET / { this.tracer?.edgeTransition("edge2"); } TransitionTo(FACTORY_RESET_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge2");`.
            this.tracer?.edgeTransition("edge2");
            
            // Step 3: Enter/move towards transition target `FACTORY_RESET_STATE`.
            this.#FACTORY_RESET_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE
        
        // No ancestor handles this event.
    }
    
    #DISPLAY_STATE_reboot()
    {
        // DISPLAY_STATE behavior
        // uml: REBOOT / { this.tracer?.edgeTransition("edge3"); } TransitionTo(REBOOT_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge3");`.
            this.tracer?.edgeTransition("edge3");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE
        
        // No ancestor handles this event.
    }
    
    #DISPLAY_STATE_InitialState_transition()
    {
        // DISPLAY_STATE.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge42"); } TransitionTo(DISPLAY_STATE.<History>)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge42");`.
            this.tracer?.edgeTransition("edge42");
            
            // Step 3: Enter/move towards transition target `DISPLAY_STATE.<History>`.
            // DISPLAY_STATE.<History> is a pseudo state and cannot have an `enter` trigger.
            
            // DISPLAY_STATE.<History> behavior
            // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.OTA_STATE)] / { this.tracer?.log("🕑 History: transitioning to OTA_STATE."); } TransitionTo(OTA_STATE)
            if (this.vars.DISPLAY_STATE_history == DisplaySm.DISPLAY_STATE_HistoryId.OTA_STATE)
            {
                // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("🕑 History: transitioning to OTA_STATE.");`.
                this.tracer?.log("🕑 History: transitioning to OTA_STATE.");
                
                // Step 3: Enter/move towards transition target `OTA_STATE`.
                this.#OTA_STATE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#OTA_STATE_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for DISPLAY_STATE.<History>
            
            // DISPLAY_STATE.<History> behavior
            // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.CONNECTING_STATE)] / { this.tracer?.log("🕑 History: transitioning to CONNECTING_STATE."); } TransitionTo(CONNECTING_STATE)
            if (this.vars.DISPLAY_STATE_history == DisplaySm.DISPLAY_STATE_HistoryId.CONNECTING_STATE)
            {
                // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("🕑 History: transitioning to CONNECTING_STATE.");`.
                this.tracer?.log("🕑 History: transitioning to CONNECTING_STATE.");
                
                // Step 3: Enter/move towards transition target `CONNECTING_STATE`.
                this.#CONNECTING_STATE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for DISPLAY_STATE.<History>
            
            // DISPLAY_STATE.<History> behavior
            // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.RUNNING_STATE)] / { this.tracer?.log("🕑 History: transitioning to RUNNING_STATE."); } TransitionTo(RUNNING_STATE)
            if (this.vars.DISPLAY_STATE_history == DisplaySm.DISPLAY_STATE_HistoryId.RUNNING_STATE)
            {
                // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("🕑 History: transitioning to RUNNING_STATE.");`.
                this.tracer?.log("🕑 History: transitioning to RUNNING_STATE.");
                
                // Step 3: Enter/move towards transition target `RUNNING_STATE`.
                this.#RUNNING_STATE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for DISPLAY_STATE.<History>
            
            // DISPLAY_STATE.<History> behavior
            // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.SHOW_CONNECTED_STATE)] / { this.tracer?.log("🕑 History: transitioning to SHOW_CONNECTED_STATE."); } TransitionTo(SHOW_CONNECTED_STATE)
            if (this.vars.DISPLAY_STATE_history == DisplaySm.DISPLAY_STATE_HistoryId.SHOW_CONNECTED_STATE)
            {
                // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("🕑 History: transitioning to SHOW_CONNECTED_STATE.");`.
                this.tracer?.log("🕑 History: transitioning to SHOW_CONNECTED_STATE.");
                
                // Step 3: Enter/move towards transition target `SHOW_CONNECTED_STATE`.
                this.#CONNECTING_STATE_enter();
                this.#SHOW_CONNECTED_STATE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for DISPLAY_STATE.<History>
            
            // DISPLAY_STATE.<History> behavior
            // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.SHOW_CONNECTING_STATE)] / { this.tracer?.log("🕑 History: transitioning to SHOW_CONNECTING_STATE."); } TransitionTo(SHOW_CONNECTING_STATE)
            if (this.vars.DISPLAY_STATE_history == DisplaySm.DISPLAY_STATE_HistoryId.SHOW_CONNECTING_STATE)
            {
                // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("🕑 History: transitioning to SHOW_CONNECTING_STATE.");`.
                this.tracer?.log("🕑 History: transitioning to SHOW_CONNECTING_STATE.");
                
                // Step 3: Enter/move towards transition target `SHOW_CONNECTING_STATE`.
                this.#CONNECTING_STATE_enter();
                this.#SHOW_CONNECTING_STATE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for DISPLAY_STATE.<History>
            
            // DISPLAY_STATE.<History> behavior
            // uml: else / { this.tracer?.log("🕑 History: default transition.");this.tracer?.edgeTransition("edge41"); } TransitionTo(BOOT_ANIMATION_STATE)
            {
                // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("🕑 History: default transition.");this.tracer?.edgeTransition("edge41");`.
                this.tracer?.log("🕑 History: default transition.");this.tracer?.edgeTransition("edge41");
                
                // Step 3: Enter/move towards transition target `BOOT_ANIMATION_STATE`.
                this.#BOOT_ANIMATION_STATE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for DISPLAY_STATE.<History>
        } // end of behavior for DISPLAY_STATE.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state BOOT_ANIMATION_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #BOOT_ANIMATION_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.BOOT_ANIMATION_STATE;
        
        // BOOT_ANIMATION_STATE behavior
        // uml: enter / { this.tracer?.enterState('BOOT_ANIMATION_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('BOOT_ANIMATION_STATE');`
            this.tracer?.enterState('BOOT_ANIMATION_STATE');
        } // end of behavior for BOOT_ANIMATION_STATE
        
        // BOOT_ANIMATION_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "startBootupTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "startBootupTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "startBootupTimer();");
        } // end of behavior for BOOT_ANIMATION_STATE
        
        // BOOT_ANIMATION_STATE behavior
        // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.BOOT_ANIMATION_STATE;) }
        {
            // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.BOOT_ANIMATION_STATE;)`
            this.vars.DISPLAY_STATE_history = DisplaySm.DISPLAY_STATE_HistoryId.BOOT_ANIMATION_STATE;
        } // end of behavior for BOOT_ANIMATION_STATE
    }
    
    #BOOT_ANIMATION_STATE_exit()
    {
        // BOOT_ANIMATION_STATE behavior
        // uml: exit
        {
            // Step 1: execute action ``
        } // end of behavior for BOOT_ANIMATION_STATE
        
        // BOOT_ANIMATION_STATE behavior
        // uml: exit / { this.tracer?.exitState('BOOT_ANIMATION_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('BOOT_ANIMATION_STATE');`
            this.tracer?.exitState('BOOT_ANIMATION_STATE');
        } // end of behavior for BOOT_ANIMATION_STATE
        
        this.stateId = DisplaySm.StateId.DISPLAY_STATE;
    }
    
    #BOOT_ANIMATION_STATE_timer()
    {
        // BOOT_ANIMATION_STATE behavior
        // uml: TIMER / { this.tracer?.edgeTransition("edge4"); } TransitionTo(CONNECTING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#BOOT_ANIMATION_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge4");`.
            this.tracer?.edgeTransition("edge4");
            
            // Step 3: Enter/move towards transition target `CONNECTING_STATE`.
            this.#CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for BOOT_ANIMATION_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CONNECTING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #CONNECTING_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.CONNECTING_STATE;
        
        // CONNECTING_STATE behavior
        // uml: enter / { this.tracer?.enterState('CONNECTING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('CONNECTING_STATE');`
            this.tracer?.enterState('CONNECTING_STATE');
        } // end of behavior for CONNECTING_STATE
        
        // CONNECTING_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "updateNetworkScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "updateNetworkScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "updateNetworkScreen();");
        } // end of behavior for CONNECTING_STATE
        
        // CONNECTING_STATE behavior
        // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.CONNECTING_STATE;) }
        {
            // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.CONNECTING_STATE;)`
            this.vars.DISPLAY_STATE_history = DisplaySm.DISPLAY_STATE_HistoryId.CONNECTING_STATE;
        } // end of behavior for CONNECTING_STATE
    }
    
    #CONNECTING_STATE_exit()
    {
        // CONNECTING_STATE behavior
        // uml: exit / { this.tracer?.exitState('CONNECTING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('CONNECTING_STATE');`
            this.tracer?.exitState('CONNECTING_STATE');
        } // end of behavior for CONNECTING_STATE
        
        this.stateId = DisplaySm.StateId.DISPLAY_STATE;
    }
    
    #CONNECTING_STATE_connected()
    {
        // CONNECTING_STATE behavior
        // uml: CONNECTED / { this.tracer?.edgeTransition("edge25"); } TransitionTo(RUNNING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge25");`.
            this.tracer?.edgeTransition("edge25");
            
            // Step 3: Enter/move towards transition target `RUNNING_STATE`.
            this.#RUNNING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CONNECTING_STATE
        
        // unreachable behavior: `CONNECTED / { this.tracer?.edgeTransition("edge26"); } TransitionTo(SHOW_CONNECTED_STATE)` due to unconditional transition above
        
        // No ancestor handles this event.
    }
    
    #CONNECTING_STATE_connecting()
    {
        // CONNECTING_STATE behavior
        // uml: CONNECTING / { this.tracer?.edgeTransition("edge27"); } TransitionTo(SHOW_CONNECTING_STATE)
        {
            // Step 1: Exit states until we reach `CONNECTING_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.CONNECTING_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge27");`.
            this.tracer?.edgeTransition("edge27");
            
            // Step 3: Enter/move towards transition target `SHOW_CONNECTING_STATE`.
            this.#SHOW_CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CONNECTING_STATE
        
        // No ancestor handles this event.
    }
    
    #CONNECTING_STATE_improv_start()
    {
        // CONNECTING_STATE behavior
        // uml: IMPROV_START / { this.tracer?.edgeTransition("edge24"); } TransitionTo(IMPROV_STARTED_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge24");`.
            this.tracer?.edgeTransition("edge24");
            
            // Step 3: Enter/move towards transition target `IMPROV_STARTED_STATE`.
            this.#WIFI_IMPROV_STATE_UI_enter();
            this.#IMPROV_STARTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CONNECTING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SHOW_CONNECTED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #SHOW_CONNECTED_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.SHOW_CONNECTED_STATE;
        
        // SHOW_CONNECTED_STATE behavior
        // uml: enter / { this.tracer?.enterState('SHOW_CONNECTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SHOW_CONNECTED_STATE');`
            this.tracer?.enterState('SHOW_CONNECTED_STATE');
        } // end of behavior for SHOW_CONNECTED_STATE
        
        // SHOW_CONNECTED_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "updateNetworkScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "updateNetworkScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "updateNetworkScreen();");
        } // end of behavior for SHOW_CONNECTED_STATE
        
        // SHOW_CONNECTED_STATE behavior
        // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.SHOW_CONNECTED_STATE;) }
        {
            // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.SHOW_CONNECTED_STATE;)`
            this.vars.DISPLAY_STATE_history = DisplaySm.DISPLAY_STATE_HistoryId.SHOW_CONNECTED_STATE;
        } // end of behavior for SHOW_CONNECTED_STATE
    }
    
    #SHOW_CONNECTED_STATE_exit()
    {
        // SHOW_CONNECTED_STATE behavior
        // uml: exit / { this.tracer?.exitState('SHOW_CONNECTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SHOW_CONNECTED_STATE');`
            this.tracer?.exitState('SHOW_CONNECTED_STATE');
        } // end of behavior for SHOW_CONNECTED_STATE
        
        this.stateId = DisplaySm.StateId.CONNECTING_STATE;
    }
    
    #SHOW_CONNECTED_STATE_do()
    {
        // SHOW_CONNECTED_STATE behavior
        // uml: do / { this.tracer?.edgeTransition("edge28"); } TransitionTo(RUNNING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge28");`.
            this.tracer?.edgeTransition("edge28");
            
            // Step 3: Enter/move towards transition target `RUNNING_STATE`.
            this.#RUNNING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SHOW_CONNECTED_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SHOW_CONNECTING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #SHOW_CONNECTING_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.SHOW_CONNECTING_STATE;
        
        // SHOW_CONNECTING_STATE behavior
        // uml: enter / { this.tracer?.enterState('SHOW_CONNECTING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SHOW_CONNECTING_STATE');`
            this.tracer?.enterState('SHOW_CONNECTING_STATE');
        } // end of behavior for SHOW_CONNECTING_STATE
        
        // SHOW_CONNECTING_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "connectingTimerReset();\nupdateConnectingScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "connectingTimerReset();\nupdateConnectingScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "connectingTimerReset();\nupdateConnectingScreen();");
        } // end of behavior for SHOW_CONNECTING_STATE
        
        // SHOW_CONNECTING_STATE behavior
        // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.SHOW_CONNECTING_STATE;) }
        {
            // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.SHOW_CONNECTING_STATE;)`
            this.vars.DISPLAY_STATE_history = DisplaySm.DISPLAY_STATE_HistoryId.SHOW_CONNECTING_STATE;
        } // end of behavior for SHOW_CONNECTING_STATE
    }
    
    #SHOW_CONNECTING_STATE_exit()
    {
        // SHOW_CONNECTING_STATE behavior
        // uml: exit / { this.tracer?.exitState('SHOW_CONNECTING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SHOW_CONNECTING_STATE');`
            this.tracer?.exitState('SHOW_CONNECTING_STATE');
        } // end of behavior for SHOW_CONNECTING_STATE
        
        this.stateId = DisplaySm.StateId.CONNECTING_STATE;
    }
    
    #SHOW_CONNECTING_STATE_connected()
    {
        let consume_event = false;
        
        // SHOW_CONNECTING_STATE behavior
        // uml: CONNECTED / { this.tracer?.edgeTransition("edge29"); } TransitionTo(SHOW_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `CONNECTING_STATE` state (Least Common Ancestor for transition).
            this.#SHOW_CONNECTING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge29");`.
            this.tracer?.edgeTransition("edge29");
            
            // Step 3: Enter/move towards transition target `SHOW_CONNECTED_STATE`.
            this.#SHOW_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SHOW_CONNECTING_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#CONNECTING_STATE_connected();
        }
    }
    
    #SHOW_CONNECTING_STATE_do()
    {
        // SHOW_CONNECTING_STATE behavior
        // uml: do [this.tracer?.log("🛡️ User evaluating guard: " + "connectingTimerAfter(300)") || this.evaluateGuard("SHOW_CONNECTING_STATE","do [connectingTimerAfter(300)] TransitionTo(SHOW_CONNECTING_STATE)")] / { this.tracer?.edgeTransition("edge30"); } TransitionTo(SHOW_CONNECTING_STATE)
        if (this.tracer?.log("🛡️ User evaluating guard: " + "connectingTimerAfter(300)") || this.evaluateGuard("SHOW_CONNECTING_STATE","do [connectingTimerAfter(300)] TransitionTo(SHOW_CONNECTING_STATE)"))
        {
            // Step 1: Exit states until we reach `CONNECTING_STATE` state (Least Common Ancestor for transition).
            this.#SHOW_CONNECTING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge30");`.
            this.tracer?.edgeTransition("edge30");
            
            // Step 3: Enter/move towards transition target `SHOW_CONNECTING_STATE`.
            this.#SHOW_CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SHOW_CONNECTING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IR_LEARNING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IR_LEARNING_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.IR_LEARNING_STATE;
        
        // IR_LEARNING_STATE behavior
        // uml: enter / { this.tracer?.enterState('IR_LEARNING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IR_LEARNING_STATE');`
            this.tracer?.enterState('IR_LEARNING_STATE');
        } // end of behavior for IR_LEARNING_STATE
    }
    
    #IR_LEARNING_STATE_exit()
    {
        // IR_LEARNING_STATE behavior
        // uml: exit / { this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nstopIrLearning();\nclearScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nstopIrLearning();\nclearScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nstopIrLearning();\nclearScreen();");
        } // end of behavior for IR_LEARNING_STATE
        
        // IR_LEARNING_STATE behavior
        // uml: exit / { this.tracer?.exitState('IR_LEARNING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IR_LEARNING_STATE');`
            this.tracer?.exitState('IR_LEARNING_STATE');
        } // end of behavior for IR_LEARNING_STATE
        
        this.stateId = DisplaySm.StateId.DISPLAY_STATE;
    }
    
    #IR_LEARNING_STATE_ir_learning_failed()
    {
        // IR_LEARNING_STATE behavior
        // uml: IR_LEARNING_FAILED / { this.tracer?.edgeTransition("edge15"); } TransitionTo(IR_LEARNED_FAILED_STATE)
        {
            // Step 1: Exit states until we reach `IR_LEARNING_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.IR_LEARNING_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge15");`.
            this.tracer?.edgeTransition("edge15");
            
            // Step 3: Enter/move towards transition target `IR_LEARNED_FAILED_STATE`.
            this.#IR_LEARNED_FAILED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IR_LEARNING_STATE
        
        // No ancestor handles this event.
    }
    
    #IR_LEARNING_STATE_ir_learning_ok()
    {
        // IR_LEARNING_STATE behavior
        // uml: IR_LEARNING_OK / { this.tracer?.edgeTransition("edge14"); } TransitionTo(IR_LEARNED_OK_STATE)
        {
            // Step 1: Exit states until we reach `IR_LEARNING_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.IR_LEARNING_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge14");`.
            this.tracer?.edgeTransition("edge14");
            
            // Step 3: Enter/move towards transition target `IR_LEARNED_OK_STATE`.
            this.#IR_LEARNED_OK_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IR_LEARNING_STATE
        
        // No ancestor handles this event.
    }
    
    #IR_LEARNING_STATE_ir_learning_stop()
    {
        // IR_LEARNING_STATE behavior
        // uml: IR_LEARNING_STOP / { this.tracer?.edgeTransition("edge11"); } TransitionTo(RUNNING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge11");`.
            this.tracer?.edgeTransition("edge11");
            
            // Step 3: Enter/move towards transition target `RUNNING_STATE`.
            this.#RUNNING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IR_LEARNING_STATE
        
        // No ancestor handles this event.
    }
    
    #IR_LEARNING_STATE_lost_connection()
    {
        // IR_LEARNING_STATE behavior
        // uml: LOST_CONNECTION / { this.tracer?.edgeTransition("edge12"); } TransitionTo(CONNECTING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge12");`.
            this.tracer?.edgeTransition("edge12");
            
            // Step 3: Enter/move towards transition target `CONNECTING_STATE`.
            this.#CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IR_LEARNING_STATE
        
        // No ancestor handles this event.
    }
    
    #IR_LEARNING_STATE_ota_start()
    {
        // IR_LEARNING_STATE behavior
        // uml: OTA_START / { this.tracer?.edgeTransition("edge13"); } TransitionTo(OTA_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge13");`.
            this.tracer?.edgeTransition("edge13");
            
            // Step 3: Enter/move towards transition target `OTA_STATE`.
            this.#OTA_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#OTA_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for IR_LEARNING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IR_LEARNED_FAILED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IR_LEARNED_FAILED_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.IR_LEARNED_FAILED_STATE;
        
        // IR_LEARNED_FAILED_STATE behavior
        // uml: enter / { this.tracer?.enterState('IR_LEARNED_FAILED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IR_LEARNED_FAILED_STATE');`
            this.tracer?.enterState('IR_LEARNED_FAILED_STATE');
        } // end of behavior for IR_LEARNED_FAILED_STATE
        
        // IR_LEARNED_FAILED_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showIrLearnedFailedScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showIrLearnedFailedScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showIrLearnedFailedScreen();");
        } // end of behavior for IR_LEARNED_FAILED_STATE
    }
    
    #IR_LEARNED_FAILED_STATE_exit()
    {
        // IR_LEARNED_FAILED_STATE behavior
        // uml: exit / { this.tracer?.exitState('IR_LEARNED_FAILED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IR_LEARNED_FAILED_STATE');`
            this.tracer?.exitState('IR_LEARNED_FAILED_STATE');
        } // end of behavior for IR_LEARNED_FAILED_STATE
        
        this.stateId = DisplaySm.StateId.IR_LEARNING_STATE;
    }
    
    #IR_LEARNED_FAILED_STATE_button_click()
    {
        // IR_LEARNED_FAILED_STATE behavior
        // uml: BUTTON_CLICK / { this.tracer?.edgeTransition("edge17"); } TransitionTo(IR_LEARNING_STARTED_STATE)
        {
            // Step 1: Exit states until we reach `IR_LEARNING_STATE` state (Least Common Ancestor for transition).
            this.#IR_LEARNED_FAILED_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge17");`.
            this.tracer?.edgeTransition("edge17");
            
            // Step 3: Enter/move towards transition target `IR_LEARNING_STARTED_STATE`.
            this.#IR_LEARNING_STARTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IR_LEARNED_FAILED_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IR_LEARNED_OK_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IR_LEARNED_OK_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.IR_LEARNED_OK_STATE;
        
        // IR_LEARNED_OK_STATE behavior
        // uml: enter / { this.tracer?.enterState('IR_LEARNED_OK_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IR_LEARNED_OK_STATE');`
            this.tracer?.enterState('IR_LEARNED_OK_STATE');
        } // end of behavior for IR_LEARNED_OK_STATE
        
        // IR_LEARNED_OK_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showIrLearnedOkScreen();\nstartIrLearnedOkTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showIrLearnedOkScreen();\nstartIrLearnedOkTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showIrLearnedOkScreen();\nstartIrLearnedOkTimer();");
        } // end of behavior for IR_LEARNED_OK_STATE
    }
    
    #IR_LEARNED_OK_STATE_exit()
    {
        // IR_LEARNED_OK_STATE behavior
        // uml: exit / { this.tracer?.exitState('IR_LEARNED_OK_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IR_LEARNED_OK_STATE');`
            this.tracer?.exitState('IR_LEARNED_OK_STATE');
        } // end of behavior for IR_LEARNED_OK_STATE
        
        this.stateId = DisplaySm.StateId.IR_LEARNING_STATE;
    }
    
    #IR_LEARNED_OK_STATE_timer()
    {
        // IR_LEARNED_OK_STATE behavior
        // uml: TIMER / { this.tracer?.edgeTransition("edge16"); } TransitionTo(IR_LEARNING_STARTED_STATE)
        {
            // Step 1: Exit states until we reach `IR_LEARNING_STATE` state (Least Common Ancestor for transition).
            this.#IR_LEARNED_OK_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge16");`.
            this.tracer?.edgeTransition("edge16");
            
            // Step 3: Enter/move towards transition target `IR_LEARNING_STARTED_STATE`.
            this.#IR_LEARNING_STARTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IR_LEARNED_OK_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IR_LEARNING_STARTED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IR_LEARNING_STARTED_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.IR_LEARNING_STARTED_STATE;
        
        // IR_LEARNING_STARTED_STATE behavior
        // uml: enter / { this.tracer?.enterState('IR_LEARNING_STARTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IR_LEARNING_STARTED_STATE');`
            this.tracer?.enterState('IR_LEARNING_STARTED_STATE');
        } // end of behavior for IR_LEARNING_STARTED_STATE
        
        // IR_LEARNING_STARTED_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showIrLearningScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showIrLearningScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showIrLearningScreen();");
        } // end of behavior for IR_LEARNING_STARTED_STATE
    }
    
    #IR_LEARNING_STARTED_STATE_exit()
    {
        // IR_LEARNING_STARTED_STATE behavior
        // uml: exit / { this.tracer?.exitState('IR_LEARNING_STARTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IR_LEARNING_STARTED_STATE');`
            this.tracer?.exitState('IR_LEARNING_STARTED_STATE');
        } // end of behavior for IR_LEARNING_STARTED_STATE
        
        this.stateId = DisplaySm.StateId.IR_LEARNING_STATE;
    }
    
    #IR_LEARNING_STARTED_STATE_button_click()
    {
        // IR_LEARNING_STARTED_STATE behavior
        // uml: BUTTON_CLICK / { this.tracer?.edgeTransition("edge18"); } TransitionTo(RUNNING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge18");`.
            this.tracer?.edgeTransition("edge18");
            
            // Step 3: Enter/move towards transition target `RUNNING_STATE`.
            this.#RUNNING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IR_LEARNING_STARTED_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state OTA_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #OTA_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.OTA_STATE;
        
        // OTA_STATE behavior
        // uml: enter / { this.tracer?.enterState('OTA_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('OTA_STATE');`
            this.tracer?.enterState('OTA_STATE');
        } // end of behavior for OTA_STATE
        
        // OTA_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();");
        } // end of behavior for OTA_STATE
        
        // OTA_STATE behavior
        // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.OTA_STATE;) }
        {
            // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.OTA_STATE;)`
            this.vars.DISPLAY_STATE_history = DisplaySm.DISPLAY_STATE_HistoryId.OTA_STATE;
        } // end of behavior for OTA_STATE
    }
    
    #OTA_STATE_exit()
    {
        // OTA_STATE behavior
        // uml: exit / { this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();");
        } // end of behavior for OTA_STATE
        
        // OTA_STATE behavior
        // uml: exit / { this.tracer?.exitState('OTA_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('OTA_STATE');`
            this.tracer?.exitState('OTA_STATE');
        } // end of behavior for OTA_STATE
        
        this.stateId = DisplaySm.StateId.DISPLAY_STATE;
    }
    
    #OTA_STATE_ota_fail()
    {
        // OTA_STATE behavior
        // uml: OTA_FAIL / { this.tracer?.edgeTransition("edge21"); } TransitionTo(OTA_FAIL_STATE)
        {
            // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.OTA_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge21");`.
            this.tracer?.edgeTransition("edge21");
            
            // Step 3: Enter/move towards transition target `OTA_FAIL_STATE`.
            this.#OTA_FAIL_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for OTA_STATE
        
        // No ancestor handles this event.
    }
    
    #OTA_STATE_ota_progress()
    {
        // OTA_STATE behavior
        // uml: OTA_PROGRESS / { this.tracer?.edgeTransition("edge19"); } TransitionTo(OTA_PROGRESS_STATE)
        {
            // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.OTA_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge19");`.
            this.tracer?.edgeTransition("edge19");
            
            // Step 3: Enter/move towards transition target `OTA_PROGRESS_STATE`.
            this.#OTA_PROGRESS_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for OTA_STATE
        
        // No ancestor handles this event.
    }
    
    #OTA_STATE_ota_success()
    {
        // OTA_STATE behavior
        // uml: OTA_SUCCESS / { this.tracer?.edgeTransition("edge20"); } TransitionTo(OTA_SUCCESS_STATE)
        {
            // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.OTA_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge20");`.
            this.tracer?.edgeTransition("edge20");
            
            // Step 3: Enter/move towards transition target `OTA_SUCCESS_STATE`.
            this.#OTA_SUCCESS_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for OTA_STATE
        
        // No ancestor handles this event.
    }
    
    #OTA_STATE_timer()
    {
        // OTA_STATE behavior
        // uml: TIMER / { this.tracer?.edgeTransition("edge22"); } TransitionTo(OTA_FAIL_STATE)
        {
            // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.OTA_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge22");`.
            this.tracer?.edgeTransition("edge22");
            
            // Step 3: Enter/move towards transition target `OTA_FAIL_STATE`.
            this.#OTA_FAIL_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for OTA_STATE
        
        // No ancestor handles this event.
    }
    
    #OTA_STATE_InitialState_transition()
    {
        // OTA_STATE.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge23"); } TransitionTo(OTA_STARTED_STATE)
        {
            // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge23");`.
            this.tracer?.edgeTransition("edge23");
            
            // Step 3: Enter/move towards transition target `OTA_STARTED_STATE`.
            this.#OTA_STARTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for OTA_STATE.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state OTA_FAIL_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #OTA_FAIL_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.OTA_FAIL_STATE;
        
        // OTA_FAIL_STATE behavior
        // uml: enter / { this.tracer?.enterState('OTA_FAIL_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('OTA_FAIL_STATE');`
            this.tracer?.enterState('OTA_FAIL_STATE');
        } // end of behavior for OTA_FAIL_STATE
        
        // OTA_FAIL_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nshowOtaFailScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nshowOtaFailScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nshowOtaFailScreen();");
        } // end of behavior for OTA_FAIL_STATE
    }
    
    #OTA_FAIL_STATE_exit()
    {
        // OTA_FAIL_STATE behavior
        // uml: exit / { this.tracer?.exitState('OTA_FAIL_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('OTA_FAIL_STATE');`
            this.tracer?.exitState('OTA_FAIL_STATE');
        } // end of behavior for OTA_FAIL_STATE
        
        this.stateId = DisplaySm.StateId.OTA_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state OTA_PROGRESS_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #OTA_PROGRESS_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.OTA_PROGRESS_STATE;
        
        // OTA_PROGRESS_STATE behavior
        // uml: enter / { this.tracer?.enterState('OTA_PROGRESS_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('OTA_PROGRESS_STATE');`
            this.tracer?.enterState('OTA_PROGRESS_STATE');
        } // end of behavior for OTA_PROGRESS_STATE
        
        // OTA_PROGRESS_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();\nupdateOtaScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();\nupdateOtaScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();\nupdateOtaScreen();");
        } // end of behavior for OTA_PROGRESS_STATE
    }
    
    #OTA_PROGRESS_STATE_exit()
    {
        // OTA_PROGRESS_STATE behavior
        // uml: exit / { this.tracer?.exitState('OTA_PROGRESS_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('OTA_PROGRESS_STATE');`
            this.tracer?.exitState('OTA_PROGRESS_STATE');
        } // end of behavior for OTA_PROGRESS_STATE
        
        this.stateId = DisplaySm.StateId.OTA_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state OTA_STARTED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #OTA_STARTED_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.OTA_STARTED_STATE;
        
        // OTA_STARTED_STATE behavior
        // uml: enter / { this.tracer?.enterState('OTA_STARTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('OTA_STARTED_STATE');`
            this.tracer?.enterState('OTA_STARTED_STATE');
        } // end of behavior for OTA_STARTED_STATE
        
        // OTA_STARTED_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();\nshowOtaScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();\nshowOtaScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "startOtaTimer();\nshowOtaScreen();");
        } // end of behavior for OTA_STARTED_STATE
    }
    
    #OTA_STARTED_STATE_exit()
    {
        // OTA_STARTED_STATE behavior
        // uml: exit / { this.tracer?.exitState('OTA_STARTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('OTA_STARTED_STATE');`
            this.tracer?.exitState('OTA_STARTED_STATE');
        } // end of behavior for OTA_STARTED_STATE
        
        this.stateId = DisplaySm.StateId.OTA_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state OTA_SUCCESS_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #OTA_SUCCESS_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.OTA_SUCCESS_STATE;
        
        // OTA_SUCCESS_STATE behavior
        // uml: enter / { this.tracer?.enterState('OTA_SUCCESS_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('OTA_SUCCESS_STATE');`
            this.tracer?.enterState('OTA_SUCCESS_STATE');
        } // end of behavior for OTA_SUCCESS_STATE
        
        // OTA_SUCCESS_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nshowOtaSuccessScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nshowOtaSuccessScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();\nshowOtaSuccessScreen();");
        } // end of behavior for OTA_SUCCESS_STATE
    }
    
    #OTA_SUCCESS_STATE_exit()
    {
        // OTA_SUCCESS_STATE behavior
        // uml: exit / { this.tracer?.exitState('OTA_SUCCESS_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('OTA_SUCCESS_STATE');`
            this.tracer?.exitState('OTA_SUCCESS_STATE');
        } // end of behavior for OTA_SUCCESS_STATE
        
        this.stateId = DisplaySm.StateId.OTA_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state RUNNING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #RUNNING_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.RUNNING_STATE;
        
        // RUNNING_STATE behavior
        // uml: enter / { this.tracer?.enterState('RUNNING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('RUNNING_STATE');`
            this.tracer?.enterState('RUNNING_STATE');
        } // end of behavior for RUNNING_STATE
        
        // RUNNING_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "startRunningTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "startRunningTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "startRunningTimer();");
        } // end of behavior for RUNNING_STATE
        
        // RUNNING_STATE behavior
        // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.RUNNING_STATE;) }
        {
            // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.RUNNING_STATE;)`
            this.vars.DISPLAY_STATE_history = DisplaySm.DISPLAY_STATE_HistoryId.RUNNING_STATE;
        } // end of behavior for RUNNING_STATE
    }
    
    #RUNNING_STATE_exit()
    {
        // RUNNING_STATE behavior
        // uml: exit / { this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "stopTimer();");
        } // end of behavior for RUNNING_STATE
        
        // RUNNING_STATE behavior
        // uml: exit / { this.tracer?.exitState('RUNNING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('RUNNING_STATE');`
            this.tracer?.exitState('RUNNING_STATE');
        } // end of behavior for RUNNING_STATE
        
        this.stateId = DisplaySm.StateId.DISPLAY_STATE;
    }
    
    #RUNNING_STATE_button_click()
    {
        // RUNNING_STATE behavior
        // uml: BUTTON_CLICK / { this.tracer?.edgeTransition("edge38"); } TransitionTo(INFO_STATE)
        {
            // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.RUNNING_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge38");`.
            this.tracer?.edgeTransition("edge38");
            
            // Step 3: Enter/move towards transition target `INFO_STATE`.
            this.#INFO_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING_STATE
        
        // No ancestor handles this event.
    }
    
    #RUNNING_STATE_charging_off()
    {
        let consume_event = false;
        
        // RUNNING_STATE behavior
        // uml: CHARGING_OFF / { this.tracer?.edgeTransition("edge37"); } TransitionTo(CHARGING_OFF_STATE)
        {
            // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.RUNNING_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge37");`.
            this.tracer?.edgeTransition("edge37");
            
            // Step 3: Enter/move towards transition target `CHARGING_OFF_STATE`.
            this.#CHARGING_OFF_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#DISPLAY_STATE_charging_off();
        }
    }
    
    #RUNNING_STATE_charging_on()
    {
        let consume_event = false;
        
        // RUNNING_STATE behavior
        // uml: CHARGING_ON / { this.tracer?.edgeTransition("edge36"); } TransitionTo(CHARGING_STATE)
        {
            // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.RUNNING_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge36");`.
            this.tracer?.edgeTransition("edge36");
            
            // Step 3: Enter/move towards transition target `CHARGING_STATE`.
            this.#CHARGING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#DISPLAY_STATE_charging_on();
        }
    }
    
    #RUNNING_STATE_identify()
    {
        // RUNNING_STATE behavior
        // uml: IDENTIFY / { this.tracer?.edgeTransition("edge34"); } TransitionTo(IDENTIFY_STATE)
        {
            // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.RUNNING_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge34");`.
            this.tracer?.edgeTransition("edge34");
            
            // Step 3: Enter/move towards transition target `IDENTIFY_STATE`.
            this.#IDENTIFY_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING_STATE
        
        // No ancestor handles this event.
    }
    
    #RUNNING_STATE_ir_learning_start()
    {
        // RUNNING_STATE behavior
        // uml: IR_LEARNING_START / { this.tracer?.edgeTransition("edge31"); } TransitionTo(IR_LEARNING_STARTED_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge31");`.
            this.tracer?.edgeTransition("edge31");
            
            // Step 3: Enter/move towards transition target `IR_LEARNING_STARTED_STATE`.
            this.#IR_LEARNING_STATE_enter();
            this.#IR_LEARNING_STARTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING_STATE
        
        // No ancestor handles this event.
    }
    
    #RUNNING_STATE_lost_connection()
    {
        // RUNNING_STATE behavior
        // uml: LOST_CONNECTION / { this.tracer?.edgeTransition("edge32"); } TransitionTo(CONNECTING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge32");`.
            this.tracer?.edgeTransition("edge32");
            
            // Step 3: Enter/move towards transition target `CONNECTING_STATE`.
            this.#CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING_STATE
        
        // No ancestor handles this event.
    }
    
    #RUNNING_STATE_ota_start()
    {
        // RUNNING_STATE behavior
        // uml: OTA_START / { this.tracer?.edgeTransition("edge33"); } TransitionTo(OTA_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge33");`.
            this.tracer?.edgeTransition("edge33");
            
            // Step 3: Enter/move towards transition target `OTA_STATE`.
            this.#OTA_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#OTA_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for RUNNING_STATE
        
        // No ancestor handles this event.
    }
    
    #RUNNING_STATE_timer()
    {
        // RUNNING_STATE behavior
        // uml: TIMER / { this.tracer?.edgeTransition("edge35"); } TransitionTo(IDLE_STATE)
        {
            // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.RUNNING_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge35");`.
            this.tracer?.edgeTransition("edge35");
            
            // Step 3: Enter/move towards transition target `IDLE_STATE`.
            this.#IDLE_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CHARGING_OFF_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #CHARGING_OFF_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.CHARGING_OFF_STATE;
        
        // CHARGING_OFF_STATE behavior
        // uml: enter / { this.tracer?.enterState('CHARGING_OFF_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('CHARGING_OFF_STATE');`
            this.tracer?.enterState('CHARGING_OFF_STATE');
        } // end of behavior for CHARGING_OFF_STATE
        
        // CHARGING_OFF_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showChargingOffScreen();\nstartRunningTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showChargingOffScreen();\nstartRunningTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showChargingOffScreen();\nstartRunningTimer();");
        } // end of behavior for CHARGING_OFF_STATE
    }
    
    #CHARGING_OFF_STATE_exit()
    {
        // CHARGING_OFF_STATE behavior
        // uml: exit / { this.tracer?.exitState('CHARGING_OFF_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('CHARGING_OFF_STATE');`
            this.tracer?.exitState('CHARGING_OFF_STATE');
        } // end of behavior for CHARGING_OFF_STATE
        
        this.stateId = DisplaySm.StateId.RUNNING_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CHARGING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #CHARGING_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.CHARGING_STATE;
        
        // CHARGING_STATE behavior
        // uml: enter / { this.tracer?.enterState('CHARGING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('CHARGING_STATE');`
            this.tracer?.enterState('CHARGING_STATE');
        } // end of behavior for CHARGING_STATE
        
        // CHARGING_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showChargingScreen();\nstartRunningTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showChargingScreen();\nstartRunningTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showChargingScreen();\nstartRunningTimer();");
        } // end of behavior for CHARGING_STATE
    }
    
    #CHARGING_STATE_exit()
    {
        // CHARGING_STATE behavior
        // uml: exit / { this.tracer?.exitState('CHARGING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('CHARGING_STATE');`
            this.tracer?.exitState('CHARGING_STATE');
        } // end of behavior for CHARGING_STATE
        
        this.stateId = DisplaySm.StateId.RUNNING_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IDENTIFY_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IDENTIFY_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.IDENTIFY_STATE;
        
        // IDENTIFY_STATE behavior
        // uml: enter / { this.tracer?.enterState('IDENTIFY_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IDENTIFY_STATE');`
            this.tracer?.enterState('IDENTIFY_STATE');
        } // end of behavior for IDENTIFY_STATE
        
        // IDENTIFY_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showIdentifyScreen();\nstartRunningTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showIdentifyScreen();\nstartRunningTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showIdentifyScreen();\nstartRunningTimer();");
        } // end of behavior for IDENTIFY_STATE
    }
    
    #IDENTIFY_STATE_exit()
    {
        // IDENTIFY_STATE behavior
        // uml: exit / { this.tracer?.exitState('IDENTIFY_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IDENTIFY_STATE');`
            this.tracer?.exitState('IDENTIFY_STATE');
        } // end of behavior for IDENTIFY_STATE
        
        this.stateId = DisplaySm.StateId.RUNNING_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IDLE_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IDLE_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.IDLE_STATE;
        
        // IDLE_STATE behavior
        // uml: enter / { this.tracer?.enterState('IDLE_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IDLE_STATE');`
            this.tracer?.enterState('IDLE_STATE');
        } // end of behavior for IDLE_STATE
        
        // IDLE_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();");
        } // end of behavior for IDLE_STATE
    }
    
    #IDLE_STATE_exit()
    {
        // IDLE_STATE behavior
        // uml: exit / { this.tracer?.exitState('IDLE_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IDLE_STATE');`
            this.tracer?.exitState('IDLE_STATE');
        } // end of behavior for IDLE_STATE
        
        this.stateId = DisplaySm.StateId.RUNNING_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state INFO_NEXT_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #INFO_NEXT_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.INFO_NEXT_STATE;
        
        // INFO_NEXT_STATE behavior
        // uml: enter / { this.tracer?.enterState('INFO_NEXT_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('INFO_NEXT_STATE');`
            this.tracer?.enterState('INFO_NEXT_STATE');
        } // end of behavior for INFO_NEXT_STATE
        
        // INFO_NEXT_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showNextInfoScreen();\nstartRunningTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showNextInfoScreen();\nstartRunningTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showNextInfoScreen();\nstartRunningTimer();");
        } // end of behavior for INFO_NEXT_STATE
    }
    
    #INFO_NEXT_STATE_exit()
    {
        // INFO_NEXT_STATE behavior
        // uml: exit / { this.tracer?.exitState('INFO_NEXT_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('INFO_NEXT_STATE');`
            this.tracer?.exitState('INFO_NEXT_STATE');
        } // end of behavior for INFO_NEXT_STATE
        
        this.stateId = DisplaySm.StateId.RUNNING_STATE;
    }
    
    #INFO_NEXT_STATE_button_click()
    {
        let consume_event = false;
        
        // INFO_NEXT_STATE behavior
        // uml: BUTTON_CLICK / { this.tracer?.edgeTransition("edge40"); } TransitionTo(INFO_NEXT_STATE)
        {
            // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
            this.#INFO_NEXT_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge40");`.
            this.tracer?.edgeTransition("edge40");
            
            // Step 3: Enter/move towards transition target `INFO_NEXT_STATE`.
            this.#INFO_NEXT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for INFO_NEXT_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#RUNNING_STATE_button_click();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state INFO_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #INFO_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.INFO_STATE;
        
        // INFO_STATE behavior
        // uml: enter / { this.tracer?.enterState('INFO_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('INFO_STATE');`
            this.tracer?.enterState('INFO_STATE');
        } // end of behavior for INFO_STATE
        
        // INFO_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showInfoScreen();\nstartRunningTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showInfoScreen();\nstartRunningTimer();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showInfoScreen();\nstartRunningTimer();");
        } // end of behavior for INFO_STATE
    }
    
    #INFO_STATE_exit()
    {
        // INFO_STATE behavior
        // uml: exit / { this.tracer?.exitState('INFO_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('INFO_STATE');`
            this.tracer?.exitState('INFO_STATE');
        } // end of behavior for INFO_STATE
        
        this.stateId = DisplaySm.StateId.RUNNING_STATE;
    }
    
    #INFO_STATE_button_click()
    {
        let consume_event = false;
        
        // INFO_STATE behavior
        // uml: BUTTON_CLICK / { this.tracer?.edgeTransition("edge39"); } TransitionTo(INFO_NEXT_STATE)
        {
            // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
            this.#INFO_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge39");`.
            this.tracer?.edgeTransition("edge39");
            
            // Step 3: Enter/move towards transition target `INFO_NEXT_STATE`.
            this.#INFO_NEXT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for INFO_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#RUNNING_STATE_button_click();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_IMPROV_STATE_UI
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_IMPROV_STATE_UI_enter()
    {
        this.stateId = DisplaySm.StateId.WIFI_IMPROV_STATE_UI;
        
        // WIFI_IMPROV_STATE_UI behavior
        // uml: enter / { this.tracer?.enterState('WIFI_IMPROV_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_IMPROV_STATE_UI');`
            this.tracer?.enterState('WIFI_IMPROV_STATE_UI');
        } // end of behavior for WIFI_IMPROV_STATE_UI
    }
    
    #WIFI_IMPROV_STATE_UI_exit()
    {
        // WIFI_IMPROV_STATE_UI behavior
        // uml: exit / { this.tracer?.exitState('WIFI_IMPROV_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_IMPROV_STATE_UI');`
            this.tracer?.exitState('WIFI_IMPROV_STATE_UI');
        } // end of behavior for WIFI_IMPROV_STATE_UI
        
        this.stateId = DisplaySm.StateId.DISPLAY_STATE;
    }
    
    #WIFI_IMPROV_STATE_UI_connected()
    {
        // WIFI_IMPROV_STATE_UI behavior
        // uml: CONNECTED / { this.tracer?.edgeTransition("edge5"); } TransitionTo(RUNNING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.DISPLAY_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge5");`.
            this.tracer?.edgeTransition("edge5");
            
            // Step 3: Enter/move towards transition target `RUNNING_STATE`.
            this.#RUNNING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE_UI
        
        // No ancestor handles this event.
    }
    
    #WIFI_IMPROV_STATE_UI_improv_auth_required()
    {
        // WIFI_IMPROV_STATE_UI behavior
        // uml: IMPROV_AUTH_REQUIRED / { this.tracer?.edgeTransition("edge6"); } TransitionTo(IMPROV_AWAITING_AUTH_STATE_UI)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.WIFI_IMPROV_STATE_UI);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge6");`.
            this.tracer?.edgeTransition("edge6");
            
            // Step 3: Enter/move towards transition target `IMPROV_AWAITING_AUTH_STATE_UI`.
            this.#IMPROV_AWAITING_AUTH_STATE_UI_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE_UI
        
        // No ancestor handles this event.
    }
    
    #WIFI_IMPROV_STATE_UI_improv_authorized()
    {
        // WIFI_IMPROV_STATE_UI behavior
        // uml: IMPROV_AUTHORIZED / { this.tracer?.edgeTransition("edge7"); } TransitionTo(IMPROV_AUTHORIZED_STATE_UI)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.WIFI_IMPROV_STATE_UI);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge7");`.
            this.tracer?.edgeTransition("edge7");
            
            // Step 3: Enter/move towards transition target `IMPROV_AUTHORIZED_STATE_UI`.
            this.#IMPROV_AUTHORIZED_STATE_UI_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE_UI
        
        // No ancestor handles this event.
    }
    
    #WIFI_IMPROV_STATE_UI_improv_end()
    {
        // WIFI_IMPROV_STATE_UI behavior
        // uml: IMPROV_END / { this.tracer?.edgeTransition("edge8"); } TransitionTo(IMPROV_PROVISIONED_STATE_UI)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.WIFI_IMPROV_STATE_UI);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge8");`.
            this.tracer?.edgeTransition("edge8");
            
            // Step 3: Enter/move towards transition target `IMPROV_PROVISIONED_STATE_UI`.
            this.#IMPROV_PROVISIONED_STATE_UI_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE_UI
        
        // No ancestor handles this event.
    }
    
    #WIFI_IMPROV_STATE_UI_improv_provisioning()
    {
        // WIFI_IMPROV_STATE_UI behavior
        // uml: IMPROV_PROVISIONING / { this.tracer?.edgeTransition("edge9"); } TransitionTo(IMPROV_PROVISIONING_STATE_UI)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.WIFI_IMPROV_STATE_UI);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge9");`.
            this.tracer?.edgeTransition("edge9");
            
            // Step 3: Enter/move towards transition target `IMPROV_PROVISIONING_STATE_UI`.
            this.#IMPROV_PROVISIONING_STATE_UI_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE_UI
        
        // No ancestor handles this event.
    }
    
    #WIFI_IMPROV_STATE_UI_improv_start()
    {
        // WIFI_IMPROV_STATE_UI behavior
        // uml: IMPROV_START / { this.tracer?.edgeTransition("edge10"); } TransitionTo(IMPROV_STARTED_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(DisplaySm.StateId.WIFI_IMPROV_STATE_UI);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge10");`.
            this.tracer?.edgeTransition("edge10");
            
            // Step 3: Enter/move towards transition target `IMPROV_STARTED_STATE`.
            this.#IMPROV_STARTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE_UI
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_AUTHORIZED_STATE_UI
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_AUTHORIZED_STATE_UI_enter()
    {
        this.stateId = DisplaySm.StateId.IMPROV_AUTHORIZED_STATE_UI;
        
        // IMPROV_AUTHORIZED_STATE_UI behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_AUTHORIZED_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_AUTHORIZED_STATE_UI');`
            this.tracer?.enterState('IMPROV_AUTHORIZED_STATE_UI');
        } // end of behavior for IMPROV_AUTHORIZED_STATE_UI
        
        // IMPROV_AUTHORIZED_STATE_UI behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showImprovAuthorizedScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showImprovAuthorizedScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showImprovAuthorizedScreen();");
        } // end of behavior for IMPROV_AUTHORIZED_STATE_UI
    }
    
    #IMPROV_AUTHORIZED_STATE_UI_exit()
    {
        // IMPROV_AUTHORIZED_STATE_UI behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_AUTHORIZED_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_AUTHORIZED_STATE_UI');`
            this.tracer?.exitState('IMPROV_AUTHORIZED_STATE_UI');
        } // end of behavior for IMPROV_AUTHORIZED_STATE_UI
        
        this.stateId = DisplaySm.StateId.WIFI_IMPROV_STATE_UI;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_AWAITING_AUTH_STATE_UI
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_AWAITING_AUTH_STATE_UI_enter()
    {
        this.stateId = DisplaySm.StateId.IMPROV_AWAITING_AUTH_STATE_UI;
        
        // IMPROV_AWAITING_AUTH_STATE_UI behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_AWAITING_AUTH_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_AWAITING_AUTH_STATE_UI');`
            this.tracer?.enterState('IMPROV_AWAITING_AUTH_STATE_UI');
        } // end of behavior for IMPROV_AWAITING_AUTH_STATE_UI
        
        // IMPROV_AWAITING_AUTH_STATE_UI behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showImprovConfirmationScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showImprovConfirmationScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showImprovConfirmationScreen();");
        } // end of behavior for IMPROV_AWAITING_AUTH_STATE_UI
    }
    
    #IMPROV_AWAITING_AUTH_STATE_UI_exit()
    {
        // IMPROV_AWAITING_AUTH_STATE_UI behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_AWAITING_AUTH_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_AWAITING_AUTH_STATE_UI');`
            this.tracer?.exitState('IMPROV_AWAITING_AUTH_STATE_UI');
        } // end of behavior for IMPROV_AWAITING_AUTH_STATE_UI
        
        this.stateId = DisplaySm.StateId.WIFI_IMPROV_STATE_UI;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_PROVISIONED_STATE_UI
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_PROVISIONED_STATE_UI_enter()
    {
        this.stateId = DisplaySm.StateId.IMPROV_PROVISIONED_STATE_UI;
        
        // IMPROV_PROVISIONED_STATE_UI behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_PROVISIONED_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_PROVISIONED_STATE_UI');`
            this.tracer?.enterState('IMPROV_PROVISIONED_STATE_UI');
        } // end of behavior for IMPROV_PROVISIONED_STATE_UI
        
        // IMPROV_PROVISIONED_STATE_UI behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showImprovDoneScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showImprovDoneScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showImprovDoneScreen();");
        } // end of behavior for IMPROV_PROVISIONED_STATE_UI
    }
    
    #IMPROV_PROVISIONED_STATE_UI_exit()
    {
        // IMPROV_PROVISIONED_STATE_UI behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_PROVISIONED_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_PROVISIONED_STATE_UI');`
            this.tracer?.exitState('IMPROV_PROVISIONED_STATE_UI');
        } // end of behavior for IMPROV_PROVISIONED_STATE_UI
        
        this.stateId = DisplaySm.StateId.WIFI_IMPROV_STATE_UI;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_PROVISIONING_STATE_UI
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_PROVISIONING_STATE_UI_enter()
    {
        this.stateId = DisplaySm.StateId.IMPROV_PROVISIONING_STATE_UI;
        
        // IMPROV_PROVISIONING_STATE_UI behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_PROVISIONING_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_PROVISIONING_STATE_UI');`
            this.tracer?.enterState('IMPROV_PROVISIONING_STATE_UI');
        } // end of behavior for IMPROV_PROVISIONING_STATE_UI
        
        // IMPROV_PROVISIONING_STATE_UI behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showImprovConnectingScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showImprovConnectingScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showImprovConnectingScreen();");
        } // end of behavior for IMPROV_PROVISIONING_STATE_UI
    }
    
    #IMPROV_PROVISIONING_STATE_UI_exit()
    {
        // IMPROV_PROVISIONING_STATE_UI behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_PROVISIONING_STATE_UI'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_PROVISIONING_STATE_UI');`
            this.tracer?.exitState('IMPROV_PROVISIONING_STATE_UI');
        } // end of behavior for IMPROV_PROVISIONING_STATE_UI
        
        this.stateId = DisplaySm.StateId.WIFI_IMPROV_STATE_UI;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_STARTED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_STARTED_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.IMPROV_STARTED_STATE;
        
        // IMPROV_STARTED_STATE behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_STARTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_STARTED_STATE');`
            this.tracer?.enterState('IMPROV_STARTED_STATE');
        } // end of behavior for IMPROV_STARTED_STATE
        
        // IMPROV_STARTED_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showImprovScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showImprovScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showImprovScreen();");
        } // end of behavior for IMPROV_STARTED_STATE
    }
    
    #IMPROV_STARTED_STATE_exit()
    {
        // IMPROV_STARTED_STATE behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_STARTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_STARTED_STATE');`
            this.tracer?.exitState('IMPROV_STARTED_STATE');
        } // end of behavior for IMPROV_STARTED_STATE
        
        this.stateId = DisplaySm.StateId.WIFI_IMPROV_STATE_UI;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ERROR_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #ERROR_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.ERROR_STATE;
        
        // ERROR_STATE behavior
        // uml: enter / { this.tracer?.enterState('ERROR_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ERROR_STATE');`
            this.tracer?.enterState('ERROR_STATE');
        } // end of behavior for ERROR_STATE
        
        // ERROR_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "showErrorScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "showErrorScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "showErrorScreen();");
        } // end of behavior for ERROR_STATE
    }
    
    #ERROR_STATE_exit()
    {
        // ERROR_STATE behavior
        // uml: exit / { this.tracer?.exitState('ERROR_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ERROR_STATE');`
            this.tracer?.exitState('ERROR_STATE');
        } // end of behavior for ERROR_STATE
        
        this.stateId = DisplaySm.StateId.ROOT;
    }
    
    #ERROR_STATE_do()
    {
        // ERROR_STATE behavior
        // uml: do / { this.tracer?.edgeTransition("edge44"); } TransitionTo(DISPLAY_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#ERROR_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge44");`.
            this.tracer?.edgeTransition("edge44");
            
            // Step 3: Enter/move towards transition target `DISPLAY_STATE`.
            this.#DISPLAY_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#DISPLAY_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ERROR_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state FACTORY_RESET_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #FACTORY_RESET_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.FACTORY_RESET_STATE;
        
        // FACTORY_RESET_STATE behavior
        // uml: enter / { this.tracer?.enterState('FACTORY_RESET_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('FACTORY_RESET_STATE');`
            this.tracer?.enterState('FACTORY_RESET_STATE');
        } // end of behavior for FACTORY_RESET_STATE
        
        // FACTORY_RESET_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "resetTimerRestart();\nfactoryReset();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "resetTimerRestart();\nfactoryReset();");`
            this.tracer?.log("⚡ FSM would execute action: " + "resetTimerRestart();\nfactoryReset();");
        } // end of behavior for FACTORY_RESET_STATE
    }
    
    #FACTORY_RESET_STATE_exit()
    {
        // FACTORY_RESET_STATE behavior
        // uml: exit / { this.tracer?.exitState('FACTORY_RESET_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('FACTORY_RESET_STATE');`
            this.tracer?.exitState('FACTORY_RESET_STATE');
        } // end of behavior for FACTORY_RESET_STATE
        
        this.stateId = DisplaySm.StateId.ROOT;
    }
    
    #FACTORY_RESET_STATE_do()
    {
        // FACTORY_RESET_STATE behavior
        // uml: do [this.tracer?.log("🛡️ User evaluating guard: " + "resetTimerAfter(1000)") || this.evaluateGuard("FACTORY_RESET_STATE","do [resetTimerAfter(1000)] TransitionTo(REBOOT_STATE)")] / { this.tracer?.edgeTransition("edge46"); } TransitionTo(REBOOT_STATE)
        if (this.tracer?.log("🛡️ User evaluating guard: " + "resetTimerAfter(1000)") || this.evaluateGuard("FACTORY_RESET_STATE","do [resetTimerAfter(1000)] TransitionTo(REBOOT_STATE)"))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#FACTORY_RESET_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge46");`.
            this.tracer?.edgeTransition("edge46");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for FACTORY_RESET_STATE
        
        // No ancestor handles this event.
    }
    
    #FACTORY_RESET_STATE_reboot()
    {
        // FACTORY_RESET_STATE behavior
        // uml: REBOOT / { this.tracer?.edgeTransition("edge45"); } TransitionTo(REBOOT_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#FACTORY_RESET_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge45");`.
            this.tracer?.edgeTransition("edge45");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for FACTORY_RESET_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state REBOOT_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #REBOOT_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.REBOOT_STATE;
        
        // REBOOT_STATE behavior
        // uml: enter / { this.tracer?.enterState('REBOOT_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('REBOOT_STATE');`
            this.tracer?.enterState('REBOOT_STATE');
        } // end of behavior for REBOOT_STATE
        
        // REBOOT_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();");
        } // end of behavior for REBOOT_STATE
    }
    
    #REBOOT_STATE_exit()
    {
        // REBOOT_STATE behavior
        // uml: exit / { this.tracer?.exitState('REBOOT_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('REBOOT_STATE');`
            this.tracer?.exitState('REBOOT_STATE');
        } // end of behavior for REBOOT_STATE
        
        this.stateId = DisplaySm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state RESET_COUNTDOWN_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #RESET_COUNTDOWN_STATE_enter()
    {
        this.stateId = DisplaySm.StateId.RESET_COUNTDOWN_STATE;
        
        // RESET_COUNTDOWN_STATE behavior
        // uml: enter / { this.tracer?.enterState('RESET_COUNTDOWN_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('RESET_COUNTDOWN_STATE');`
            this.tracer?.enterState('RESET_COUNTDOWN_STATE');
        } // end of behavior for RESET_COUNTDOWN_STATE
        
        // RESET_COUNTDOWN_STATE behavior
        // uml: enter / { this.tracer?.log("⚡ FSM would execute action: " + "resetTimerRestart();\nupdateFactoryResetScreen();"); }
        {
            // Step 1: execute action `this.tracer?.log("⚡ FSM would execute action: " + "resetTimerRestart();\nupdateFactoryResetScreen();");`
            this.tracer?.log("⚡ FSM would execute action: " + "resetTimerRestart();\nupdateFactoryResetScreen();");
        } // end of behavior for RESET_COUNTDOWN_STATE
    }
    
    #RESET_COUNTDOWN_STATE_exit()
    {
        // RESET_COUNTDOWN_STATE behavior
        // uml: exit / { this.tracer?.exitState('RESET_COUNTDOWN_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('RESET_COUNTDOWN_STATE');`
            this.tracer?.exitState('RESET_COUNTDOWN_STATE');
        } // end of behavior for RESET_COUNTDOWN_STATE
        
        this.stateId = DisplaySm.StateId.ROOT;
    }
    
    #RESET_COUNTDOWN_STATE_button_long_press_up()
    {
        // RESET_COUNTDOWN_STATE behavior
        // uml: BUTTON_LONG_PRESS_UP / { this.tracer?.log("⚡ FSM would execute action: " + "updateBtnHoldtime();");this.tracer?.edgeTransition("edge48"); } TransitionTo(ROOT.<ChoicePoint>())
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#RESET_COUNTDOWN_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.log("⚡ FSM would execute action: " + "updateBtnHoldtime();");this.tracer?.edgeTransition("edge48");`.
            this.tracer?.log("⚡ FSM would execute action: " + "updateBtnHoldtime();");this.tracer?.edgeTransition("edge48");
            
            // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>()`.
            // ROOT.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<ChoicePoint>() behavior
            // uml: [this.tracer?.log("🛡️ User evaluating guard: " + "btn_holdtime < kFactoryResetTimeoutMs") || this.evaluateGuard("ROOT.<ChoicePoint>()","[btn_holdtime < kFactoryResetTimeoutMs] / { clearScreen(); } TransitionTo(DISPLAY_STATE)")] / { this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();");this.tracer?.edgeTransition("edge49"); } TransitionTo(DISPLAY_STATE)
            if (this.tracer?.log("🛡️ User evaluating guard: " + "btn_holdtime < kFactoryResetTimeoutMs") || this.evaluateGuard("ROOT.<ChoicePoint>()","[btn_holdtime < kFactoryResetTimeoutMs] / { clearScreen(); } TransitionTo(DISPLAY_STATE)"))
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();");this.tracer?.edgeTransition("edge49");`.
                this.tracer?.log("⚡ FSM would execute action: " + "clearScreen();");this.tracer?.edgeTransition("edge49");
                
                // Step 3: Enter/move towards transition target `DISPLAY_STATE`.
                this.#DISPLAY_STATE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#DISPLAY_STATE_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ROOT.<ChoicePoint>()
            
            // ROOT.<ChoicePoint>() behavior
            // uml: else / { this.tracer?.edgeTransition("edge50"); } TransitionTo(FACTORY_RESET_STATE)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition("edge50");`.
                this.tracer?.edgeTransition("edge50");
                
                // Step 3: Enter/move towards transition target `FACTORY_RESET_STATE`.
                this.#FACTORY_RESET_STATE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<ChoicePoint>()
        } // end of behavior for RESET_COUNTDOWN_STATE
        
        // No ancestor handles this event.
    }
    
    #RESET_COUNTDOWN_STATE_do()
    {
        // RESET_COUNTDOWN_STATE behavior
        // uml: do [this.tracer?.log("🛡️ User evaluating guard: " + "resetTimerAfter(1000)") || this.evaluateGuard("RESET_COUNTDOWN_STATE","do [resetTimerAfter(1000)] TransitionTo(RESET_COUNTDOWN_STATE)")] / { this.tracer?.edgeTransition("edge47"); } TransitionTo(RESET_COUNTDOWN_STATE)
        if (this.tracer?.log("🛡️ User evaluating guard: " + "resetTimerAfter(1000)") || this.evaluateGuard("RESET_COUNTDOWN_STATE","do [resetTimerAfter(1000)] TransitionTo(RESET_COUNTDOWN_STATE)"))
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#RESET_COUNTDOWN_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge47");`.
            this.tracer?.edgeTransition("edge47");
            
            // Step 3: Enter/move towards transition target `RESET_COUNTDOWN_STATE`.
            this.#RESET_COUNTDOWN_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RESET_COUNTDOWN_STATE
        
        // No ancestor handles this event.
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case DisplaySm.StateId.ROOT: return "ROOT";
            case DisplaySm.StateId.DISPLAY_STATE: return "DISPLAY_STATE";
            case DisplaySm.StateId.BOOT_ANIMATION_STATE: return "BOOT_ANIMATION_STATE";
            case DisplaySm.StateId.CONNECTING_STATE: return "CONNECTING_STATE";
            case DisplaySm.StateId.SHOW_CONNECTED_STATE: return "SHOW_CONNECTED_STATE";
            case DisplaySm.StateId.SHOW_CONNECTING_STATE: return "SHOW_CONNECTING_STATE";
            case DisplaySm.StateId.IR_LEARNING_STATE: return "IR_LEARNING_STATE";
            case DisplaySm.StateId.IR_LEARNED_FAILED_STATE: return "IR_LEARNED_FAILED_STATE";
            case DisplaySm.StateId.IR_LEARNED_OK_STATE: return "IR_LEARNED_OK_STATE";
            case DisplaySm.StateId.IR_LEARNING_STARTED_STATE: return "IR_LEARNING_STARTED_STATE";
            case DisplaySm.StateId.OTA_STATE: return "OTA_STATE";
            case DisplaySm.StateId.OTA_FAIL_STATE: return "OTA_FAIL_STATE";
            case DisplaySm.StateId.OTA_PROGRESS_STATE: return "OTA_PROGRESS_STATE";
            case DisplaySm.StateId.OTA_STARTED_STATE: return "OTA_STARTED_STATE";
            case DisplaySm.StateId.OTA_SUCCESS_STATE: return "OTA_SUCCESS_STATE";
            case DisplaySm.StateId.RUNNING_STATE: return "RUNNING_STATE";
            case DisplaySm.StateId.CHARGING_OFF_STATE: return "CHARGING_OFF_STATE";
            case DisplaySm.StateId.CHARGING_STATE: return "CHARGING_STATE";
            case DisplaySm.StateId.IDENTIFY_STATE: return "IDENTIFY_STATE";
            case DisplaySm.StateId.IDLE_STATE: return "IDLE_STATE";
            case DisplaySm.StateId.INFO_NEXT_STATE: return "INFO_NEXT_STATE";
            case DisplaySm.StateId.INFO_STATE: return "INFO_STATE";
            case DisplaySm.StateId.WIFI_IMPROV_STATE_UI: return "WIFI_IMPROV_STATE_UI";
            case DisplaySm.StateId.IMPROV_AUTHORIZED_STATE_UI: return "IMPROV_AUTHORIZED_STATE_UI";
            case DisplaySm.StateId.IMPROV_AWAITING_AUTH_STATE_UI: return "IMPROV_AWAITING_AUTH_STATE_UI";
            case DisplaySm.StateId.IMPROV_PROVISIONED_STATE_UI: return "IMPROV_PROVISIONED_STATE_UI";
            case DisplaySm.StateId.IMPROV_PROVISIONING_STATE_UI: return "IMPROV_PROVISIONING_STATE_UI";
            case DisplaySm.StateId.IMPROV_STARTED_STATE: return "IMPROV_STARTED_STATE";
            case DisplaySm.StateId.ERROR_STATE: return "ERROR_STATE";
            case DisplaySm.StateId.FACTORY_RESET_STATE: return "FACTORY_RESET_STATE";
            case DisplaySm.StateId.REBOOT_STATE: return "REBOOT_STATE";
            case DisplaySm.StateId.RESET_COUNTDOWN_STATE: return "RESET_COUNTDOWN_STATE";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case DisplaySm.EventId.BUTTON_CLICK: return "BUTTON_CLICK";
            case DisplaySm.EventId.BUTTON_LONG_PRESS_START: return "BUTTON_LONG_PRESS_START";
            case DisplaySm.EventId.BUTTON_LONG_PRESS_UP: return "BUTTON_LONG_PRESS_UP";
            case DisplaySm.EventId.CHARGING_OFF: return "CHARGING_OFF";
            case DisplaySm.EventId.CHARGING_ON: return "CHARGING_ON";
            case DisplaySm.EventId.CONNECTED: return "CONNECTED";
            case DisplaySm.EventId.CONNECTING: return "CONNECTING";
            case DisplaySm.EventId.DO: return "DO";
            case DisplaySm.EventId.ERROR: return "ERROR";
            case DisplaySm.EventId.EXT_PORT_MODE: return "EXT_PORT_MODE";
            case DisplaySm.EventId.FACTORY_RESET: return "FACTORY_RESET";
            case DisplaySm.EventId.IDENTIFY: return "IDENTIFY";
            case DisplaySm.EventId.IMPROV_AUTH_REQUIRED: return "IMPROV_AUTH_REQUIRED";
            case DisplaySm.EventId.IMPROV_AUTHORIZED: return "IMPROV_AUTHORIZED";
            case DisplaySm.EventId.IMPROV_END: return "IMPROV_END";
            case DisplaySm.EventId.IMPROV_PROVISIONING: return "IMPROV_PROVISIONING";
            case DisplaySm.EventId.IMPROV_START: return "IMPROV_START";
            case DisplaySm.EventId.IR_LEARNING_FAILED: return "IR_LEARNING_FAILED";
            case DisplaySm.EventId.IR_LEARNING_OK: return "IR_LEARNING_OK";
            case DisplaySm.EventId.IR_LEARNING_START: return "IR_LEARNING_START";
            case DisplaySm.EventId.IR_LEARNING_STOP: return "IR_LEARNING_STOP";
            case DisplaySm.EventId.LOST_CONNECTION: return "LOST_CONNECTION";
            case DisplaySm.EventId.OTA_FAIL: return "OTA_FAIL";
            case DisplaySm.EventId.OTA_PROGRESS: return "OTA_PROGRESS";
            case DisplaySm.EventId.OTA_START: return "OTA_START";
            case DisplaySm.EventId.OTA_SUCCESS: return "OTA_SUCCESS";
            case DisplaySm.EventId.REBOOT: return "REBOOT";
            case DisplaySm.EventId.TIMER: return "TIMER";
            default: return "?";
        }
    }
}

</script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        import svgPanZoom from 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/+esm' ;
        mermaid.initialize({ startOnLoad: false });
        await mermaid.run();

        // svg-pan-zoom doesn't like the mermaid viewbox
        document.querySelector('svg').removeAttribute('viewBox');
        document.querySelector('svg').setAttribute('width', '100%');
        document.querySelector('svg').setAttribute('height', '100%');
        document.querySelector('svg').style["max-width"] = '';

        // don't scale the arrow when we scale the transition edge
        document.querySelectorAll('g defs marker[id$=barbEnd]').forEach(marker => {
            marker.setAttribute('markerUnits', 'userSpaceOnUse');
        });

        // https://github.com/StateSmith/StateSmith/issues/404
        // https://github.com/StateSmith/StateSmith/issues/294
        // rewrite $initial_state to a black circle
        document.querySelectorAll('g[data-id*="(InitialState)"]').forEach(g=> {
          g.innerHTML = '<circle transform="translate(0,3)" height="14" width="14" r="14" class="state - start"></circle>';
        })

        var panZoom = window.panZoom = svgPanZoom(document.querySelector('svg'), {
            zoomEnabled: true,
            controlIconsEnabled: true,
            fit: true,
            center: true
        });

        const diagramEventNamesArray = ['do', 'BUTTON_CLICK', 'BUTTON_LONG_PRESS_START', 'BUTTON_LONG_PRESS_UP', 'CHARGING_OFF', 'CHARGING_ON', 'CONNECTED', 'CONNECTING', 'ERROR', 'EXT_PORT_MODE', 'FACTORY_RESET', 'IDENTIFY', 'IMPROV_AUTHORIZED', 'IMPROV_AUTH_REQUIRED', 'IMPROV_END', 'IMPROV_PROVISIONING', 'IMPROV_START', 'IR_LEARNING_FAILED', 'IR_LEARNING_OK', 'IR_LEARNING_START', 'IR_LEARNING_STOP', 'LOST_CONNECTION', 'OTA_FAIL', 'OTA_PROGRESS', 'OTA_START', 'OTA_SUCCESS', 'REBOOT', 'TIMER', ];

        const leftPane = document.querySelector(".main");
        const rightPane = document.querySelector(".sidebar");
        const gutter = document.querySelector(".gutter");

        function resizer(e) {          
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);          
          let prevX = e.x;
          const rightPanel = rightPane.getBoundingClientRect();
                    
          function mousemove(e) {
            let newX = prevX - e.x;
            rightPane.style.width = rightPanel.width + newX + 'px';
            window.panZoom.resize();
            window.panZoom.fit();
            window.panZoom.center();
          }
          
          function mouseup() {
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
            
          }                  
        }

        gutter.addEventListener('mousedown', resizer);

        document.getElementById('timestamps').checked = document.querySelector('table.console').classList.contains('timestamps');
        document.getElementById('timestamps').addEventListener('change', function() {
          if(this.checked) {
            document.querySelector('table.console').classList.add('timestamps');
          } else {
            document.querySelector('table.console').classList.remove('timestamps');
          }
        });

        document.getElementById('dropbtn').addEventListener('click', myFunction);

        /* When the user clicks on the button, 
        toggle between hiding and showing the dropdown content */
        function myFunction() {
          document.getElementById('myDropdown').classList.toggle('show');
        }

        // Close the dropdown if the user clicks outside of it
        window.onclick = function(event) {
          if (!event.target.matches('.dropbtn')) {
            var dropdowns = document.getElementsByClassName('dropdown-content');
            var i;
            for (i = 0; i < dropdowns.length; i++) {
              var openDropdown = dropdowns[i];
              if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
              }
            }
          }
        }




        // Convert a date to a string in the format HH:MM:SS.sss
        function formatTime(date) {
            return date.getHours().toString().padStart(2, '0') + ':' +
                date.getMinutes().toString().padStart(2, '0') + ':' +
                date.getSeconds().toString().padStart(2, '0') + '.' +
                date.getMilliseconds().toString().padStart(3, '0');
        }

        // Add a row to the history table.
        function addHistoryRow(time, event, html = false) {
            var row = document.createElement('tr');
            var timeCell = document.createElement('td');
            timeCell.innerText = formatTime(time);
            timeCell.classList.add('timestamp');
            var eventCell = document.createElement('td');

            if(html) {
              eventCell.innerHTML = event;
            } else {
              eventCell.innerText = event;
            }

            row.appendChild(timeCell);
            row.appendChild(eventCell);
            document.querySelector('tbody').appendChild(row);
        }

        var sm = new DisplaySm();

        // prompt the user to evaluate guards manually
        sm.evaluateGuard = (vertexName, behaviorUml) => {
            return confirm(`Evaluate guard for\n${vertexName} behavior:\n${behaviorUml}.\n\nPress 'OK' to evaluate guard as true and 'Cancel' to evaluate it as false.`);
        }; 

        const highlightedEdges = new Set();
        function highlightEdge(edgeId) {
            var edge = document.getElementById(edgeId);
            if (edge) {
              edge.classList.add('active');
              highlightedEdges.add(edge);
            }
        }

        function clearHighlightedEdges() {
            for (const edge of highlightedEdges) {
              edge.classList.remove('active');
              const showOldTraversal = false;
              if (showOldTraversal) {
                  // shows that the edge was traversed. Optional, but kinda nice.
                  edge.style.stroke = 'green';
              }
            }
            highlightedEdges.clear();
        }

        // The simulator uses a tracer callback to perform operations such as 
        // state highlighting and logging. You do not need this functionality
        // when using DisplaySm.js in your own applications, although you may
        // choose to implement a tracer for debugging purposes.
        sm.tracer = {
            enterState: (mermaidName) => {
                var e = document.querySelector('g[data-id=' + mermaidName + ']');
                if(e) {
                  e.classList.add('active');
                  panOnScreen(e);
                }
                sm.tracer.log('➡️ Entered ' + mermaidName);
            },
            exitState: (mermaidName) => {
                document.querySelector('g[data-id=' + mermaidName + ']')?.classList.remove('active');
            },
            edgeTransition: (edgeId) => {
                highlightEdge(edgeId);
            },
            log: (message, html=false) => {
                addHistoryRow(new Date(), message, html);
            }
        };

        // Wire up the buttons that dispatch events for the state machine.
        diagramEventNamesArray.forEach(diagramEventName => {
            var button = document.createElement('button');
            button.id = 'button_' + diagramEventName;
            button.innerText = diagramEventName;
            button.addEventListener('click', () => {
                clearHighlightedEdges();
                sm.tracer?.log('<span class="dispatched"><span class="trigger">' + diagramEventName + '</span> DISPATCHED</span>', true);
                const fsmEventName = diagramEventName.toUpperCase();
                sm.dispatchEvent(DisplaySm.EventId[fsmEventName]); 
            });
            document.getElementById('buttons').appendChild(button);
        });

        sm.tracer?.log('<span class="dispatched">START</span>', true);
        sm.start();


        function panOnScreen(element) {
          if(!element) return;

          var bounds = element.getBoundingClientRect();
          if(bounds.x<0 || bounds.y<0) {
              var x = Math.max(0, -bounds.x + 20);
              var y = Math.max(0, -bounds.y + 20);
              window.panZoom.panBy({x: x, y: y});
          }
          var panebounds = document.querySelector('svg').getBoundingClientRect();
          if(bounds.x>panebounds.width || bounds.y>panebounds.height) {
              var x = Math.min(0, panebounds.width - bounds.x - bounds.width - 20);
              var y = Math.min(0, panebounds.height - bounds.y - bounds.height - 20);
              window.panZoom.panBy({x: x, y: y});
          }
        }
    </script>


  </body>
</html>
