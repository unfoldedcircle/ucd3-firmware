// Autogenerated with StateSmith 0.17.1+9cb7486c1587230c52d22d8b6faadd8e2219313c.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// SPDX-FileCopyrightText: Copyright (c) 2024 Unfolded Circle ApS and/or its affiliates <hello@unfoldedcircle.com>
//
// SPDX-License-Identifier: GPL-3.0-or-later
 
#include "DisplaySm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
    


// Starts the state machine. Must be called before dispatching events. Not thread safe.
void DisplaySm::start()
{
    ROOT_enter();
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(DISPLAY_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `DISPLAY_STATE`.
            DISPLAY_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            DISPLAY_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `eventId` parameter is valid.
void DisplaySm::dispatchEvent(EventId eventId)
{
    switch (this->stateId)
    {
        // STATE: DisplaySm
        case StateId::ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: DISPLAY_STATE
        case StateId::DISPLAY_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break;
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break;
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break;
                case EventId::ERROR: DISPLAY_STATE_error(); break;
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break;
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break;
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: BOOT_ANIMATION_STATE
        case StateId::BOOT_ANIMATION_STATE:
            switch (eventId)
            {
                case EventId::TIMER: BOOT_ANIMATION_STATE_timer(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CONNECTING_STATE
        case StateId::CONNECTING_STATE:
            switch (eventId)
            {
                case EventId::IMPROV_START: CONNECTING_STATE_improv_start(); break;
                case EventId::CONNECTED: CONNECTING_STATE_connected(); break;
                case EventId::CONNECTING: CONNECTING_STATE_connecting(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SHOW_CONNECTED_STATE
        case StateId::SHOW_CONNECTED_STATE:
            switch (eventId)
            {
                case EventId::DO: SHOW_CONNECTED_STATE_do(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::CONNECTED: CONNECTING_STATE_connected(); break; // First ancestor handler for this event
                case EventId::IMPROV_START: CONNECTING_STATE_improv_start(); break; // First ancestor handler for this event
                case EventId::CONNECTING: CONNECTING_STATE_connecting(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SHOW_CONNECTING_STATE
        case StateId::SHOW_CONNECTING_STATE:
            switch (eventId)
            {
                case EventId::CONNECTED: SHOW_CONNECTING_STATE_connected(); break;
                case EventId::DO: SHOW_CONNECTING_STATE_do(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::IMPROV_START: CONNECTING_STATE_improv_start(); break; // First ancestor handler for this event
                case EventId::CONNECTING: CONNECTING_STATE_connecting(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IR_LEARNING_STATE
        case StateId::IR_LEARNING_STATE:
            switch (eventId)
            {
                case EventId::IR_LEARNING_STOP: IR_LEARNING_STATE_ir_learning_stop(); break;
                case EventId::LOST_CONNECTION: IR_LEARNING_STATE_lost_connection(); break;
                case EventId::OTA_START: IR_LEARNING_STATE_ota_start(); break;
                case EventId::IR_LEARNING_OK: IR_LEARNING_STATE_ir_learning_ok(); break;
                case EventId::IR_LEARNING_FAILED: IR_LEARNING_STATE_ir_learning_failed(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IR_LEARNED_FAILED_STATE
        case StateId::IR_LEARNED_FAILED_STATE:
            switch (eventId)
            {
                case EventId::BUTTON_CLICK: IR_LEARNED_FAILED_STATE_button_click(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_STOP: IR_LEARNING_STATE_ir_learning_stop(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: IR_LEARNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: IR_LEARNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_OK: IR_LEARNING_STATE_ir_learning_ok(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_FAILED: IR_LEARNING_STATE_ir_learning_failed(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IR_LEARNED_OK_STATE
        case StateId::IR_LEARNED_OK_STATE:
            switch (eventId)
            {
                case EventId::TIMER: IR_LEARNED_OK_STATE_timer(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_STOP: IR_LEARNING_STATE_ir_learning_stop(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: IR_LEARNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: IR_LEARNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_OK: IR_LEARNING_STATE_ir_learning_ok(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_FAILED: IR_LEARNING_STATE_ir_learning_failed(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IR_LEARNING_STARTED_STATE
        case StateId::IR_LEARNING_STARTED_STATE:
            switch (eventId)
            {
                case EventId::BUTTON_CLICK: IR_LEARNING_STARTED_STATE_button_click(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_STOP: IR_LEARNING_STATE_ir_learning_stop(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: IR_LEARNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: IR_LEARNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_OK: IR_LEARNING_STATE_ir_learning_ok(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_FAILED: IR_LEARNING_STATE_ir_learning_failed(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: OTA_STATE
        case StateId::OTA_STATE:
            switch (eventId)
            {
                case EventId::OTA_PROGRESS: OTA_STATE_ota_progress(); break;
                case EventId::OTA_SUCCESS: OTA_STATE_ota_success(); break;
                case EventId::OTA_FAIL: OTA_STATE_ota_fail(); break;
                case EventId::TIMER: OTA_STATE_timer(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: OTA_FAIL_STATE
        case StateId::OTA_FAIL_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: OTA_STATE_timer(); break; // First ancestor handler for this event
                case EventId::OTA_PROGRESS: OTA_STATE_ota_progress(); break; // First ancestor handler for this event
                case EventId::OTA_SUCCESS: OTA_STATE_ota_success(); break; // First ancestor handler for this event
                case EventId::OTA_FAIL: OTA_STATE_ota_fail(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: OTA_PROGRESS_STATE
        case StateId::OTA_PROGRESS_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: OTA_STATE_timer(); break; // First ancestor handler for this event
                case EventId::OTA_PROGRESS: OTA_STATE_ota_progress(); break; // First ancestor handler for this event
                case EventId::OTA_SUCCESS: OTA_STATE_ota_success(); break; // First ancestor handler for this event
                case EventId::OTA_FAIL: OTA_STATE_ota_fail(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: OTA_STARTED_STATE
        case StateId::OTA_STARTED_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: OTA_STATE_timer(); break; // First ancestor handler for this event
                case EventId::OTA_PROGRESS: OTA_STATE_ota_progress(); break; // First ancestor handler for this event
                case EventId::OTA_SUCCESS: OTA_STATE_ota_success(); break; // First ancestor handler for this event
                case EventId::OTA_FAIL: OTA_STATE_ota_fail(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: OTA_SUCCESS_STATE
        case StateId::OTA_SUCCESS_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: OTA_STATE_timer(); break; // First ancestor handler for this event
                case EventId::OTA_PROGRESS: OTA_STATE_ota_progress(); break; // First ancestor handler for this event
                case EventId::OTA_SUCCESS: OTA_STATE_ota_success(); break; // First ancestor handler for this event
                case EventId::OTA_FAIL: OTA_STATE_ota_fail(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: RUNNING_STATE
        case StateId::RUNNING_STATE:
            switch (eventId)
            {
                case EventId::IR_LEARNING_START: RUNNING_STATE_ir_learning_start(); break;
                case EventId::LOST_CONNECTION: RUNNING_STATE_lost_connection(); break;
                case EventId::OTA_START: RUNNING_STATE_ota_start(); break;
                case EventId::IDENTIFY: RUNNING_STATE_identify(); break;
                case EventId::TIMER: RUNNING_STATE_timer(); break;
                case EventId::CHARGING_ON: RUNNING_STATE_charging_on(); break;
                case EventId::CHARGING_OFF: RUNNING_STATE_charging_off(); break;
                case EventId::BUTTON_CLICK: RUNNING_STATE_button_click(); break;
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CHARGING_OFF_STATE
        case StateId::CHARGING_OFF_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: RUNNING_STATE_timer(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::BUTTON_CLICK: RUNNING_STATE_button_click(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_START: RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                case EventId::IDENTIFY: RUNNING_STATE_identify(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CHARGING_STATE
        case StateId::CHARGING_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: RUNNING_STATE_timer(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::BUTTON_CLICK: RUNNING_STATE_button_click(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_START: RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                case EventId::IDENTIFY: RUNNING_STATE_identify(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IDENTIFY_STATE
        case StateId::IDENTIFY_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: RUNNING_STATE_timer(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::BUTTON_CLICK: RUNNING_STATE_button_click(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_START: RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                case EventId::IDENTIFY: RUNNING_STATE_identify(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IDLE_STATE
        case StateId::IDLE_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: RUNNING_STATE_timer(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::BUTTON_CLICK: RUNNING_STATE_button_click(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_START: RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                case EventId::IDENTIFY: RUNNING_STATE_identify(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: INFO_NEXT_STATE
        case StateId::INFO_NEXT_STATE:
            switch (eventId)
            {
                case EventId::BUTTON_CLICK: INFO_NEXT_STATE_button_click(); break;
                case EventId::CHARGING_ON: RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: RUNNING_STATE_timer(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_START: RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                case EventId::IDENTIFY: RUNNING_STATE_identify(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: INFO_STATE
        case StateId::INFO_STATE:
            switch (eventId)
            {
                case EventId::BUTTON_CLICK: INFO_STATE_button_click(); break;
                case EventId::CHARGING_ON: RUNNING_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: RUNNING_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::TIMER: RUNNING_STATE_timer(); break; // First ancestor handler for this event
                case EventId::LOST_CONNECTION: RUNNING_STATE_lost_connection(); break; // First ancestor handler for this event
                case EventId::OTA_START: RUNNING_STATE_ota_start(); break; // First ancestor handler for this event
                case EventId::IR_LEARNING_START: RUNNING_STATE_ir_learning_start(); break; // First ancestor handler for this event
                case EventId::IDENTIFY: RUNNING_STATE_identify(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_IMPROV_STATE_UI
        case StateId::WIFI_IMPROV_STATE_UI:
            switch (eventId)
            {
                case EventId::CONNECTED: WIFI_IMPROV_STATE_UI_connected(); break;
                case EventId::IMPROV_AUTH_REQUIRED: WIFI_IMPROV_STATE_UI_improv_auth_required(); break;
                case EventId::IMPROV_AUTHORIZED: WIFI_IMPROV_STATE_UI_improv_authorized(); break;
                case EventId::IMPROV_END: WIFI_IMPROV_STATE_UI_improv_end(); break;
                case EventId::IMPROV_PROVISIONING: WIFI_IMPROV_STATE_UI_improv_provisioning(); break;
                case EventId::IMPROV_START: WIFI_IMPROV_STATE_UI_improv_start(); break;
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_AUTHORIZED_STATE_UI
        case StateId::IMPROV_AUTHORIZED_STATE_UI:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::CONNECTED: WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTH_REQUIRED: WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTHORIZED: WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                case EventId::IMPROV_END: WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                case EventId::IMPROV_PROVISIONING: WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                case EventId::IMPROV_START: WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_AWAITING_AUTH_STATE_UI
        case StateId::IMPROV_AWAITING_AUTH_STATE_UI:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::CONNECTED: WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTH_REQUIRED: WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTHORIZED: WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                case EventId::IMPROV_END: WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                case EventId::IMPROV_PROVISIONING: WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                case EventId::IMPROV_START: WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_PROVISIONED_STATE_UI
        case StateId::IMPROV_PROVISIONED_STATE_UI:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::CONNECTED: WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTH_REQUIRED: WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTHORIZED: WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                case EventId::IMPROV_END: WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                case EventId::IMPROV_PROVISIONING: WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                case EventId::IMPROV_START: WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_PROVISIONING_STATE_UI
        case StateId::IMPROV_PROVISIONING_STATE_UI:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::CONNECTED: WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTH_REQUIRED: WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTHORIZED: WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                case EventId::IMPROV_END: WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                case EventId::IMPROV_PROVISIONING: WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                case EventId::IMPROV_START: WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_STARTED_STATE
        case StateId::IMPROV_STARTED_STATE:
            switch (eventId)
            {
                case EventId::CHARGING_ON: DISPLAY_STATE_charging_on(); break; // First ancestor handler for this event
                case EventId::CHARGING_OFF: DISPLAY_STATE_charging_off(); break; // First ancestor handler for this event
                case EventId::EXT_PORT_MODE: DISPLAY_STATE_ext_port_mode(); break; // First ancestor handler for this event
                case EventId::ERROR: DISPLAY_STATE_error(); break; // First ancestor handler for this event
                case EventId::BUTTON_LONG_PRESS_START: DISPLAY_STATE_button_long_press_start(); break; // First ancestor handler for this event
                case EventId::FACTORY_RESET: DISPLAY_STATE_factory_reset(); break; // First ancestor handler for this event
                case EventId::REBOOT: DISPLAY_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::CONNECTED: WIFI_IMPROV_STATE_UI_connected(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTH_REQUIRED: WIFI_IMPROV_STATE_UI_improv_auth_required(); break; // First ancestor handler for this event
                case EventId::IMPROV_AUTHORIZED: WIFI_IMPROV_STATE_UI_improv_authorized(); break; // First ancestor handler for this event
                case EventId::IMPROV_END: WIFI_IMPROV_STATE_UI_improv_end(); break; // First ancestor handler for this event
                case EventId::IMPROV_PROVISIONING: WIFI_IMPROV_STATE_UI_improv_provisioning(); break; // First ancestor handler for this event
                case EventId::IMPROV_START: WIFI_IMPROV_STATE_UI_improv_start(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ERROR_STATE
        case StateId::ERROR_STATE:
            switch (eventId)
            {
                case EventId::DO: ERROR_STATE_do(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: FACTORY_RESET_STATE
        case StateId::FACTORY_RESET_STATE:
            switch (eventId)
            {
                case EventId::REBOOT: FACTORY_RESET_STATE_reboot(); break;
                case EventId::DO: FACTORY_RESET_STATE_do(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: REBOOT_STATE
        case StateId::REBOOT_STATE:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: RESET_COUNTDOWN_STATE
        case StateId::RESET_COUNTDOWN_STATE:
            switch (eventId)
            {
                case EventId::DO: RESET_COUNTDOWN_STATE_do(); break;
                case EventId::BUTTON_LONG_PRESS_UP: RESET_COUNTDOWN_STATE_button_long_press_up(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
void DisplaySm::exitUpToStateHandler(StateId desiredState)
{
    while (this->stateId != desiredState)
    {
        switch (this->stateId)
        {
            case StateId::DISPLAY_STATE: DISPLAY_STATE_exit(); break;
            
            case StateId::BOOT_ANIMATION_STATE: BOOT_ANIMATION_STATE_exit(); break;
            
            case StateId::CONNECTING_STATE: CONNECTING_STATE_exit(); break;
            
            case StateId::SHOW_CONNECTED_STATE: SHOW_CONNECTED_STATE_exit(); break;
            
            case StateId::SHOW_CONNECTING_STATE: SHOW_CONNECTING_STATE_exit(); break;
            
            case StateId::IR_LEARNING_STATE: IR_LEARNING_STATE_exit(); break;
            
            case StateId::IR_LEARNED_FAILED_STATE: IR_LEARNED_FAILED_STATE_exit(); break;
            
            case StateId::IR_LEARNED_OK_STATE: IR_LEARNED_OK_STATE_exit(); break;
            
            case StateId::IR_LEARNING_STARTED_STATE: IR_LEARNING_STARTED_STATE_exit(); break;
            
            case StateId::OTA_STATE: OTA_STATE_exit(); break;
            
            case StateId::OTA_FAIL_STATE: OTA_FAIL_STATE_exit(); break;
            
            case StateId::OTA_PROGRESS_STATE: OTA_PROGRESS_STATE_exit(); break;
            
            case StateId::OTA_STARTED_STATE: OTA_STARTED_STATE_exit(); break;
            
            case StateId::OTA_SUCCESS_STATE: OTA_SUCCESS_STATE_exit(); break;
            
            case StateId::RUNNING_STATE: RUNNING_STATE_exit(); break;
            
            case StateId::CHARGING_OFF_STATE: CHARGING_OFF_STATE_exit(); break;
            
            case StateId::CHARGING_STATE: CHARGING_STATE_exit(); break;
            
            case StateId::IDENTIFY_STATE: IDENTIFY_STATE_exit(); break;
            
            case StateId::IDLE_STATE: IDLE_STATE_exit(); break;
            
            case StateId::INFO_NEXT_STATE: INFO_NEXT_STATE_exit(); break;
            
            case StateId::INFO_STATE: INFO_STATE_exit(); break;
            
            case StateId::WIFI_IMPROV_STATE_UI: WIFI_IMPROV_STATE_UI_exit(); break;
            
            case StateId::IMPROV_AUTHORIZED_STATE_UI: IMPROV_AUTHORIZED_STATE_UI_exit(); break;
            
            case StateId::IMPROV_AWAITING_AUTH_STATE_UI: IMPROV_AWAITING_AUTH_STATE_UI_exit(); break;
            
            case StateId::IMPROV_PROVISIONED_STATE_UI: IMPROV_PROVISIONED_STATE_UI_exit(); break;
            
            case StateId::IMPROV_PROVISIONING_STATE_UI: IMPROV_PROVISIONING_STATE_UI_exit(); break;
            
            case StateId::IMPROV_STARTED_STATE: IMPROV_STARTED_STATE_exit(); break;
            
            case StateId::ERROR_STATE: ERROR_STATE_exit(); break;
            
            case StateId::FACTORY_RESET_STATE: FACTORY_RESET_STATE_exit(); break;
            
            case StateId::REBOOT_STATE: REBOOT_STATE_exit(); break;
            
            case StateId::RESET_COUNTDOWN_STATE: RESET_COUNTDOWN_STATE_exit(); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::ROOT_enter()
{
    this->stateId = StateId::ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DISPLAY_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::DISPLAY_STATE_enter()
{
    this->stateId = StateId::DISPLAY_STATE;
    
    // DISPLAY_STATE behavior
    // uml: enter
    {
        // Step 1: execute action ``
    } // end of behavior for DISPLAY_STATE
}

void DisplaySm::DISPLAY_STATE_exit()
{
    this->stateId = StateId::ROOT;
}

void DisplaySm::DISPLAY_STATE_button_long_press_start()
{
    // DISPLAY_STATE behavior
    // uml: BUTTON_LONG_PRESS_START / { startFactoryResetScreen(); } TransitionTo(RESET_COUNTDOWN_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: `startFactoryResetScreen();`.
        startFactoryResetScreen();
        
        // Step 3: Enter/move towards transition target `RESET_COUNTDOWN_STATE`.
        RESET_COUNTDOWN_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DISPLAY_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::DISPLAY_STATE_charging_off()
{
    // DISPLAY_STATE behavior
    // uml: CHARGING_OFF / { charging = false; }
    {
        // Step 1: execute action `charging = false;`
        charging = false;
    } // end of behavior for DISPLAY_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::DISPLAY_STATE_charging_on()
{
    // DISPLAY_STATE behavior
    // uml: CHARGING_ON / { charging = true; }
    {
        // Step 1: execute action `charging = true;`
        charging = true;
    } // end of behavior for DISPLAY_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::DISPLAY_STATE_error()
{
    // DISPLAY_STATE behavior
    // uml: ERROR TransitionTo(ERROR_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ERROR_STATE`.
        ERROR_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DISPLAY_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::DISPLAY_STATE_ext_port_mode()
{
    // DISPLAY_STATE behavior
    // uml: EXT_PORT_MODE / { updateExtPortMode(); }
    {
        // Step 1: execute action `updateExtPortMode();`
        updateExtPortMode();
    } // end of behavior for DISPLAY_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::DISPLAY_STATE_factory_reset()
{
    // DISPLAY_STATE behavior
    // uml: FACTORY_RESET TransitionTo(FACTORY_RESET_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `FACTORY_RESET_STATE`.
        FACTORY_RESET_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DISPLAY_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::DISPLAY_STATE_reboot()
{
    // DISPLAY_STATE behavior
    // uml: REBOOT TransitionTo(REBOOT_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DISPLAY_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::DISPLAY_STATE_InitialState_transition()
{
    // DISPLAY_STATE.<InitialState> behavior
    // uml: TransitionTo(DISPLAY_STATE.<History>)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DISPLAY_STATE.<History>`.
        // DISPLAY_STATE.<History> is a pseudo state and cannot have an `enter` trigger.
        
        // DISPLAY_STATE.<History> behavior
        // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.OTA_STATE)] TransitionTo(OTA_STATE)
        if (this->vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId::OTA_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `OTA_STATE`.
            OTA_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            OTA_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for DISPLAY_STATE.<History>
        
        // DISPLAY_STATE.<History> behavior
        // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.CONNECTING_STATE)] TransitionTo(CONNECTING_STATE)
        if (this->vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId::CONNECTING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CONNECTING_STATE`.
            CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE.<History>
        
        // DISPLAY_STATE.<History> behavior
        // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.RUNNING_STATE)] TransitionTo(RUNNING_STATE)
        if (this->vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId::RUNNING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `RUNNING_STATE`.
            RUNNING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE.<History>
        
        // DISPLAY_STATE.<History> behavior
        // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.SHOW_CONNECTED_STATE)] TransitionTo(SHOW_CONNECTED_STATE)
        if (this->vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId::SHOW_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SHOW_CONNECTED_STATE`.
            CONNECTING_STATE_enter();
            SHOW_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE.<History>
        
        // DISPLAY_STATE.<History> behavior
        // uml: [$gil(this.vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId.SHOW_CONNECTING_STATE)] TransitionTo(SHOW_CONNECTING_STATE)
        if (this->vars.DISPLAY_STATE_history == DISPLAY_STATE_HistoryId::SHOW_CONNECTING_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SHOW_CONNECTING_STATE`.
            CONNECTING_STATE_enter();
            SHOW_CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE.<History>
        
        // DISPLAY_STATE.<History> behavior
        // uml: else TransitionTo(BOOT_ANIMATION_STATE)
        {
            // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `BOOT_ANIMATION_STATE`.
            BOOT_ANIMATION_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISPLAY_STATE.<History>
    } // end of behavior for DISPLAY_STATE.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state BOOT_ANIMATION_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::BOOT_ANIMATION_STATE_enter()
{
    this->stateId = StateId::BOOT_ANIMATION_STATE;
    
    // BOOT_ANIMATION_STATE behavior
    // uml: enter / { startBootupTimer(); }
    {
        // Step 1: execute action `startBootupTimer();`
        startBootupTimer();
    } // end of behavior for BOOT_ANIMATION_STATE
    
    // BOOT_ANIMATION_STATE behavior
    // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.BOOT_ANIMATION_STATE;) }
    {
        // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.BOOT_ANIMATION_STATE;)`
        this->vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId::BOOT_ANIMATION_STATE;
    } // end of behavior for BOOT_ANIMATION_STATE
}

void DisplaySm::BOOT_ANIMATION_STATE_exit()
{
    // BOOT_ANIMATION_STATE behavior
    // uml: exit
    {
        // Step 1: execute action ``
    } // end of behavior for BOOT_ANIMATION_STATE
    
    this->stateId = StateId::DISPLAY_STATE;
}

void DisplaySm::BOOT_ANIMATION_STATE_timer()
{
    // BOOT_ANIMATION_STATE behavior
    // uml: TIMER TransitionTo(CONNECTING_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        BOOT_ANIMATION_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONNECTING_STATE`.
        CONNECTING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for BOOT_ANIMATION_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONNECTING_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::CONNECTING_STATE_enter()
{
    this->stateId = StateId::CONNECTING_STATE;
    
    // CONNECTING_STATE behavior
    // uml: enter / { updateNetworkScreen(); }
    {
        // Step 1: execute action `updateNetworkScreen();`
        updateNetworkScreen();
    } // end of behavior for CONNECTING_STATE
    
    // CONNECTING_STATE behavior
    // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.CONNECTING_STATE;) }
    {
        // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.CONNECTING_STATE;)`
        this->vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId::CONNECTING_STATE;
    } // end of behavior for CONNECTING_STATE
}

void DisplaySm::CONNECTING_STATE_exit()
{
    this->stateId = StateId::DISPLAY_STATE;
}

void DisplaySm::CONNECTING_STATE_connected()
{
    // CONNECTING_STATE behavior
    // uml: CONNECTED TransitionTo(RUNNING_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RUNNING_STATE`.
        RUNNING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONNECTING_STATE
    
    // unreachable behavior: `CONNECTED TransitionTo(SHOW_CONNECTED_STATE)` due to unconditional transition above
    
    // No ancestor handles this event.
}

void DisplaySm::CONNECTING_STATE_connecting()
{
    // CONNECTING_STATE behavior
    // uml: CONNECTING TransitionTo(SHOW_CONNECTING_STATE)
    {
        // Step 1: Exit states until we reach `CONNECTING_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::CONNECTING_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SHOW_CONNECTING_STATE`.
        SHOW_CONNECTING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONNECTING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::CONNECTING_STATE_improv_start()
{
    // CONNECTING_STATE behavior
    // uml: IMPROV_START TransitionTo(IMPROV_STARTED_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_STARTED_STATE`.
        WIFI_IMPROV_STATE_UI_enter();
        IMPROV_STARTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONNECTING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SHOW_CONNECTED_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::SHOW_CONNECTED_STATE_enter()
{
    this->stateId = StateId::SHOW_CONNECTED_STATE;
    
    // SHOW_CONNECTED_STATE behavior
    // uml: enter / { updateNetworkScreen(); }
    {
        // Step 1: execute action `updateNetworkScreen();`
        updateNetworkScreen();
    } // end of behavior for SHOW_CONNECTED_STATE
    
    // SHOW_CONNECTED_STATE behavior
    // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.SHOW_CONNECTED_STATE;) }
    {
        // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.SHOW_CONNECTED_STATE;)`
        this->vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId::SHOW_CONNECTED_STATE;
    } // end of behavior for SHOW_CONNECTED_STATE
}

void DisplaySm::SHOW_CONNECTED_STATE_exit()
{
    this->stateId = StateId::CONNECTING_STATE;
}

void DisplaySm::SHOW_CONNECTED_STATE_do()
{
    // SHOW_CONNECTED_STATE behavior
    // uml: do TransitionTo(RUNNING_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RUNNING_STATE`.
        RUNNING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SHOW_CONNECTED_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SHOW_CONNECTING_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::SHOW_CONNECTING_STATE_enter()
{
    this->stateId = StateId::SHOW_CONNECTING_STATE;
    
    // SHOW_CONNECTING_STATE behavior
    // uml: enter / { connectingTimerReset();\nupdateConnectingScreen(); }
    {
        // Step 1: execute action `connectingTimerReset();\nupdateConnectingScreen();`
        connectingTimerReset();
        updateConnectingScreen();
    } // end of behavior for SHOW_CONNECTING_STATE
    
    // SHOW_CONNECTING_STATE behavior
    // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.SHOW_CONNECTING_STATE;) }
    {
        // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.SHOW_CONNECTING_STATE;)`
        this->vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId::SHOW_CONNECTING_STATE;
    } // end of behavior for SHOW_CONNECTING_STATE
}

void DisplaySm::SHOW_CONNECTING_STATE_exit()
{
    this->stateId = StateId::CONNECTING_STATE;
}

void DisplaySm::SHOW_CONNECTING_STATE_connected()
{
    bool consume_event = false;
    
    // SHOW_CONNECTING_STATE behavior
    // uml: CONNECTED TransitionTo(SHOW_CONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `CONNECTING_STATE` state (Least Common Ancestor for transition).
        SHOW_CONNECTING_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SHOW_CONNECTED_STATE`.
        SHOW_CONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SHOW_CONNECTING_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        CONNECTING_STATE_connected();
    }
}

void DisplaySm::SHOW_CONNECTING_STATE_do()
{
    // SHOW_CONNECTING_STATE behavior
    // uml: do [connectingTimerAfter(300)] TransitionTo(SHOW_CONNECTING_STATE)
    if (connectingTimerAfter(300))
    {
        // Step 1: Exit states until we reach `CONNECTING_STATE` state (Least Common Ancestor for transition).
        SHOW_CONNECTING_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SHOW_CONNECTING_STATE`.
        SHOW_CONNECTING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SHOW_CONNECTING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IR_LEARNING_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IR_LEARNING_STATE_enter()
{
    this->stateId = StateId::IR_LEARNING_STATE;
}

void DisplaySm::IR_LEARNING_STATE_exit()
{
    // IR_LEARNING_STATE behavior
    // uml: exit / { stopTimer();\nstopIrLearning();\nclearScreen(); }
    {
        // Step 1: execute action `stopTimer();\nstopIrLearning();\nclearScreen();`
        stopTimer();
        stopIrLearning();
        clearScreen();
    } // end of behavior for IR_LEARNING_STATE
    
    this->stateId = StateId::DISPLAY_STATE;
}

void DisplaySm::IR_LEARNING_STATE_ir_learning_failed()
{
    // IR_LEARNING_STATE behavior
    // uml: IR_LEARNING_FAILED TransitionTo(IR_LEARNED_FAILED_STATE)
    {
        // Step 1: Exit states until we reach `IR_LEARNING_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::IR_LEARNING_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IR_LEARNED_FAILED_STATE`.
        IR_LEARNED_FAILED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IR_LEARNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::IR_LEARNING_STATE_ir_learning_ok()
{
    // IR_LEARNING_STATE behavior
    // uml: IR_LEARNING_OK TransitionTo(IR_LEARNED_OK_STATE)
    {
        // Step 1: Exit states until we reach `IR_LEARNING_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::IR_LEARNING_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IR_LEARNED_OK_STATE`.
        IR_LEARNED_OK_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IR_LEARNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::IR_LEARNING_STATE_ir_learning_stop()
{
    // IR_LEARNING_STATE behavior
    // uml: IR_LEARNING_STOP TransitionTo(RUNNING_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RUNNING_STATE`.
        RUNNING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IR_LEARNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::IR_LEARNING_STATE_lost_connection()
{
    // IR_LEARNING_STATE behavior
    // uml: LOST_CONNECTION TransitionTo(CONNECTING_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONNECTING_STATE`.
        CONNECTING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IR_LEARNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::IR_LEARNING_STATE_ota_start()
{
    // IR_LEARNING_STATE behavior
    // uml: OTA_START TransitionTo(OTA_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OTA_STATE`.
        OTA_STATE_enter();
        
        // Finish transition by calling pseudo state transition function.
        OTA_STATE_InitialState_transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for IR_LEARNING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IR_LEARNED_FAILED_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IR_LEARNED_FAILED_STATE_enter()
{
    this->stateId = StateId::IR_LEARNED_FAILED_STATE;
    
    // IR_LEARNED_FAILED_STATE behavior
    // uml: enter / { showIrLearnedFailedScreen(); }
    {
        // Step 1: execute action `showIrLearnedFailedScreen();`
        showIrLearnedFailedScreen();
    } // end of behavior for IR_LEARNED_FAILED_STATE
}

void DisplaySm::IR_LEARNED_FAILED_STATE_exit()
{
    this->stateId = StateId::IR_LEARNING_STATE;
}

void DisplaySm::IR_LEARNED_FAILED_STATE_button_click()
{
    // IR_LEARNED_FAILED_STATE behavior
    // uml: BUTTON_CLICK TransitionTo(IR_LEARNING_STARTED_STATE)
    {
        // Step 1: Exit states until we reach `IR_LEARNING_STATE` state (Least Common Ancestor for transition).
        IR_LEARNED_FAILED_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IR_LEARNING_STARTED_STATE`.
        IR_LEARNING_STARTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IR_LEARNED_FAILED_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IR_LEARNED_OK_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IR_LEARNED_OK_STATE_enter()
{
    this->stateId = StateId::IR_LEARNED_OK_STATE;
    
    // IR_LEARNED_OK_STATE behavior
    // uml: enter / { showIrLearnedOkScreen();\nstartIrLearnedOkTimer(); }
    {
        // Step 1: execute action `showIrLearnedOkScreen();\nstartIrLearnedOkTimer();`
        showIrLearnedOkScreen();
        startIrLearnedOkTimer();
    } // end of behavior for IR_LEARNED_OK_STATE
}

void DisplaySm::IR_LEARNED_OK_STATE_exit()
{
    this->stateId = StateId::IR_LEARNING_STATE;
}

void DisplaySm::IR_LEARNED_OK_STATE_timer()
{
    // IR_LEARNED_OK_STATE behavior
    // uml: TIMER TransitionTo(IR_LEARNING_STARTED_STATE)
    {
        // Step 1: Exit states until we reach `IR_LEARNING_STATE` state (Least Common Ancestor for transition).
        IR_LEARNED_OK_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IR_LEARNING_STARTED_STATE`.
        IR_LEARNING_STARTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IR_LEARNED_OK_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IR_LEARNING_STARTED_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IR_LEARNING_STARTED_STATE_enter()
{
    this->stateId = StateId::IR_LEARNING_STARTED_STATE;
    
    // IR_LEARNING_STARTED_STATE behavior
    // uml: enter / { showIrLearningScreen(); }
    {
        // Step 1: execute action `showIrLearningScreen();`
        showIrLearningScreen();
    } // end of behavior for IR_LEARNING_STARTED_STATE
}

void DisplaySm::IR_LEARNING_STARTED_STATE_exit()
{
    this->stateId = StateId::IR_LEARNING_STATE;
}

void DisplaySm::IR_LEARNING_STARTED_STATE_button_click()
{
    // IR_LEARNING_STARTED_STATE behavior
    // uml: BUTTON_CLICK TransitionTo(RUNNING_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RUNNING_STATE`.
        RUNNING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IR_LEARNING_STARTED_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OTA_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::OTA_STATE_enter()
{
    this->stateId = StateId::OTA_STATE;
    
    // OTA_STATE behavior
    // uml: enter / { startOtaTimer(); }
    {
        // Step 1: execute action `startOtaTimer();`
        startOtaTimer();
    } // end of behavior for OTA_STATE
    
    // OTA_STATE behavior
    // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.OTA_STATE;) }
    {
        // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.OTA_STATE;)`
        this->vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId::OTA_STATE;
    } // end of behavior for OTA_STATE
}

void DisplaySm::OTA_STATE_exit()
{
    // OTA_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for OTA_STATE
    
    this->stateId = StateId::DISPLAY_STATE;
}

void DisplaySm::OTA_STATE_ota_fail()
{
    // OTA_STATE behavior
    // uml: OTA_FAIL TransitionTo(OTA_FAIL_STATE)
    {
        // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::OTA_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OTA_FAIL_STATE`.
        OTA_FAIL_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for OTA_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::OTA_STATE_ota_progress()
{
    // OTA_STATE behavior
    // uml: OTA_PROGRESS TransitionTo(OTA_PROGRESS_STATE)
    {
        // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::OTA_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OTA_PROGRESS_STATE`.
        OTA_PROGRESS_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for OTA_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::OTA_STATE_ota_success()
{
    // OTA_STATE behavior
    // uml: OTA_SUCCESS TransitionTo(OTA_SUCCESS_STATE)
    {
        // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::OTA_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OTA_SUCCESS_STATE`.
        OTA_SUCCESS_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for OTA_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::OTA_STATE_timer()
{
    // OTA_STATE behavior
    // uml: TIMER TransitionTo(OTA_FAIL_STATE)
    {
        // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::OTA_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OTA_FAIL_STATE`.
        OTA_FAIL_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for OTA_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::OTA_STATE_InitialState_transition()
{
    // OTA_STATE.<InitialState> behavior
    // uml: TransitionTo(OTA_STARTED_STATE)
    {
        // Step 1: Exit states until we reach `OTA_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OTA_STARTED_STATE`.
        OTA_STARTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for OTA_STATE.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OTA_FAIL_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::OTA_FAIL_STATE_enter()
{
    this->stateId = StateId::OTA_FAIL_STATE;
    
    // OTA_FAIL_STATE behavior
    // uml: enter / { stopTimer();\nshowOtaFailScreen(); }
    {
        // Step 1: execute action `stopTimer();\nshowOtaFailScreen();`
        stopTimer();
        showOtaFailScreen();
    } // end of behavior for OTA_FAIL_STATE
}

void DisplaySm::OTA_FAIL_STATE_exit()
{
    this->stateId = StateId::OTA_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OTA_PROGRESS_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::OTA_PROGRESS_STATE_enter()
{
    this->stateId = StateId::OTA_PROGRESS_STATE;
    
    // OTA_PROGRESS_STATE behavior
    // uml: enter / { startOtaTimer();\nupdateOtaScreen(); }
    {
        // Step 1: execute action `startOtaTimer();\nupdateOtaScreen();`
        startOtaTimer();
        updateOtaScreen();
    } // end of behavior for OTA_PROGRESS_STATE
}

void DisplaySm::OTA_PROGRESS_STATE_exit()
{
    this->stateId = StateId::OTA_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OTA_STARTED_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::OTA_STARTED_STATE_enter()
{
    this->stateId = StateId::OTA_STARTED_STATE;
    
    // OTA_STARTED_STATE behavior
    // uml: enter / { startOtaTimer();\nshowOtaScreen(); }
    {
        // Step 1: execute action `startOtaTimer();\nshowOtaScreen();`
        startOtaTimer();
        showOtaScreen();
    } // end of behavior for OTA_STARTED_STATE
}

void DisplaySm::OTA_STARTED_STATE_exit()
{
    this->stateId = StateId::OTA_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OTA_SUCCESS_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::OTA_SUCCESS_STATE_enter()
{
    this->stateId = StateId::OTA_SUCCESS_STATE;
    
    // OTA_SUCCESS_STATE behavior
    // uml: enter / { stopTimer();\nshowOtaSuccessScreen(); }
    {
        // Step 1: execute action `stopTimer();\nshowOtaSuccessScreen();`
        stopTimer();
        showOtaSuccessScreen();
    } // end of behavior for OTA_SUCCESS_STATE
}

void DisplaySm::OTA_SUCCESS_STATE_exit()
{
    this->stateId = StateId::OTA_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RUNNING_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::RUNNING_STATE_enter()
{
    this->stateId = StateId::RUNNING_STATE;
    
    // RUNNING_STATE behavior
    // uml: enter / { startRunningTimer(); }
    {
        // Step 1: execute action `startRunningTimer();`
        startRunningTimer();
    } // end of behavior for RUNNING_STATE
    
    // RUNNING_STATE behavior
    // uml: enter / { $gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.RUNNING_STATE;) }
    {
        // Step 1: execute action `$gil(this.vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId.RUNNING_STATE;)`
        this->vars.DISPLAY_STATE_history = DISPLAY_STATE_HistoryId::RUNNING_STATE;
    } // end of behavior for RUNNING_STATE
}

void DisplaySm::RUNNING_STATE_exit()
{
    // RUNNING_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for RUNNING_STATE
    
    this->stateId = StateId::DISPLAY_STATE;
}

void DisplaySm::RUNNING_STATE_button_click()
{
    // RUNNING_STATE behavior
    // uml: BUTTON_CLICK TransitionTo(INFO_STATE)
    {
        // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::RUNNING_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `INFO_STATE`.
        INFO_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RUNNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::RUNNING_STATE_charging_off()
{
    bool consume_event = false;
    
    // RUNNING_STATE behavior
    // uml: CHARGING_OFF TransitionTo(CHARGING_OFF_STATE)
    {
        // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::RUNNING_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHARGING_OFF_STATE`.
        CHARGING_OFF_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RUNNING_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        DISPLAY_STATE_charging_off();
    }
}

void DisplaySm::RUNNING_STATE_charging_on()
{
    bool consume_event = false;
    
    // RUNNING_STATE behavior
    // uml: CHARGING_ON TransitionTo(CHARGING_STATE)
    {
        // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::RUNNING_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHARGING_STATE`.
        CHARGING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RUNNING_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        DISPLAY_STATE_charging_on();
    }
}

void DisplaySm::RUNNING_STATE_identify()
{
    // RUNNING_STATE behavior
    // uml: IDENTIFY TransitionTo(IDENTIFY_STATE)
    {
        // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::RUNNING_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IDENTIFY_STATE`.
        IDENTIFY_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RUNNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::RUNNING_STATE_ir_learning_start()
{
    // RUNNING_STATE behavior
    // uml: IR_LEARNING_START TransitionTo(IR_LEARNING_STARTED_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IR_LEARNING_STARTED_STATE`.
        IR_LEARNING_STATE_enter();
        IR_LEARNING_STARTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RUNNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::RUNNING_STATE_lost_connection()
{
    // RUNNING_STATE behavior
    // uml: LOST_CONNECTION TransitionTo(CONNECTING_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONNECTING_STATE`.
        CONNECTING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RUNNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::RUNNING_STATE_ota_start()
{
    // RUNNING_STATE behavior
    // uml: OTA_START TransitionTo(OTA_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OTA_STATE`.
        OTA_STATE_enter();
        
        // Finish transition by calling pseudo state transition function.
        OTA_STATE_InitialState_transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for RUNNING_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::RUNNING_STATE_timer()
{
    // RUNNING_STATE behavior
    // uml: TIMER TransitionTo(IDLE_STATE)
    {
        // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::RUNNING_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IDLE_STATE`.
        IDLE_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RUNNING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CHARGING_OFF_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::CHARGING_OFF_STATE_enter()
{
    this->stateId = StateId::CHARGING_OFF_STATE;
    
    // CHARGING_OFF_STATE behavior
    // uml: enter / { showChargingOffScreen();\nstartRunningTimer(); }
    {
        // Step 1: execute action `showChargingOffScreen();\nstartRunningTimer();`
        showChargingOffScreen();
        startRunningTimer();
    } // end of behavior for CHARGING_OFF_STATE
}

void DisplaySm::CHARGING_OFF_STATE_exit()
{
    this->stateId = StateId::RUNNING_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CHARGING_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::CHARGING_STATE_enter()
{
    this->stateId = StateId::CHARGING_STATE;
    
    // CHARGING_STATE behavior
    // uml: enter / { showChargingScreen();\nstartRunningTimer(); }
    {
        // Step 1: execute action `showChargingScreen();\nstartRunningTimer();`
        showChargingScreen();
        startRunningTimer();
    } // end of behavior for CHARGING_STATE
}

void DisplaySm::CHARGING_STATE_exit()
{
    this->stateId = StateId::RUNNING_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IDENTIFY_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IDENTIFY_STATE_enter()
{
    this->stateId = StateId::IDENTIFY_STATE;
    
    // IDENTIFY_STATE behavior
    // uml: enter / { showIdentifyScreen();\nstartRunningTimer(); }
    {
        // Step 1: execute action `showIdentifyScreen();\nstartRunningTimer();`
        showIdentifyScreen();
        startRunningTimer();
    } // end of behavior for IDENTIFY_STATE
}

void DisplaySm::IDENTIFY_STATE_exit()
{
    this->stateId = StateId::RUNNING_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IDLE_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IDLE_STATE_enter()
{
    this->stateId = StateId::IDLE_STATE;
    
    // IDLE_STATE behavior
    // uml: enter / { clearScreen(); }
    {
        // Step 1: execute action `clearScreen();`
        clearScreen();
    } // end of behavior for IDLE_STATE
}

void DisplaySm::IDLE_STATE_exit()
{
    this->stateId = StateId::RUNNING_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state INFO_NEXT_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::INFO_NEXT_STATE_enter()
{
    this->stateId = StateId::INFO_NEXT_STATE;
    
    // INFO_NEXT_STATE behavior
    // uml: enter / { showNextInfoScreen();\nstartRunningTimer(); }
    {
        // Step 1: execute action `showNextInfoScreen();\nstartRunningTimer();`
        showNextInfoScreen();
        startRunningTimer();
    } // end of behavior for INFO_NEXT_STATE
}

void DisplaySm::INFO_NEXT_STATE_exit()
{
    this->stateId = StateId::RUNNING_STATE;
}

void DisplaySm::INFO_NEXT_STATE_button_click()
{
    bool consume_event = false;
    
    // INFO_NEXT_STATE behavior
    // uml: BUTTON_CLICK TransitionTo(INFO_NEXT_STATE)
    {
        // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
        INFO_NEXT_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `INFO_NEXT_STATE`.
        INFO_NEXT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for INFO_NEXT_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        RUNNING_STATE_button_click();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state INFO_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::INFO_STATE_enter()
{
    this->stateId = StateId::INFO_STATE;
    
    // INFO_STATE behavior
    // uml: enter / { showInfoScreen();\nstartRunningTimer(); }
    {
        // Step 1: execute action `showInfoScreen();\nstartRunningTimer();`
        showInfoScreen();
        startRunningTimer();
    } // end of behavior for INFO_STATE
}

void DisplaySm::INFO_STATE_exit()
{
    this->stateId = StateId::RUNNING_STATE;
}

void DisplaySm::INFO_STATE_button_click()
{
    bool consume_event = false;
    
    // INFO_STATE behavior
    // uml: BUTTON_CLICK TransitionTo(INFO_NEXT_STATE)
    {
        // Step 1: Exit states until we reach `RUNNING_STATE` state (Least Common Ancestor for transition).
        INFO_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `INFO_NEXT_STATE`.
        INFO_NEXT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for INFO_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        RUNNING_STATE_button_click();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_IMPROV_STATE_UI
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::WIFI_IMPROV_STATE_UI_enter()
{
    this->stateId = StateId::WIFI_IMPROV_STATE_UI;
}

void DisplaySm::WIFI_IMPROV_STATE_UI_exit()
{
    this->stateId = StateId::DISPLAY_STATE;
}

void DisplaySm::WIFI_IMPROV_STATE_UI_connected()
{
    // WIFI_IMPROV_STATE_UI behavior
    // uml: CONNECTED TransitionTo(RUNNING_STATE)
    {
        // Step 1: Exit states until we reach `DISPLAY_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::DISPLAY_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RUNNING_STATE`.
        RUNNING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE_UI
    
    // No ancestor handles this event.
}

void DisplaySm::WIFI_IMPROV_STATE_UI_improv_auth_required()
{
    // WIFI_IMPROV_STATE_UI behavior
    // uml: IMPROV_AUTH_REQUIRED TransitionTo(IMPROV_AWAITING_AUTH_STATE_UI)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::WIFI_IMPROV_STATE_UI);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_AWAITING_AUTH_STATE_UI`.
        IMPROV_AWAITING_AUTH_STATE_UI_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE_UI
    
    // No ancestor handles this event.
}

void DisplaySm::WIFI_IMPROV_STATE_UI_improv_authorized()
{
    // WIFI_IMPROV_STATE_UI behavior
    // uml: IMPROV_AUTHORIZED TransitionTo(IMPROV_AUTHORIZED_STATE_UI)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::WIFI_IMPROV_STATE_UI);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_AUTHORIZED_STATE_UI`.
        IMPROV_AUTHORIZED_STATE_UI_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE_UI
    
    // No ancestor handles this event.
}

void DisplaySm::WIFI_IMPROV_STATE_UI_improv_end()
{
    // WIFI_IMPROV_STATE_UI behavior
    // uml: IMPROV_END TransitionTo(IMPROV_PROVISIONED_STATE_UI)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::WIFI_IMPROV_STATE_UI);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_PROVISIONED_STATE_UI`.
        IMPROV_PROVISIONED_STATE_UI_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE_UI
    
    // No ancestor handles this event.
}

void DisplaySm::WIFI_IMPROV_STATE_UI_improv_provisioning()
{
    // WIFI_IMPROV_STATE_UI behavior
    // uml: IMPROV_PROVISIONING TransitionTo(IMPROV_PROVISIONING_STATE_UI)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::WIFI_IMPROV_STATE_UI);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_PROVISIONING_STATE_UI`.
        IMPROV_PROVISIONING_STATE_UI_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE_UI
    
    // No ancestor handles this event.
}

void DisplaySm::WIFI_IMPROV_STATE_UI_improv_start()
{
    // WIFI_IMPROV_STATE_UI behavior
    // uml: IMPROV_START TransitionTo(IMPROV_STARTED_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE_UI` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::WIFI_IMPROV_STATE_UI);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_STARTED_STATE`.
        IMPROV_STARTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE_UI
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_AUTHORIZED_STATE_UI
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IMPROV_AUTHORIZED_STATE_UI_enter()
{
    this->stateId = StateId::IMPROV_AUTHORIZED_STATE_UI;
    
    // IMPROV_AUTHORIZED_STATE_UI behavior
    // uml: enter / { showImprovAuthorizedScreen(); }
    {
        // Step 1: execute action `showImprovAuthorizedScreen();`
        showImprovAuthorizedScreen();
    } // end of behavior for IMPROV_AUTHORIZED_STATE_UI
}

void DisplaySm::IMPROV_AUTHORIZED_STATE_UI_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE_UI;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_AWAITING_AUTH_STATE_UI
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IMPROV_AWAITING_AUTH_STATE_UI_enter()
{
    this->stateId = StateId::IMPROV_AWAITING_AUTH_STATE_UI;
    
    // IMPROV_AWAITING_AUTH_STATE_UI behavior
    // uml: enter / { showImprovConfirmationScreen(); }
    {
        // Step 1: execute action `showImprovConfirmationScreen();`
        showImprovConfirmationScreen();
    } // end of behavior for IMPROV_AWAITING_AUTH_STATE_UI
}

void DisplaySm::IMPROV_AWAITING_AUTH_STATE_UI_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE_UI;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_PROVISIONED_STATE_UI
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IMPROV_PROVISIONED_STATE_UI_enter()
{
    this->stateId = StateId::IMPROV_PROVISIONED_STATE_UI;
    
    // IMPROV_PROVISIONED_STATE_UI behavior
    // uml: enter / { showImprovDoneScreen(); }
    {
        // Step 1: execute action `showImprovDoneScreen();`
        showImprovDoneScreen();
    } // end of behavior for IMPROV_PROVISIONED_STATE_UI
}

void DisplaySm::IMPROV_PROVISIONED_STATE_UI_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE_UI;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_PROVISIONING_STATE_UI
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IMPROV_PROVISIONING_STATE_UI_enter()
{
    this->stateId = StateId::IMPROV_PROVISIONING_STATE_UI;
    
    // IMPROV_PROVISIONING_STATE_UI behavior
    // uml: enter / { showImprovConnectingScreen(); }
    {
        // Step 1: execute action `showImprovConnectingScreen();`
        showImprovConnectingScreen();
    } // end of behavior for IMPROV_PROVISIONING_STATE_UI
}

void DisplaySm::IMPROV_PROVISIONING_STATE_UI_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE_UI;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_STARTED_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::IMPROV_STARTED_STATE_enter()
{
    this->stateId = StateId::IMPROV_STARTED_STATE;
    
    // IMPROV_STARTED_STATE behavior
    // uml: enter / { showImprovScreen(); }
    {
        // Step 1: execute action `showImprovScreen();`
        showImprovScreen();
    } // end of behavior for IMPROV_STARTED_STATE
}

void DisplaySm::IMPROV_STARTED_STATE_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE_UI;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ERROR_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::ERROR_STATE_enter()
{
    this->stateId = StateId::ERROR_STATE;
    
    // ERROR_STATE behavior
    // uml: enter / { showErrorScreen(); }
    {
        // Step 1: execute action `showErrorScreen();`
        showErrorScreen();
    } // end of behavior for ERROR_STATE
}

void DisplaySm::ERROR_STATE_exit()
{
    this->stateId = StateId::ROOT;
}

void DisplaySm::ERROR_STATE_do()
{
    // ERROR_STATE behavior
    // uml: do TransitionTo(DISPLAY_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ERROR_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DISPLAY_STATE`.
        DISPLAY_STATE_enter();
        
        // Finish transition by calling pseudo state transition function.
        DISPLAY_STATE_InitialState_transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for ERROR_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state FACTORY_RESET_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::FACTORY_RESET_STATE_enter()
{
    this->stateId = StateId::FACTORY_RESET_STATE;
    
    // FACTORY_RESET_STATE behavior
    // uml: enter / { resetTimerRestart();\nfactoryReset(); }
    {
        // Step 1: execute action `resetTimerRestart();\nfactoryReset();`
        resetTimerRestart();
        factoryReset();
    } // end of behavior for FACTORY_RESET_STATE
}

void DisplaySm::FACTORY_RESET_STATE_exit()
{
    this->stateId = StateId::ROOT;
}

void DisplaySm::FACTORY_RESET_STATE_do()
{
    // FACTORY_RESET_STATE behavior
    // uml: do [resetTimerAfter(1000)] TransitionTo(REBOOT_STATE)
    if (resetTimerAfter(1000))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        FACTORY_RESET_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for FACTORY_RESET_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::FACTORY_RESET_STATE_reboot()
{
    // FACTORY_RESET_STATE behavior
    // uml: REBOOT TransitionTo(REBOOT_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        FACTORY_RESET_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for FACTORY_RESET_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state REBOOT_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::REBOOT_STATE_enter()
{
    this->stateId = StateId::REBOOT_STATE;
    
    // REBOOT_STATE behavior
    // uml: enter / { clearScreen(); }
    {
        // Step 1: execute action `clearScreen();`
        clearScreen();
    } // end of behavior for REBOOT_STATE
}

void DisplaySm::REBOOT_STATE_exit()
{
    this->stateId = StateId::ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RESET_COUNTDOWN_STATE
////////////////////////////////////////////////////////////////////////////////

void DisplaySm::RESET_COUNTDOWN_STATE_enter()
{
    this->stateId = StateId::RESET_COUNTDOWN_STATE;
    
    // RESET_COUNTDOWN_STATE behavior
    // uml: enter / { resetTimerRestart();\nupdateFactoryResetScreen(); }
    {
        // Step 1: execute action `resetTimerRestart();\nupdateFactoryResetScreen();`
        resetTimerRestart();
        updateFactoryResetScreen();
    } // end of behavior for RESET_COUNTDOWN_STATE
}

void DisplaySm::RESET_COUNTDOWN_STATE_exit()
{
    this->stateId = StateId::ROOT;
}

void DisplaySm::RESET_COUNTDOWN_STATE_button_long_press_up()
{
    // RESET_COUNTDOWN_STATE behavior
    // uml: BUTTON_LONG_PRESS_UP / { updateBtnHoldtime(); } TransitionTo(ROOT.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        RESET_COUNTDOWN_STATE_exit();
        
        // Step 2: Transition action: `updateBtnHoldtime();`.
        updateBtnHoldtime();
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>()`.
        // ROOT.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<ChoicePoint>() behavior
        // uml: [btn_holdtime < kFactoryResetTimeoutMs] / { clearScreen(); } TransitionTo(DISPLAY_STATE)
        if (btn_holdtime < kFactoryResetTimeoutMs)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `clearScreen();`.
            clearScreen();
            
            // Step 3: Enter/move towards transition target `DISPLAY_STATE`.
            DISPLAY_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            DISPLAY_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<ChoicePoint>()
        
        // ROOT.<ChoicePoint>() behavior
        // uml: else TransitionTo(FACTORY_RESET_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `FACTORY_RESET_STATE`.
            FACTORY_RESET_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<ChoicePoint>()
    } // end of behavior for RESET_COUNTDOWN_STATE
    
    // No ancestor handles this event.
}

void DisplaySm::RESET_COUNTDOWN_STATE_do()
{
    // RESET_COUNTDOWN_STATE behavior
    // uml: do [resetTimerAfter(1000)] TransitionTo(RESET_COUNTDOWN_STATE)
    if (resetTimerAfter(1000))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        RESET_COUNTDOWN_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RESET_COUNTDOWN_STATE`.
        RESET_COUNTDOWN_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RESET_COUNTDOWN_STATE
    
    // No ancestor handles this event.
}

// Thread safe.
char const * DisplaySm::stateIdToString(StateId id)
{
    switch (id)
    {
        case StateId::ROOT: return "ROOT";
        case StateId::DISPLAY_STATE: return "DISPLAY_STATE";
        case StateId::BOOT_ANIMATION_STATE: return "BOOT_ANIMATION_STATE";
        case StateId::CONNECTING_STATE: return "CONNECTING_STATE";
        case StateId::SHOW_CONNECTED_STATE: return "SHOW_CONNECTED_STATE";
        case StateId::SHOW_CONNECTING_STATE: return "SHOW_CONNECTING_STATE";
        case StateId::IR_LEARNING_STATE: return "IR_LEARNING_STATE";
        case StateId::IR_LEARNED_FAILED_STATE: return "IR_LEARNED_FAILED_STATE";
        case StateId::IR_LEARNED_OK_STATE: return "IR_LEARNED_OK_STATE";
        case StateId::IR_LEARNING_STARTED_STATE: return "IR_LEARNING_STARTED_STATE";
        case StateId::OTA_STATE: return "OTA_STATE";
        case StateId::OTA_FAIL_STATE: return "OTA_FAIL_STATE";
        case StateId::OTA_PROGRESS_STATE: return "OTA_PROGRESS_STATE";
        case StateId::OTA_STARTED_STATE: return "OTA_STARTED_STATE";
        case StateId::OTA_SUCCESS_STATE: return "OTA_SUCCESS_STATE";
        case StateId::RUNNING_STATE: return "RUNNING_STATE";
        case StateId::CHARGING_OFF_STATE: return "CHARGING_OFF_STATE";
        case StateId::CHARGING_STATE: return "CHARGING_STATE";
        case StateId::IDENTIFY_STATE: return "IDENTIFY_STATE";
        case StateId::IDLE_STATE: return "IDLE_STATE";
        case StateId::INFO_NEXT_STATE: return "INFO_NEXT_STATE";
        case StateId::INFO_STATE: return "INFO_STATE";
        case StateId::WIFI_IMPROV_STATE_UI: return "WIFI_IMPROV_STATE_UI";
        case StateId::IMPROV_AUTHORIZED_STATE_UI: return "IMPROV_AUTHORIZED_STATE_UI";
        case StateId::IMPROV_AWAITING_AUTH_STATE_UI: return "IMPROV_AWAITING_AUTH_STATE_UI";
        case StateId::IMPROV_PROVISIONED_STATE_UI: return "IMPROV_PROVISIONED_STATE_UI";
        case StateId::IMPROV_PROVISIONING_STATE_UI: return "IMPROV_PROVISIONING_STATE_UI";
        case StateId::IMPROV_STARTED_STATE: return "IMPROV_STARTED_STATE";
        case StateId::ERROR_STATE: return "ERROR_STATE";
        case StateId::FACTORY_RESET_STATE: return "FACTORY_RESET_STATE";
        case StateId::REBOOT_STATE: return "REBOOT_STATE";
        case StateId::RESET_COUNTDOWN_STATE: return "RESET_COUNTDOWN_STATE";
        default: return "?";
    }
}

// Thread safe.
char const * DisplaySm::eventIdToString(EventId id)
{
    switch (id)
    {
        case EventId::BUTTON_CLICK: return "BUTTON_CLICK";
        case EventId::BUTTON_LONG_PRESS_START: return "BUTTON_LONG_PRESS_START";
        case EventId::BUTTON_LONG_PRESS_UP: return "BUTTON_LONG_PRESS_UP";
        case EventId::CHARGING_OFF: return "CHARGING_OFF";
        case EventId::CHARGING_ON: return "CHARGING_ON";
        case EventId::CONNECTED: return "CONNECTED";
        case EventId::CONNECTING: return "CONNECTING";
        case EventId::DO: return "DO";
        case EventId::ERROR: return "ERROR";
        case EventId::EXT_PORT_MODE: return "EXT_PORT_MODE";
        case EventId::FACTORY_RESET: return "FACTORY_RESET";
        case EventId::IDENTIFY: return "IDENTIFY";
        case EventId::IMPROV_AUTH_REQUIRED: return "IMPROV_AUTH_REQUIRED";
        case EventId::IMPROV_AUTHORIZED: return "IMPROV_AUTHORIZED";
        case EventId::IMPROV_END: return "IMPROV_END";
        case EventId::IMPROV_PROVISIONING: return "IMPROV_PROVISIONING";
        case EventId::IMPROV_START: return "IMPROV_START";
        case EventId::IR_LEARNING_FAILED: return "IR_LEARNING_FAILED";
        case EventId::IR_LEARNING_OK: return "IR_LEARNING_OK";
        case EventId::IR_LEARNING_START: return "IR_LEARNING_START";
        case EventId::IR_LEARNING_STOP: return "IR_LEARNING_STOP";
        case EventId::LOST_CONNECTION: return "LOST_CONNECTION";
        case EventId::OTA_FAIL: return "OTA_FAIL";
        case EventId::OTA_PROGRESS: return "OTA_PROGRESS";
        case EventId::OTA_START: return "OTA_START";
        case EventId::OTA_SUCCESS: return "OTA_SUCCESS";
        case EventId::REBOOT: return "REBOOT";
        case EventId::TIMER: return "TIMER";
        default: return "?";
    }
}
