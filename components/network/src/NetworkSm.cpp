// Autogenerated with StateSmith 0.17.1+9cb7486c1587230c52d22d8b6faadd8e2219313c.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// SPDX-FileCopyrightText: Copyright (c) 2024 Unfolded Circle ApS and/or its affiliates <hello@unfoldedcircle.com>
//
// SPDX-License-Identifier: GPL-3.0-or-later
 
#include "NetworkSm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
    


// Starts the state machine. Must be called before dispatching events. Not thread safe.
void NetworkSm::start()
{
    ROOT_enter();
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(NETWORK_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `NETWORK_STATE`.
            NETWORK_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `eventId` parameter is valid.
void NetworkSm::dispatchEvent(EventId eventId)
{
    switch (this->stateId)
    {
        // STATE: NetworkSm
        case StateId::ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: NETWORK_STATE
        case StateId::NETWORK_STATE:
            switch (eventId)
            {
                case EventId::REBOOT: NETWORK_STATE_reboot(); break;
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break;
                case EventId::START: NETWORK_STATE_start(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: NETWORK_ETH_ACTIVE_STATE
        case StateId::NETWORK_ETH_ACTIVE_STATE:
            switch (eventId)
            {
                case EventId::DELETE_WIFI: NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break;
                case EventId::TIMER: NETWORK_ETH_ACTIVE_STATE_timer(); break;
                case EventId::ETH_LINK_UP: NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break;
                case EventId::ETH_LINK_DOWN: NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break;
                case EventId::ETH_GOT_IP: NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break;
                case EventId::CONNECT_TO_AP: NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ETH_ACTIVE_CONNECTED_STATE
        case StateId::ETH_ACTIVE_CONNECTED_STATE:
            switch (eventId)
            {
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::TIMER: NETWORK_ETH_ACTIVE_STATE_timer(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_DOWN: NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ETH_ACTIVE_LINKDOWN_STATE
        case StateId::ETH_ACTIVE_LINKDOWN_STATE:
            switch (eventId)
            {
                case EventId::TIMER: ETH_ACTIVE_LINKDOWN_STATE_timer(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_DOWN: NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ETH_ACTIVE_LINKUP_STATE
        case StateId::ETH_ACTIVE_LINKUP_STATE:
            switch (eventId)
            {
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::TIMER: NETWORK_ETH_ACTIVE_STATE_timer(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_DOWN: NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ETH_CONNECTING_NEW_STATE
        case StateId::ETH_CONNECTING_NEW_STATE:
            switch (eventId)
            {
                case EventId::LOST_CONNECTION: ETH_CONNECTING_NEW_STATE_lost_connection(); break;
                case EventId::ETH_FALLBACK: ETH_CONNECTING_NEW_STATE_eth_fallback(); break;
                case EventId::WIFI_GOT_IP: ETH_CONNECTING_NEW_STATE_wifi_got_ip(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::TIMER: NETWORK_ETH_ACTIVE_STATE_timer(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_DOWN: NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ETH_INITIALIZING_STATE
        case StateId::ETH_INITIALIZING_STATE:
            switch (eventId)
            {
                case EventId::NET_INIT_SUCCESS: ETH_INITIALIZING_STATE_net_init_success(); break;
                case EventId::NET_INIT_FAIL: ETH_INITIALIZING_STATE_net_init_fail(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::TIMER: NETWORK_ETH_ACTIVE_STATE_timer(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_DOWN: NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ETH_STARTING_STATE
        case StateId::ETH_STARTING_STATE:
            switch (eventId)
            {
                case EventId::TIMER: ETH_STARTING_STATE_timer(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_DOWN: NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: NETWORK_WIFI_ACTIVE_STATE
        case StateId::NETWORK_WIFI_ACTIVE_STATE:
            switch (eventId)
            {
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break;
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break;
                case EventId::CONFIGURE_WIFI: NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break;
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break;
                case EventId::WIFI_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break;
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break;
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_CONNECTED_STATE
        case StateId::WIFI_CONNECTED_STATE:
            switch (eventId)
            {
                case EventId::LOST_CONNECTION: WIFI_CONNECTED_STATE_lost_connection(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                case EventId::WIFI_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                case EventId::CONFIGURE_WIFI: NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_CONNECTING_NEW_FAILED_STATE
        case StateId::WIFI_CONNECTING_NEW_FAILED_STATE:
            switch (eventId)
            {
                case EventId::CONNECTED: WIFI_CONNECTING_NEW_FAILED_STATE_connected(); break;
                case EventId::LOST_CONNECTION: WIFI_CONNECTING_NEW_FAILED_STATE_lost_connection(); break;
                case EventId::WIFI_GOT_IP: WIFI_CONNECTING_NEW_FAILED_STATE_wifi_got_ip(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                case EventId::CONFIGURE_WIFI: NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_CONNECTING_NEW_STATE
        case StateId::WIFI_CONNECTING_NEW_STATE:
            switch (eventId)
            {
                case EventId::CONNECTED: WIFI_CONNECTING_NEW_STATE_connected(); break;
                case EventId::LOST_CONNECTION: WIFI_CONNECTING_NEW_STATE_lost_connection(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                case EventId::WIFI_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                case EventId::CONFIGURE_WIFI: NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_CONNECTING_STATE
        case StateId::WIFI_CONNECTING_STATE:
            switch (eventId)
            {
                case EventId::TIMER: WIFI_CONNECTING_STATE_timer(); break;
                case EventId::CONNECTED: WIFI_CONNECTING_STATE_connected(); break;
                case EventId::LOST_CONNECTION: WIFI_CONNECTING_STATE_lost_connection(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                case EventId::WIFI_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                case EventId::CONFIGURE_WIFI: NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_INITIALIZING_STATE
        case StateId::WIFI_INITIALIZING_STATE:
            switch (eventId)
            {
                case EventId::NET_INIT_SUCCESS: WIFI_INITIALIZING_STATE_net_init_success(); break;
                case EventId::CONFIGURE_WIFI: WIFI_INITIALIZING_STATE_configure_wifi(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                case EventId::WIFI_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_LOST_CONNECTION_STATE
        case StateId::WIFI_LOST_CONNECTION_STATE:
            switch (eventId)
            {
                case EventId::TIMER: WIFI_LOST_CONNECTION_STATE_timer(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                case EventId::WIFI_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                case EventId::CONFIGURE_WIFI: NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_USER_DISCONNECTED_STATE
        case StateId::WIFI_USER_DISCONNECTED_STATE:
            switch (eventId)
            {
                case EventId::LOST_CONNECTION: WIFI_USER_DISCONNECTED_STATE_lost_connection(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                case EventId::WIFI_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                case EventId::CONFIGURE_WIFI: NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_W4_IP_STATE
        case StateId::WIFI_W4_IP_STATE:
            switch (eventId)
            {
                case EventId::TIMER: WIFI_W4_IP_STATE_timer(); break;
                case EventId::WIFI_GOT_IP: WIFI_W4_IP_STATE_wifi_got_ip(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::DELETE_WIFI: NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                case EventId::ETH_LINK_UP: NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::CONNECT_TO_AP: NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                case EventId::ETH_FALLBACK: NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                case EventId::CONFIGURE_WIFI: NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WIFI_IMPROV_STATE
        case StateId::WIFI_IMPROV_STATE:
            switch (eventId)
            {
                case EventId::ETH_GOT_IP: WIFI_IMPROV_STATE_eth_got_ip(); break;
                case EventId::IMPROV_BLE_DISCONNECT: WIFI_IMPROV_STATE_improv_ble_disconnect(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_AUTHORIZED_STATE
        case StateId::IMPROV_AUTHORIZED_STATE:
            switch (eventId)
            {
                case EventId::CONNECT_TO_AP: IMPROV_AUTHORIZED_STATE_connect_to_ap(); break;
                case EventId::IMPROV_AUTHORIZED_TIMEOUT: IMPROV_AUTHORIZED_STATE_improv_authorized_timeout(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::IMPROV_BLE_DISCONNECT: WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_AWAITING_AUTH_STATE
        case StateId::IMPROV_AWAITING_AUTH_STATE:
            switch (eventId)
            {
                case EventId::BUTTON_PRESS: IMPROV_AWAITING_AUTH_STATE_button_press(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::IMPROV_BLE_DISCONNECT: WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_INITIALIZING_STATE
        case StateId::IMPROV_INITIALIZING_STATE:
            switch (eventId)
            {
                case EventId::NET_INIT_SUCCESS: IMPROV_INITIALIZING_STATE_net_init_success(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::IMPROV_BLE_DISCONNECT: WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_PROVISIONED_STATE
        case StateId::IMPROV_PROVISIONED_STATE:
            switch (eventId)
            {
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::IMPROV_BLE_DISCONNECT: WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_PROVISIONING_STATE
        case StateId::IMPROV_PROVISIONING_STATE:
            switch (eventId)
            {
                case EventId::CONNECTED: IMPROV_PROVISIONING_STATE_connected(); break;
                case EventId::WIFI_GOT_IP: IMPROV_PROVISIONING_STATE_wifi_got_ip(); break;
                case EventId::LOST_CONNECTION: IMPROV_PROVISIONING_STATE_lost_connection(); break;
                case EventId::TIMER: IMPROV_PROVISIONING_STATE_timer(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::IMPROV_BLE_DISCONNECT: WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: IMPROV_STOPPED_STATE
        case StateId::IMPROV_STOPPED_STATE:
            switch (eventId)
            {
                case EventId::IMPROV_BLE_CONNECT: IMPROV_STOPPED_STATE_improv_ble_connect(); break;
                case EventId::REBOOT: NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                case EventId::NET_INIT_FAIL: NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                case EventId::START: NETWORK_STATE_start(); break; // First ancestor handler for this event
                case EventId::ETH_GOT_IP: WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                case EventId::IMPROV_BLE_DISCONNECT: WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: REBOOT_STATE
        case StateId::REBOOT_STATE:
            // No events handled by this state (or its ancestors).
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
void NetworkSm::exitUpToStateHandler(StateId desiredState)
{
    while (this->stateId != desiredState)
    {
        switch (this->stateId)
        {
            case StateId::NETWORK_STATE: NETWORK_STATE_exit(); break;
            
            case StateId::NETWORK_ETH_ACTIVE_STATE: NETWORK_ETH_ACTIVE_STATE_exit(); break;
            
            case StateId::ETH_ACTIVE_CONNECTED_STATE: ETH_ACTIVE_CONNECTED_STATE_exit(); break;
            
            case StateId::ETH_ACTIVE_LINKDOWN_STATE: ETH_ACTIVE_LINKDOWN_STATE_exit(); break;
            
            case StateId::ETH_ACTIVE_LINKUP_STATE: ETH_ACTIVE_LINKUP_STATE_exit(); break;
            
            case StateId::ETH_CONNECTING_NEW_STATE: ETH_CONNECTING_NEW_STATE_exit(); break;
            
            case StateId::ETH_INITIALIZING_STATE: ETH_INITIALIZING_STATE_exit(); break;
            
            case StateId::ETH_STARTING_STATE: ETH_STARTING_STATE_exit(); break;
            
            case StateId::NETWORK_WIFI_ACTIVE_STATE: NETWORK_WIFI_ACTIVE_STATE_exit(); break;
            
            case StateId::WIFI_CONNECTED_STATE: WIFI_CONNECTED_STATE_exit(); break;
            
            case StateId::WIFI_CONNECTING_NEW_FAILED_STATE: WIFI_CONNECTING_NEW_FAILED_STATE_exit(); break;
            
            case StateId::WIFI_CONNECTING_NEW_STATE: WIFI_CONNECTING_NEW_STATE_exit(); break;
            
            case StateId::WIFI_CONNECTING_STATE: WIFI_CONNECTING_STATE_exit(); break;
            
            case StateId::WIFI_INITIALIZING_STATE: WIFI_INITIALIZING_STATE_exit(); break;
            
            case StateId::WIFI_LOST_CONNECTION_STATE: WIFI_LOST_CONNECTION_STATE_exit(); break;
            
            case StateId::WIFI_USER_DISCONNECTED_STATE: WIFI_USER_DISCONNECTED_STATE_exit(); break;
            
            case StateId::WIFI_W4_IP_STATE: WIFI_W4_IP_STATE_exit(); break;
            
            case StateId::WIFI_IMPROV_STATE: WIFI_IMPROV_STATE_exit(); break;
            
            case StateId::IMPROV_AUTHORIZED_STATE: IMPROV_AUTHORIZED_STATE_exit(); break;
            
            case StateId::IMPROV_AWAITING_AUTH_STATE: IMPROV_AWAITING_AUTH_STATE_exit(); break;
            
            case StateId::IMPROV_INITIALIZING_STATE: IMPROV_INITIALIZING_STATE_exit(); break;
            
            case StateId::IMPROV_PROVISIONED_STATE: IMPROV_PROVISIONED_STATE_exit(); break;
            
            case StateId::IMPROV_PROVISIONING_STATE: IMPROV_PROVISIONING_STATE_exit(); break;
            
            case StateId::IMPROV_STOPPED_STATE: IMPROV_STOPPED_STATE_exit(); break;
            
            case StateId::REBOOT_STATE: REBOOT_STATE_exit(); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::ROOT_enter()
{
    this->stateId = StateId::ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state NETWORK_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::NETWORK_STATE_enter()
{
    this->stateId = StateId::NETWORK_STATE;
    
    // NETWORK_STATE behavior
    // uml: enter / { initNetwork(); }
    {
        // Step 1: execute action `initNetwork();`
        initNetwork();
    } // end of behavior for NETWORK_STATE
}

void NetworkSm::NETWORK_STATE_exit()
{
    this->stateId = StateId::ROOT;
}

void NetworkSm::NETWORK_STATE_net_init_fail()
{
    // NETWORK_STATE behavior
    // uml: NET_INIT_FAIL TransitionTo(REBOOT_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_STATE_reboot()
{
    // NETWORK_STATE behavior
    // uml: REBOOT TransitionTo(REBOOT_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_STATE_start()
{
    // NETWORK_STATE behavior
    // uml: START [!isWifiPreferred()] TransitionTo(ETH_INITIALIZING_STATE)
    if (!isWifiPreferred())
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ETH_INITIALIZING_STATE`.
        NETWORK_ETH_ACTIVE_STATE_enter();
        ETH_INITIALIZING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_STATE
    
    // NETWORK_STATE behavior
    // uml: START [isWifiPreferred()] TransitionTo(WIFI_INITIALIZING_STATE)
    if (isWifiPreferred())
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_INITIALIZING_STATE`.
        NETWORK_WIFI_ACTIVE_STATE_enter();
        WIFI_INITIALIZING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state NETWORK_ETH_ACTIVE_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::NETWORK_ETH_ACTIVE_STATE_enter()
{
    this->stateId = StateId::NETWORK_ETH_ACTIVE_STATE;
    
    // NETWORK_ETH_ACTIVE_STATE behavior
    // uml: enter / { statusUpdate(UPDATE_ETH_CONNECTING); }
    {
        // Step 1: execute action `statusUpdate(UPDATE_ETH_CONNECTING);`
        statusUpdate(UPDATE_ETH_CONNECTING);
    } // end of behavior for NETWORK_ETH_ACTIVE_STATE
}

void NetworkSm::NETWORK_ETH_ACTIVE_STATE_exit()
{
    // NETWORK_ETH_ACTIVE_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for NETWORK_ETH_ACTIVE_STATE
    
    this->stateId = StateId::NETWORK_STATE;
}

void NetworkSm::NETWORK_ETH_ACTIVE_STATE_connect_to_ap()
{
    // NETWORK_ETH_ACTIVE_STATE behavior
    // uml: CONNECT_TO_AP TransitionTo(ETH_CONNECTING_NEW_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_ETH_ACTIVE_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ETH_CONNECTING_NEW_STATE`.
        ETH_CONNECTING_NEW_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_ETH_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_ETH_ACTIVE_STATE_delete_wifi()
{
    // NETWORK_ETH_ACTIVE_STATE behavior
    // uml: DELETE_WIFI / { clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT); }
    {
        // Step 1: execute action `clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT);`
        clearWifiConfig();
        statusUpdate(UPDATE_USER_DISCONNECT);
    } // end of behavior for NETWORK_ETH_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_ETH_ACTIVE_STATE_eth_got_ip()
{
    // NETWORK_ETH_ACTIVE_STATE behavior
    // uml: ETH_GOT_IP TransitionTo(ETH_ACTIVE_CONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_ETH_ACTIVE_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ETH_ACTIVE_CONNECTED_STATE`.
        ETH_ACTIVE_CONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_ETH_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_ETH_ACTIVE_STATE_eth_link_down()
{
    // NETWORK_ETH_ACTIVE_STATE behavior
    // uml: ETH_LINK_DOWN TransitionTo(ETH_ACTIVE_LINKDOWN_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_ETH_ACTIVE_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ETH_ACTIVE_LINKDOWN_STATE`.
        ETH_ACTIVE_LINKDOWN_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_ETH_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_ETH_ACTIVE_STATE_eth_link_up()
{
    // NETWORK_ETH_ACTIVE_STATE behavior
    // uml: ETH_LINK_UP TransitionTo(ETH_ACTIVE_LINKUP_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_ETH_ACTIVE_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ETH_ACTIVE_LINKUP_STATE`.
        ETH_ACTIVE_LINKUP_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_ETH_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_ETH_ACTIVE_STATE_timer()
{
    // NETWORK_ETH_ACTIVE_STATE behavior
    // uml: TIMER TransitionTo(REBOOT_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_ETH_ACTIVE_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ETH_ACTIVE_CONNECTED_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::ETH_ACTIVE_CONNECTED_STATE_enter()
{
    this->stateId = StateId::ETH_ACTIVE_CONNECTED_STATE;
    
    // ETH_ACTIVE_CONNECTED_STATE behavior
    // uml: enter / { stopTimer();\nstatusUpdate(UPDATE_ETH_CONNECTED); }
    {
        // Step 1: execute action `stopTimer();\nstatusUpdate(UPDATE_ETH_CONNECTED);`
        stopTimer();
        statusUpdate(UPDATE_ETH_CONNECTED);
    } // end of behavior for ETH_ACTIVE_CONNECTED_STATE
}

void NetworkSm::ETH_ACTIVE_CONNECTED_STATE_exit()
{
    this->stateId = StateId::NETWORK_ETH_ACTIVE_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ETH_ACTIVE_LINKDOWN_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::ETH_ACTIVE_LINKDOWN_STATE_enter()
{
    this->stateId = StateId::ETH_ACTIVE_LINKDOWN_STATE;
    
    // ETH_ACTIVE_LINKDOWN_STATE behavior
    // uml: enter / { startEthLinkDownTimer();\nstatusUpdate(UPDATE_ETH_LINK_DOWN); }
    {
        // Step 1: execute action `startEthLinkDownTimer();\nstatusUpdate(UPDATE_ETH_LINK_DOWN);`
        startEthLinkDownTimer();
        statusUpdate(UPDATE_ETH_LINK_DOWN);
    } // end of behavior for ETH_ACTIVE_LINKDOWN_STATE
}

void NetworkSm::ETH_ACTIVE_LINKDOWN_STATE_exit()
{
    // ETH_ACTIVE_LINKDOWN_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for ETH_ACTIVE_LINKDOWN_STATE
    
    this->stateId = StateId::NETWORK_ETH_ACTIVE_STATE;
}

void NetworkSm::ETH_ACTIVE_LINKDOWN_STATE_timer()
{
    bool consume_event = false;
    
    // ETH_ACTIVE_LINKDOWN_STATE behavior
    // uml: TIMER [hasWifiConfig()] TransitionTo(WIFI_INITIALIZING_STATE)
    if (hasWifiConfig())
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_INITIALIZING_STATE`.
        NETWORK_WIFI_ACTIVE_STATE_enter();
        WIFI_INITIALIZING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ETH_ACTIVE_LINKDOWN_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        NETWORK_ETH_ACTIVE_STATE_timer();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ETH_ACTIVE_LINKUP_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::ETH_ACTIVE_LINKUP_STATE_enter()
{
    this->stateId = StateId::ETH_ACTIVE_LINKUP_STATE;
    
    // ETH_ACTIVE_LINKUP_STATE behavior
    // uml: enter / { startDhcpTimer();\nstatusUpdate(UPDATE_ETH_LINK_UP); }
    {
        // Step 1: execute action `startDhcpTimer();\nstatusUpdate(UPDATE_ETH_LINK_UP);`
        startDhcpTimer();
        statusUpdate(UPDATE_ETH_LINK_UP);
    } // end of behavior for ETH_ACTIVE_LINKUP_STATE
}

void NetworkSm::ETH_ACTIVE_LINKUP_STATE_exit()
{
    this->stateId = StateId::NETWORK_ETH_ACTIVE_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ETH_CONNECTING_NEW_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::ETH_CONNECTING_NEW_STATE_enter()
{
    this->stateId = StateId::ETH_CONNECTING_NEW_STATE;
    
    // ETH_CONNECTING_NEW_STATE behavior
    // uml: enter / { startWifiDhcpClient();\nconnectWifi(); }
    {
        // Step 1: execute action `startWifiDhcpClient();\nconnectWifi();`
        startWifiDhcpClient();
        connectWifi();
    } // end of behavior for ETH_CONNECTING_NEW_STATE
}

void NetworkSm::ETH_CONNECTING_NEW_STATE_exit()
{
    // ETH_CONNECTING_NEW_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for ETH_CONNECTING_NEW_STATE
    
    this->stateId = StateId::NETWORK_ETH_ACTIVE_STATE;
}

void NetworkSm::ETH_CONNECTING_NEW_STATE_eth_fallback()
{
    // ETH_CONNECTING_NEW_STATE behavior
    // uml: ETH_FALLBACK TransitionTo(ETH_ACTIVE_CONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
        ETH_CONNECTING_NEW_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ETH_ACTIVE_CONNECTED_STATE`.
        ETH_ACTIVE_CONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ETH_CONNECTING_NEW_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::ETH_CONNECTING_NEW_STATE_lost_connection()
{
    // ETH_CONNECTING_NEW_STATE behavior
    // uml: LOST_CONNECTION / { statusUpdate(UPDATE_FAILED_ATTEMPT);\ntrigger_eth_fallback_event(); }
    {
        // Step 1: execute action `statusUpdate(UPDATE_FAILED_ATTEMPT);\ntrigger_eth_fallback_event();`
        statusUpdate(UPDATE_FAILED_ATTEMPT);
        trigger_eth_fallback_event();
    } // end of behavior for ETH_CONNECTING_NEW_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::ETH_CONNECTING_NEW_STATE_wifi_got_ip()
{
    // ETH_CONNECTING_NEW_STATE behavior
    // uml: WIFI_GOT_IP TransitionTo(WIFI_CONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_CONNECTED_STATE`.
        NETWORK_WIFI_ACTIVE_STATE_enter();
        WIFI_CONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ETH_CONNECTING_NEW_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ETH_INITIALIZING_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::ETH_INITIALIZING_STATE_enter()
{
    this->stateId = StateId::ETH_INITIALIZING_STATE;
    
    // ETH_INITIALIZING_STATE behavior
    // uml: enter / { initEthernet(); }
    {
        // Step 1: execute action `initEthernet();`
        initEthernet();
    } // end of behavior for ETH_INITIALIZING_STATE
}

void NetworkSm::ETH_INITIALIZING_STATE_exit()
{
    this->stateId = StateId::NETWORK_ETH_ACTIVE_STATE;
}

void NetworkSm::ETH_INITIALIZING_STATE_net_init_fail()
{
    bool consume_event = false;
    
    // ETH_INITIALIZING_STATE behavior
    // uml: NET_INIT_FAIL TransitionTo(WIFI_INITIALIZING_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_INITIALIZING_STATE`.
        NETWORK_WIFI_ACTIVE_STATE_enter();
        WIFI_INITIALIZING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ETH_INITIALIZING_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        NETWORK_STATE_net_init_fail();
    }
}

void NetworkSm::ETH_INITIALIZING_STATE_net_init_success()
{
    // ETH_INITIALIZING_STATE behavior
    // uml: NET_INIT_SUCCESS TransitionTo(ETH_STARTING_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
        ETH_INITIALIZING_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ETH_STARTING_STATE`.
        ETH_STARTING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ETH_INITIALIZING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ETH_STARTING_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::ETH_STARTING_STATE_enter()
{
    this->stateId = StateId::ETH_STARTING_STATE;
    
    // ETH_STARTING_STATE behavior
    // uml: enter / { startEthLinkTimer(); }
    {
        // Step 1: execute action `startEthLinkTimer();`
        startEthLinkTimer();
    } // end of behavior for ETH_STARTING_STATE
}

void NetworkSm::ETH_STARTING_STATE_exit()
{
    this->stateId = StateId::NETWORK_ETH_ACTIVE_STATE;
}

void NetworkSm::ETH_STARTING_STATE_timer()
{
    bool consume_event = false;
    
    // ETH_STARTING_STATE behavior
    // uml: TIMER TransitionTo(WIFI_INITIALIZING_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_INITIALIZING_STATE`.
        NETWORK_WIFI_ACTIVE_STATE_enter();
        WIFI_INITIALIZING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ETH_STARTING_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        NETWORK_ETH_ACTIVE_STATE_timer();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state NETWORK_WIFI_ACTIVE_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_enter()
{
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_exit()
{
    // NETWORK_WIFI_ACTIVE_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    
    this->stateId = StateId::NETWORK_STATE;
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_configure_wifi()
{
    // NETWORK_WIFI_ACTIVE_STATE behavior
    // uml: CONFIGURE_WIFI TransitionTo(WIFI_IMPROV_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_IMPROV_STATE`.
        WIFI_IMPROV_STATE_enter();
        
        // Finish transition by calling pseudo state transition function.
        WIFI_IMPROV_STATE_InitialState_transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_connect_to_ap()
{
    // NETWORK_WIFI_ACTIVE_STATE behavior
    // uml: CONNECT_TO_AP TransitionTo(WIFI_CONNECTING_NEW_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_WIFI_ACTIVE_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_CONNECTING_NEW_STATE`.
        WIFI_CONNECTING_NEW_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_delete_wifi()
{
    // NETWORK_WIFI_ACTIVE_STATE behavior
    // uml: DELETE_WIFI TransitionTo(WIFI_USER_DISCONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_WIFI_ACTIVE_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_USER_DISCONNECTED_STATE`.
        WIFI_USER_DISCONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_eth_fallback()
{
    // NETWORK_WIFI_ACTIVE_STATE behavior
    // uml: ETH_FALLBACK TransitionTo(ETH_ACTIVE_CONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ETH_ACTIVE_CONNECTED_STATE`.
        NETWORK_ETH_ACTIVE_STATE_enter();
        ETH_ACTIVE_CONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_eth_got_ip()
{
    // NETWORK_WIFI_ACTIVE_STATE behavior
    // uml: ETH_GOT_IP TransitionTo(REBOOT_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_eth_link_up()
{
    // NETWORK_WIFI_ACTIVE_STATE behavior
    // uml: ETH_LINK_UP / { LOGD("ETH link up in WiFi mode"); }
    {
        // Step 1: execute action `LOGD("ETH link up in WiFi mode");`
        LOGD("ETH link up in WiFi mode");
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip()
{
    // NETWORK_WIFI_ACTIVE_STATE behavior
    // uml: WIFI_GOT_IP TransitionTo(WIFI_CONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_WIFI_ACTIVE_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_CONNECTED_STATE`.
        WIFI_CONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::NETWORK_WIFI_ACTIVE_STATE_ChoicePoint__transition()
{
    // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() behavior
    // uml: [shouldRetryActiveWifiConnection()] TransitionTo(WIFI_LOST_CONNECTION_STATE)
    if (shouldRetryActiveWifiConnection())
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_LOST_CONNECTION_STATE`.
        WIFI_LOST_CONNECTION_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()
    
    // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() behavior
    // uml: else TransitionTo(REBOOT_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_CONNECTED_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_CONNECTED_STATE_enter()
{
    this->stateId = StateId::WIFI_CONNECTED_STATE;
    
    // WIFI_CONNECTED_STATE behavior
    // uml: enter / { stopTimer();\nsaveActiveWifiConfig();\nstatusUpdate(UPDATE_WIFI_CONNECTED); }
    {
        // Step 1: execute action `stopTimer();\nsaveActiveWifiConfig();\nstatusUpdate(UPDATE_WIFI_CONNECTED);`
        stopTimer();
        saveActiveWifiConfig();
        statusUpdate(UPDATE_WIFI_CONNECTED);
    } // end of behavior for WIFI_CONNECTED_STATE
}

void NetworkSm::WIFI_CONNECTED_STATE_exit()
{
    // WIFI_CONNECTED_STATE behavior
    // uml: exit / { clearEventParameters(); }
    {
        // Step 1: execute action `clearEventParameters();`
        clearEventParameters();
    } // end of behavior for WIFI_CONNECTED_STATE
    
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::WIFI_CONNECTED_STATE_lost_connection()
{
    // WIFI_CONNECTED_STATE behavior
    // uml: LOST_CONNECTION / { statusUpdate(UPDATE_FAILED_ATTEMPT); } TransitionTo(WIFI_LOST_CONNECTION_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_CONNECTED_STATE_exit();
        
        // Step 2: Transition action: `statusUpdate(UPDATE_FAILED_ATTEMPT);`.
        statusUpdate(UPDATE_FAILED_ATTEMPT);
        
        // Step 3: Enter/move towards transition target `WIFI_LOST_CONNECTION_STATE`.
        WIFI_LOST_CONNECTION_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_CONNECTED_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_CONNECTING_NEW_FAILED_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_CONNECTING_NEW_FAILED_STATE_enter()
{
    this->stateId = StateId::WIFI_CONNECTING_NEW_FAILED_STATE;
    
    // WIFI_CONNECTING_NEW_FAILED_STATE behavior
    // uml: enter [isWifiConnected()] / { connectActiveSsid(); }
    if (isWifiConnected())
    {
        // Step 1: execute action `connectActiveSsid();`
        connectActiveSsid();
    } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
}

void NetworkSm::WIFI_CONNECTING_NEW_FAILED_STATE_exit()
{
    // WIFI_CONNECTING_NEW_FAILED_STATE behavior
    // uml: exit / { stopTimer();  clearEventParameters(); }
    {
        // Step 1: execute action `stopTimer();  clearEventParameters();`
        stopTimer();  clearEventParameters();
    } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
    
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::WIFI_CONNECTING_NEW_FAILED_STATE_connected()
{
    // WIFI_CONNECTING_NEW_FAILED_STATE behavior
    // uml: CONNECTED / { LOGI("Successfully connected to the previous access point. Waiting for IP Address"); }
    {
        // Step 1: execute action `LOGI("Successfully connected to the previous access point. Waiting for IP Address");`
        LOGI("Successfully connected to the previous access point. Waiting for IP Address");
    } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::WIFI_CONNECTING_NEW_FAILED_STATE_lost_connection()
{
    // WIFI_CONNECTING_NEW_FAILED_STATE behavior
    // uml: LOST_CONNECTION / { statusUpdate(UPDATE_FAILED_ATTEMPT); }
    {
        // Step 1: execute action `statusUpdate(UPDATE_FAILED_ATTEMPT);`
        statusUpdate(UPDATE_FAILED_ATTEMPT);
    } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::WIFI_CONNECTING_NEW_FAILED_STATE_wifi_got_ip()
{
    bool consume_event = false;
    
    // WIFI_CONNECTING_NEW_FAILED_STATE behavior
    // uml: WIFI_GOT_IP / { statusUpdate(UPDATE_FAILED_ATTEMPT_AND_RESTORE); } TransitionTo(WIFI_CONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_CONNECTING_NEW_FAILED_STATE_exit();
        
        // Step 2: Transition action: `statusUpdate(UPDATE_FAILED_ATTEMPT_AND_RESTORE);`.
        statusUpdate(UPDATE_FAILED_ATTEMPT_AND_RESTORE);
        
        // Step 3: Enter/move towards transition target `WIFI_CONNECTED_STATE`.
        WIFI_CONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_CONNECTING_NEW_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_CONNECTING_NEW_STATE_enter()
{
    this->stateId = StateId::WIFI_CONNECTING_NEW_STATE;
    
    // WIFI_CONNECTING_NEW_STATE behavior
    // uml: enter / { startWifiDhcpClient();\nconnectWifi(); }
    {
        // Step 1: execute action `startWifiDhcpClient();\nconnectWifi();`
        startWifiDhcpClient();
        connectWifi();
    } // end of behavior for WIFI_CONNECTING_NEW_STATE
}

void NetworkSm::WIFI_CONNECTING_NEW_STATE_exit()
{
    // WIFI_CONNECTING_NEW_STATE behavior
    // uml: exit / { stopTimer();\nclearEventParameters(); }
    {
        // Step 1: execute action `stopTimer();\nclearEventParameters();`
        stopTimer();
        clearEventParameters();
    } // end of behavior for WIFI_CONNECTING_NEW_STATE
    
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::WIFI_CONNECTING_NEW_STATE_connected()
{
    // WIFI_CONNECTING_NEW_STATE behavior
    // uml: CONNECTED / { LOGI("Successfully connected to the new access point. Waiting for IP Address"); }
    {
        // Step 1: execute action `LOGI("Successfully connected to the new access point. Waiting for IP Address");`
        LOGI("Successfully connected to the new access point. Waiting for IP Address");
    } // end of behavior for WIFI_CONNECTING_NEW_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::WIFI_CONNECTING_NEW_STATE_lost_connection()
{
    // WIFI_CONNECTING_NEW_STATE behavior
    // uml: LOST_CONNECTION [isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)] / { LOGI("Successfully disconnected from the existing access point. "); }
    if (isWifiErrReason(WIFI_REASON_ASSOC_LEAVE))
    {
        // Step 1: execute action `LOGI("Successfully disconnected from the existing access point. ");`
        LOGI("Successfully disconnected from the existing access point. ");
    } // end of behavior for WIFI_CONNECTING_NEW_STATE
    
    // WIFI_CONNECTING_NEW_STATE behavior
    // uml: LOST_CONNECTION [!isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)] TransitionTo(WIFI_CONNECTING_NEW_FAILED_STATE)
    if (!isWifiErrReason(WIFI_REASON_ASSOC_LEAVE))
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_CONNECTING_NEW_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_CONNECTING_NEW_FAILED_STATE`.
        WIFI_CONNECTING_NEW_FAILED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_CONNECTING_NEW_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_CONNECTING_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_CONNECTING_STATE_enter()
{
    this->stateId = StateId::WIFI_CONNECTING_STATE;
    
    // WIFI_CONNECTING_STATE behavior
    // uml: enter / { statusUpdate(UPDATE_WIFI_CONNECTING);\nstartWifiDhcpClient();\nconnectActiveSsid();\nstartWifiConnectedTimer(); }
    {
        // Step 1: execute action `statusUpdate(UPDATE_WIFI_CONNECTING);\nstartWifiDhcpClient();\nconnectActiveSsid();\nstartWifiConnectedTimer();`
        statusUpdate(UPDATE_WIFI_CONNECTING);
        startWifiDhcpClient();
        connectActiveSsid();
        startWifiConnectedTimer();
    } // end of behavior for WIFI_CONNECTING_STATE
}

void NetworkSm::WIFI_CONNECTING_STATE_exit()
{
    // WIFI_CONNECTING_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for WIFI_CONNECTING_STATE
    
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::WIFI_CONNECTING_STATE_connected()
{
    // WIFI_CONNECTING_STATE behavior
    // uml: CONNECTED TransitionTo(WIFI_W4_IP_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_CONNECTING_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_W4_IP_STATE`.
        WIFI_W4_IP_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_CONNECTING_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::WIFI_CONNECTING_STATE_lost_connection()
{
    // WIFI_CONNECTING_STATE behavior
    // uml: LOST_CONNECTION / { statusUpdate(UPDATE_FAILED_ATTEMPT); } TransitionTo(NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_CONNECTING_STATE_exit();
        
        // Step 2: Transition action: `statusUpdate(UPDATE_FAILED_ATTEMPT);`.
        statusUpdate(UPDATE_FAILED_ATTEMPT);
        
        // Step 3: Enter/move towards transition target `NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()`.
        // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        NETWORK_WIFI_ACTIVE_STATE_ChoicePoint__transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for WIFI_CONNECTING_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::WIFI_CONNECTING_STATE_timer()
{
    // WIFI_CONNECTING_STATE behavior
    // uml: TIMER TransitionTo(NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_CONNECTING_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()`.
        // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        NETWORK_WIFI_ACTIVE_STATE_ChoicePoint__transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for WIFI_CONNECTING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_INITIALIZING_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_INITIALIZING_STATE_enter()
{
    this->stateId = StateId::WIFI_INITIALIZING_STATE;
    
    // WIFI_INITIALIZING_STATE behavior
    // uml: enter / { if (initWifi()) {\n  trigger_init_success_event();\n} else {\n  trigger_configure_wifi_event();\n} }
    {
        // Step 1: execute action `if (initWifi()) {\n  trigger_init_success_event();\n} else {\n  trigger_configure_wifi_event();\n}`
        if (initWifi()) {
          trigger_init_success_event();
        } else {
          trigger_configure_wifi_event();
        }
    } // end of behavior for WIFI_INITIALIZING_STATE
}

void NetworkSm::WIFI_INITIALIZING_STATE_exit()
{
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::WIFI_INITIALIZING_STATE_configure_wifi()
{
    bool consume_event = false;
    
    // WIFI_INITIALIZING_STATE behavior
    // uml: CONFIGURE_WIFI TransitionTo(WIFI_IMPROV_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_IMPROV_STATE`.
        WIFI_IMPROV_STATE_enter();
        
        // Finish transition by calling pseudo state transition function.
        WIFI_IMPROV_STATE_InitialState_transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for WIFI_INITIALIZING_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        NETWORK_WIFI_ACTIVE_STATE_configure_wifi();
    }
}

void NetworkSm::WIFI_INITIALIZING_STATE_net_init_success()
{
    // WIFI_INITIALIZING_STATE behavior
    // uml: NET_INIT_SUCCESS TransitionTo(WIFI_CONNECTING_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_INITIALIZING_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_CONNECTING_STATE`.
        WIFI_CONNECTING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_INITIALIZING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_LOST_CONNECTION_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_LOST_CONNECTION_STATE_enter()
{
    this->stateId = StateId::WIFI_LOST_CONNECTION_STATE;
    
    // WIFI_LOST_CONNECTION_STATE behavior
    // uml: enter / { retryActiveWiFiConnection();\nstartWifiPollingTimer(); }
    {
        // Step 1: execute action `retryActiveWiFiConnection();\nstartWifiPollingTimer();`
        retryActiveWiFiConnection();
        startWifiPollingTimer();
    } // end of behavior for WIFI_LOST_CONNECTION_STATE
}

void NetworkSm::WIFI_LOST_CONNECTION_STATE_exit()
{
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::WIFI_LOST_CONNECTION_STATE_timer()
{
    // WIFI_LOST_CONNECTION_STATE behavior
    // uml: TIMER / { LOGI("WiFi polling timeout, retry connection"); } TransitionTo(WIFI_CONNECTING_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_LOST_CONNECTION_STATE_exit();
        
        // Step 2: Transition action: `LOGI("WiFi polling timeout, retry connection");`.
        LOGI("WiFi polling timeout, retry connection");
        
        // Step 3: Enter/move towards transition target `WIFI_CONNECTING_STATE`.
        WIFI_CONNECTING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_LOST_CONNECTION_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_USER_DISCONNECTED_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_USER_DISCONNECTED_STATE_enter()
{
    this->stateId = StateId::WIFI_USER_DISCONNECTED_STATE;
    
    // WIFI_USER_DISCONNECTED_STATE behavior
    // uml: enter / { clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT); }
    {
        // Step 1: execute action `clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT);`
        clearWifiConfig();
        statusUpdate(UPDATE_USER_DISCONNECT);
    } // end of behavior for WIFI_USER_DISCONNECTED_STATE
}

void NetworkSm::WIFI_USER_DISCONNECTED_STATE_exit()
{
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::WIFI_USER_DISCONNECTED_STATE_lost_connection()
{
    // WIFI_USER_DISCONNECTED_STATE behavior
    // uml: LOST_CONNECTION TransitionTo(WIFI_IMPROV_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::NETWORK_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_IMPROV_STATE`.
        WIFI_IMPROV_STATE_enter();
        
        // Finish transition by calling pseudo state transition function.
        WIFI_IMPROV_STATE_InitialState_transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for WIFI_USER_DISCONNECTED_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_W4_IP_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_W4_IP_STATE_enter()
{
    this->stateId = StateId::WIFI_W4_IP_STATE;
    
    // WIFI_W4_IP_STATE behavior
    // uml: enter / { startDhcpTimer();\nLOGI("Connected, waiting for IP"); }
    {
        // Step 1: execute action `startDhcpTimer();\nLOGI("Connected, waiting for IP");`
        startDhcpTimer();
        LOGI("Connected, waiting for IP");
    } // end of behavior for WIFI_W4_IP_STATE
}

void NetworkSm::WIFI_W4_IP_STATE_exit()
{
    // WIFI_W4_IP_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for WIFI_W4_IP_STATE
    
    this->stateId = StateId::NETWORK_WIFI_ACTIVE_STATE;
}

void NetworkSm::WIFI_W4_IP_STATE_timer()
{
    // WIFI_W4_IP_STATE behavior
    // uml: TIMER TransitionTo(NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_W4_IP_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()`.
        // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        NETWORK_WIFI_ACTIVE_STATE_ChoicePoint__transition();
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for WIFI_W4_IP_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::WIFI_W4_IP_STATE_wifi_got_ip()
{
    bool consume_event = false;
    
    // WIFI_W4_IP_STATE behavior
    // uml: WIFI_GOT_IP TransitionTo(WIFI_CONNECTED_STATE)
    {
        // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
        WIFI_W4_IP_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WIFI_CONNECTED_STATE`.
        WIFI_CONNECTED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_W4_IP_STATE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WIFI_IMPROV_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::WIFI_IMPROV_STATE_enter()
{
    this->stateId = StateId::WIFI_IMPROV_STATE;
    
    // WIFI_IMPROV_STATE behavior
    // uml: enter / { statusUpdate(UPDATE_WIFI_PROVISIONING); }
    {
        // Step 1: execute action `statusUpdate(UPDATE_WIFI_PROVISIONING);`
        statusUpdate(UPDATE_WIFI_PROVISIONING);
    } // end of behavior for WIFI_IMPROV_STATE
}

void NetworkSm::WIFI_IMPROV_STATE_exit()
{
    // WIFI_IMPROV_STATE behavior
    // uml: exit / { stopTimer(); }
    {
        // Step 1: execute action `stopTimer();`
        stopTimer();
    } // end of behavior for WIFI_IMPROV_STATE
    
    this->stateId = StateId::NETWORK_STATE;
}

void NetworkSm::WIFI_IMPROV_STATE_eth_got_ip()
{
    // WIFI_IMPROV_STATE behavior
    // uml: ETH_GOT_IP TransitionTo(REBOOT_STATE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `REBOOT_STATE`.
        REBOOT_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::WIFI_IMPROV_STATE_improv_ble_disconnect()
{
    // WIFI_IMPROV_STATE behavior
    // uml: IMPROV_BLE_DISCONNECT TransitionTo(IMPROV_STOPPED_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::WIFI_IMPROV_STATE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_STOPPED_STATE`.
        IMPROV_STOPPED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::WIFI_IMPROV_STATE_InitialState_transition()
{
    // WIFI_IMPROV_STATE.<InitialState> behavior
    // uml: TransitionTo(IMPROV_INITIALIZING_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_INITIALIZING_STATE`.
        IMPROV_INITIALIZING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for WIFI_IMPROV_STATE.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_AUTHORIZED_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::IMPROV_AUTHORIZED_STATE_enter()
{
    this->stateId = StateId::IMPROV_AUTHORIZED_STATE;
    
    // IMPROV_AUTHORIZED_STATE behavior
    // uml: enter / { setImprovAuthorized(); }
    {
        // Step 1: execute action `setImprovAuthorized();`
        setImprovAuthorized();
    } // end of behavior for IMPROV_AUTHORIZED_STATE
}

void NetworkSm::IMPROV_AUTHORIZED_STATE_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE;
}

void NetworkSm::IMPROV_AUTHORIZED_STATE_connect_to_ap()
{
    // IMPROV_AUTHORIZED_STATE behavior
    // uml: CONNECT_TO_AP TransitionTo(IMPROV_PROVISIONING_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        IMPROV_AUTHORIZED_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_PROVISIONING_STATE`.
        IMPROV_PROVISIONING_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IMPROV_AUTHORIZED_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::IMPROV_AUTHORIZED_STATE_improv_authorized_timeout()
{
    // IMPROV_AUTHORIZED_STATE behavior
    // uml: IMPROV_AUTHORIZED_TIMEOUT TransitionTo(IMPROV_AWAITING_AUTH_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        IMPROV_AUTHORIZED_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_AWAITING_AUTH_STATE`.
        IMPROV_AWAITING_AUTH_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IMPROV_AUTHORIZED_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_AWAITING_AUTH_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::IMPROV_AWAITING_AUTH_STATE_enter()
{
    this->stateId = StateId::IMPROV_AWAITING_AUTH_STATE;
    
    // IMPROV_AWAITING_AUTH_STATE behavior
    // uml: enter / { setImprovAuthRequired(); }
    {
        // Step 1: execute action `setImprovAuthRequired();`
        setImprovAuthRequired();
    } // end of behavior for IMPROV_AWAITING_AUTH_STATE
}

void NetworkSm::IMPROV_AWAITING_AUTH_STATE_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE;
}

void NetworkSm::IMPROV_AWAITING_AUTH_STATE_button_press()
{
    // IMPROV_AWAITING_AUTH_STATE behavior
    // uml: BUTTON_PRESS TransitionTo(IMPROV_AUTHORIZED_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        IMPROV_AWAITING_AUTH_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_AUTHORIZED_STATE`.
        IMPROV_AUTHORIZED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IMPROV_AWAITING_AUTH_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_INITIALIZING_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::IMPROV_INITIALIZING_STATE_enter()
{
    this->stateId = StateId::IMPROV_INITIALIZING_STATE;
    
    // IMPROV_INITIALIZING_STATE behavior
    // uml: enter / { startImprovWifi(); }
    {
        // Step 1: execute action `startImprovWifi();`
        startImprovWifi();
    } // end of behavior for IMPROV_INITIALIZING_STATE
}

void NetworkSm::IMPROV_INITIALIZING_STATE_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE;
}

void NetworkSm::IMPROV_INITIALIZING_STATE_net_init_success()
{
    // IMPROV_INITIALIZING_STATE behavior
    // uml: NET_INIT_SUCCESS TransitionTo(IMPROV_STOPPED_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        IMPROV_INITIALIZING_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_STOPPED_STATE`.
        IMPROV_STOPPED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IMPROV_INITIALIZING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_PROVISIONED_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::IMPROV_PROVISIONED_STATE_enter()
{
    this->stateId = StateId::IMPROV_PROVISIONED_STATE;
    
    // IMPROV_PROVISIONED_STATE behavior
    // uml: enter / { saveActiveWifiConfig();\nsetImprovWifiProvisioned();\nvTaskDelay(pdMS_TO_TICKS(2000));\ntrigger_reboot_event(); }
    {
        // Step 1: execute action `saveActiveWifiConfig();\nsetImprovWifiProvisioned();\nvTaskDelay(pdMS_TO_TICKS(2000));\ntrigger_reboot_event();`
        saveActiveWifiConfig();
        setImprovWifiProvisioned();
        vTaskDelay(pdMS_TO_TICKS(2000));
        trigger_reboot_event();
    } // end of behavior for IMPROV_PROVISIONED_STATE
}

void NetworkSm::IMPROV_PROVISIONED_STATE_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_PROVISIONING_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::IMPROV_PROVISIONING_STATE_enter()
{
    this->stateId = StateId::IMPROV_PROVISIONING_STATE;
    
    // IMPROV_PROVISIONING_STATE behavior
    // uml: enter / { setImprovProvisioning();\nstartImprovTimer();\nstartWifiDhcpClient();\nconnectWifi(); }
    {
        // Step 1: execute action `setImprovProvisioning();\nstartImprovTimer();\nstartWifiDhcpClient();\nconnectWifi();`
        setImprovProvisioning();
        startImprovTimer();
        startWifiDhcpClient();
        connectWifi();
    } // end of behavior for IMPROV_PROVISIONING_STATE
}

void NetworkSm::IMPROV_PROVISIONING_STATE_exit()
{
    // IMPROV_PROVISIONING_STATE behavior
    // uml: exit / { stopTimer();\nclearEventParameters(); }
    {
        // Step 1: execute action `stopTimer();\nclearEventParameters();`
        stopTimer();
        clearEventParameters();
    } // end of behavior for IMPROV_PROVISIONING_STATE
    
    this->stateId = StateId::WIFI_IMPROV_STATE;
}

void NetworkSm::IMPROV_PROVISIONING_STATE_connected()
{
    // IMPROV_PROVISIONING_STATE behavior
    // uml: CONNECTED / { LOGI("Successfully connected to the new access point. Waiting for IP Address"); }
    {
        // Step 1: execute action `LOGI("Successfully connected to the new access point. Waiting for IP Address");`
        LOGI("Successfully connected to the new access point. Waiting for IP Address");
    } // end of behavior for IMPROV_PROVISIONING_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::IMPROV_PROVISIONING_STATE_lost_connection()
{
    // IMPROV_PROVISIONING_STATE behavior
    // uml: LOST_CONNECTION / { onImprovConnectTimeout(); } TransitionTo(IMPROV_AUTHORIZED_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        IMPROV_PROVISIONING_STATE_exit();
        
        // Step 2: Transition action: `onImprovConnectTimeout();`.
        onImprovConnectTimeout();
        
        // Step 3: Enter/move towards transition target `IMPROV_AUTHORIZED_STATE`.
        IMPROV_AUTHORIZED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IMPROV_PROVISIONING_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::IMPROV_PROVISIONING_STATE_timer()
{
    // IMPROV_PROVISIONING_STATE behavior
    // uml: TIMER / { onImprovConnectTimeout(); } TransitionTo(IMPROV_AUTHORIZED_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        IMPROV_PROVISIONING_STATE_exit();
        
        // Step 2: Transition action: `onImprovConnectTimeout();`.
        onImprovConnectTimeout();
        
        // Step 3: Enter/move towards transition target `IMPROV_AUTHORIZED_STATE`.
        IMPROV_AUTHORIZED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IMPROV_PROVISIONING_STATE
    
    // No ancestor handles this event.
}

void NetworkSm::IMPROV_PROVISIONING_STATE_wifi_got_ip()
{
    // IMPROV_PROVISIONING_STATE behavior
    // uml: WIFI_GOT_IP TransitionTo(IMPROV_PROVISIONED_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        IMPROV_PROVISIONING_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_PROVISIONED_STATE`.
        IMPROV_PROVISIONED_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IMPROV_PROVISIONING_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state IMPROV_STOPPED_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::IMPROV_STOPPED_STATE_enter()
{
    this->stateId = StateId::IMPROV_STOPPED_STATE;
    
    // IMPROV_STOPPED_STATE behavior
    // uml: enter / { setImprovStopped(); }
    {
        // Step 1: execute action `setImprovStopped();`
        setImprovStopped();
    } // end of behavior for IMPROV_STOPPED_STATE
}

void NetworkSm::IMPROV_STOPPED_STATE_exit()
{
    this->stateId = StateId::WIFI_IMPROV_STATE;
}

void NetworkSm::IMPROV_STOPPED_STATE_improv_ble_connect()
{
    // IMPROV_STOPPED_STATE behavior
    // uml: IMPROV_BLE_CONNECT TransitionTo(IMPROV_AWAITING_AUTH_STATE)
    {
        // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
        IMPROV_STOPPED_STATE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `IMPROV_AWAITING_AUTH_STATE`.
        IMPROV_AWAITING_AUTH_STATE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for IMPROV_STOPPED_STATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state REBOOT_STATE
////////////////////////////////////////////////////////////////////////////////

void NetworkSm::REBOOT_STATE_enter()
{
    this->stateId = StateId::REBOOT_STATE;
    
    // REBOOT_STATE behavior
    // uml: enter / { reboot(); }
    {
        // Step 1: execute action `reboot();`
        reboot();
    } // end of behavior for REBOOT_STATE
}

void NetworkSm::REBOOT_STATE_exit()
{
    this->stateId = StateId::ROOT;
}

// Thread safe.
char const * NetworkSm::stateIdToString(StateId id)
{
    switch (id)
    {
        case StateId::ROOT: return "ROOT";
        case StateId::NETWORK_STATE: return "NETWORK_STATE";
        case StateId::NETWORK_ETH_ACTIVE_STATE: return "NETWORK_ETH_ACTIVE_STATE";
        case StateId::ETH_ACTIVE_CONNECTED_STATE: return "ETH_ACTIVE_CONNECTED_STATE";
        case StateId::ETH_ACTIVE_LINKDOWN_STATE: return "ETH_ACTIVE_LINKDOWN_STATE";
        case StateId::ETH_ACTIVE_LINKUP_STATE: return "ETH_ACTIVE_LINKUP_STATE";
        case StateId::ETH_CONNECTING_NEW_STATE: return "ETH_CONNECTING_NEW_STATE";
        case StateId::ETH_INITIALIZING_STATE: return "ETH_INITIALIZING_STATE";
        case StateId::ETH_STARTING_STATE: return "ETH_STARTING_STATE";
        case StateId::NETWORK_WIFI_ACTIVE_STATE: return "NETWORK_WIFI_ACTIVE_STATE";
        case StateId::WIFI_CONNECTED_STATE: return "WIFI_CONNECTED_STATE";
        case StateId::WIFI_CONNECTING_NEW_FAILED_STATE: return "WIFI_CONNECTING_NEW_FAILED_STATE";
        case StateId::WIFI_CONNECTING_NEW_STATE: return "WIFI_CONNECTING_NEW_STATE";
        case StateId::WIFI_CONNECTING_STATE: return "WIFI_CONNECTING_STATE";
        case StateId::WIFI_INITIALIZING_STATE: return "WIFI_INITIALIZING_STATE";
        case StateId::WIFI_LOST_CONNECTION_STATE: return "WIFI_LOST_CONNECTION_STATE";
        case StateId::WIFI_USER_DISCONNECTED_STATE: return "WIFI_USER_DISCONNECTED_STATE";
        case StateId::WIFI_W4_IP_STATE: return "WIFI_W4_IP_STATE";
        case StateId::WIFI_IMPROV_STATE: return "WIFI_IMPROV_STATE";
        case StateId::IMPROV_AUTHORIZED_STATE: return "IMPROV_AUTHORIZED_STATE";
        case StateId::IMPROV_AWAITING_AUTH_STATE: return "IMPROV_AWAITING_AUTH_STATE";
        case StateId::IMPROV_INITIALIZING_STATE: return "IMPROV_INITIALIZING_STATE";
        case StateId::IMPROV_PROVISIONED_STATE: return "IMPROV_PROVISIONED_STATE";
        case StateId::IMPROV_PROVISIONING_STATE: return "IMPROV_PROVISIONING_STATE";
        case StateId::IMPROV_STOPPED_STATE: return "IMPROV_STOPPED_STATE";
        case StateId::REBOOT_STATE: return "REBOOT_STATE";
        default: return "?";
    }
}

// Thread safe.
char const * NetworkSm::eventIdToString(EventId id)
{
    switch (id)
    {
        case EventId::BUTTON_PRESS: return "BUTTON_PRESS";
        case EventId::CONFIGURE_WIFI: return "CONFIGURE_WIFI";
        case EventId::CONNECT_TO_AP: return "CONNECT_TO_AP";
        case EventId::CONNECTED: return "CONNECTED";
        case EventId::DELETE_WIFI: return "DELETE_WIFI";
        case EventId::ETH_FALLBACK: return "ETH_FALLBACK";
        case EventId::ETH_GOT_IP: return "ETH_GOT_IP";
        case EventId::ETH_LINK_DOWN: return "ETH_LINK_DOWN";
        case EventId::ETH_LINK_UP: return "ETH_LINK_UP";
        case EventId::IMPROV_AUTHORIZED_TIMEOUT: return "IMPROV_AUTHORIZED_TIMEOUT";
        case EventId::IMPROV_BLE_CONNECT: return "IMPROV_BLE_CONNECT";
        case EventId::IMPROV_BLE_DISCONNECT: return "IMPROV_BLE_DISCONNECT";
        case EventId::LOST_CONNECTION: return "LOST_CONNECTION";
        case EventId::NET_INIT_FAIL: return "NET_INIT_FAIL";
        case EventId::NET_INIT_SUCCESS: return "NET_INIT_SUCCESS";
        case EventId::REBOOT: return "REBOOT";
        case EventId::START: return "START";
        case EventId::TIMER: return "TIMER";
        case EventId::WIFI_GOT_IP: return "WIFI_GOT_IP";
        default: return "?";
    }
}
