<!-- 
  -- This file was generated by StateSmith.
  -- It serves as an example of how to use the generated state machine in a web page.
  -- It also serves as an interactive console that you can use to validate the
  -- state machine's behavior.
  --
  -- Using NetworkSm.js generally looks like:
  --   var sm = new NetworkSm();
  --   sm.start();
  --
  -- And then using sm.dispatchEvent() to dispatch events to the state machine.
  -->
<html>
  <head>
    <link rel='icon' type='image/png' href='https://statesmith.github.io/favicon.png'>
    <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined'>
    <style>
      body {
        display: flex;
        flex-direction: row;
        margin: 0px;
      }

      /* Fix for mermaid content requiring scroll bars https://github.com/StateSmith/StateSmith/issues/288 */
      pre.mermaid {
        margin: 0px;
      }

      .wrapper {
        height: 100vh;
        width: 100vw;
        display: flex;
      }

      .pane {
        padding: 1em;
        min-width: 200px;
      }

      .titlebar-icon {
        font-family: 'Material Symbols Outlined', sans-serif;
        font-size: 16px;
        color: #777;
        border-radius: 5px;
      }

      .gutter {
        width: 10px;
        height: 100%;
        background: #ccc;
        position: absolute;
        top: 0;
        left: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1;
        overflow: auto;
        padding: 10px;
      }

      .sidebar {
        width: 300px;
        padding-top: 0px;
        position: relative;
        background-color: #f0f0f0;
        border-left: 1px solid #ccc;
        display: flex;
        flex-direction: column;
      }

      #buttons {
        display: flex;
        flex-direction: column;
      }

      .titlebar {
        background-color: #ddd;
        border-bottom: 1px solid #ccc;
        font-weight: bold;
        padding: 5px;
        display: flex;
      }

      .console {
        border-collapse: collapse;
        margin-top: 10px;
        width: 100%;
      }

      table.console td.timestamp {
        display: none;
      }

      table.console.timestamps td.timestamp {
        display: table-cell;
      }

      table.console td {
          color: rgba(0, 0, 0, 0.7);
      }

      table.console td .dispatched {
          font-weight: bold;
          color: rgba(0, 0, 0, 1);
      }

      table.console tr:has(+tr td .dispatched) {
          border-bottom: 0px;
      }

      table.console tr:has(+tr td .dispatched) td {
          padding-bottom: 25px;
      }

      .console th {
        background-color: #f0f0f0;
        border-bottom: 1px solid #ccc;
        font-weight: normal;
        padding: 5px;
        text-align: left;
      }

      .console tbody {
        font-family: monospace;
      }

      .console tr {
        border-bottom: 1px solid #ccc;
      }

      .console td {
        padding: 5px;
      }
  
      .console td.timestamp {
        font-size: small;
      }

      .history {
        margin-top: 30px;       
        display: flex;
        overflow: auto;    
        flex-direction: column-reverse;
      }

      .console tr:last-child td {
        border-bottom: none;
      }

      .dispatched {
        font-weight: bold;
      }

      .dispatched > .trigger {
        border: 1px solid #000;
        border-radius: 4px;
        padding: 2px 10px 2px 10px;
      }

      button {
        margin: 5px;
      }

      .dropbtn {
        border: none;
        cursor: pointer;
      }

      .dropbtn:hover, .dropbtn:focus {
        background-color: #f1f1f1;
      }

      .dropdown {
        position: relative;
        display: inline-block;
        margin-left: auto;
      }

      .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        background-color: #f1f1f1;
        min-width: 160px;
        overflow: auto;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }

      .dropdown-content .dropdown-item {
        padding: 12px 16px;
        font-weight: normal;
      }

      .show {display: block;}

      .transition.active {
        stroke: #fff5ad !important;
        stroke-width: 5px !important;
        filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));
      }

      .statediagram-state.active > * {
        fill: #fff5ad !important;
        stroke-width: 2px !important;
      }

    </style>
  </head>

  <body>
    <div class="wrapper">
    <div class="pane main">
        <pre class="mermaid">
stateDiagram

%% Initial state name as "." so that it fits in black circle shape.
%% See https://github.com/StateSmith/StateSmith/issues/404
state "." as ROOT.(InitialState)

state NETWORK_STATE {

        state NETWORK_ETH_ACTIVE_STATE {

                ETH_INITIALIZING_STATE

                ETH_INITIALIZING_STATE : ETH_INITIALIZING_STATE

                ETH_INITIALIZING_STATE : enter / #123; initEthernet()#59; #125;

                ETH_ACTIVE_LINKUP_STATE

                ETH_ACTIVE_LINKUP_STATE : ETH_ACTIVE_LINKUP_STATE

                ETH_ACTIVE_LINKUP_STATE : enter / #123; startDhcpTimer()#59;\nstatusUpdate(UPDATE_ETH_LINK_UP)#59; #125;

                ETH_ACTIVE_LINKDOWN_STATE

                ETH_ACTIVE_LINKDOWN_STATE : ETH_ACTIVE_LINKDOWN_STATE

                ETH_ACTIVE_LINKDOWN_STATE : enter / #123; startEthLinkDownTimer()#59;\nstatusUpdate(UPDATE_ETH_LINK_DOWN)#59; #125;

                ETH_ACTIVE_LINKDOWN_STATE : exit / #123; stopTimer()#59; #125;

                ETH_ACTIVE_CONNECTED_STATE

                ETH_ACTIVE_CONNECTED_STATE : ETH_ACTIVE_CONNECTED_STATE

                ETH_ACTIVE_CONNECTED_STATE : enter / #123; stopTimer()#59;\nstatusUpdate(UPDATE_ETH_CONNECTED)#59; #125;

                ETH_CONNECTING_NEW_STATE

                ETH_CONNECTING_NEW_STATE : ETH_CONNECTING_NEW_STATE

                ETH_CONNECTING_NEW_STATE : enter / #123; startWifiDhcpClient()#59;\nconnectWifi()#59; #125;

                ETH_CONNECTING_NEW_STATE : exit / #123; stopTimer()#59; #125;

                ETH_CONNECTING_NEW_STATE : LOST_CONNECTION / #123; statusUpdate(UPDATE_FAILED_ATTEMPT)#59;\ntrigger_eth_fallback_event()#59; #125;

                ETH_STARTING_STATE

                ETH_STARTING_STATE : ETH_STARTING_STATE

                ETH_STARTING_STATE : enter / #123; startEthLinkTimer()#59; #125;

        }

        state NETWORK_WIFI_ACTIVE_STATE {

                WIFI_INITIALIZING_STATE

                WIFI_INITIALIZING_STATE : WIFI_INITIALIZING_STATE

                WIFI_INITIALIZING_STATE : enter / #123; if (initWifi()) #123;\n  trigger_init_success_event()#59;\n#125; else #123;\n  trigger_configure_wifi_event()#59;\n#125; #125;

                WIFI_CONNECTING_STATE

                WIFI_CONNECTING_STATE : WIFI_CONNECTING_STATE

                WIFI_CONNECTING_STATE : enter / #123; statusUpdate(UPDATE_WIFI_CONNECTING)#59;\nstartWifiDhcpClient()#59;\nconnectActiveSsid()#59;\nstartWifiConnectedTimer()#59; #125;

                WIFI_CONNECTING_STATE : exit / #123; stopTimer()#59; #125;

                WIFI_CONNECTING_NEW_STATE

                WIFI_CONNECTING_NEW_STATE : WIFI_CONNECTING_NEW_STATE

                WIFI_CONNECTING_NEW_STATE : enter / #123; startWifiDhcpClient()#59;\nconnectWifi()#59; #125;

                WIFI_CONNECTING_NEW_STATE : exit / #123; stopTimer()#59;\nclearEventParameters()#59; #125;

                WIFI_CONNECTING_NEW_STATE : CONNECTED / #123; LOGI("Successfully connected to the new access point. Waiting for IP Address")#59; #125;

                WIFI_CONNECTING_NEW_STATE : LOST_CONNECTION [isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)] / #123; LOGI("Successfully disconnected from the existing access point. ")#59; #125;

                WIFI_CONNECTING_NEW_FAILED_STATE

                WIFI_CONNECTING_NEW_FAILED_STATE : WIFI_CONNECTING_NEW_FAILED_STATE

                WIFI_CONNECTING_NEW_FAILED_STATE : enter [isWifiConnected()] / #123; connectActiveSsid()#59; #125;

                WIFI_CONNECTING_NEW_FAILED_STATE : exit / #123; stopTimer()#59;  clearEventParameters()#59; #125;

                WIFI_CONNECTING_NEW_FAILED_STATE : CONNECTED / #123; LOGI("Successfully connected to the previous access point. Waiting for IP Address")#59; #125;

                WIFI_CONNECTING_NEW_FAILED_STATE : LOST_CONNECTION / #123; statusUpdate(UPDATE_FAILED_ATTEMPT)#59; #125;

                WIFI_CONNECTED_STATE

                WIFI_CONNECTED_STATE : WIFI_CONNECTED_STATE

                WIFI_CONNECTED_STATE : enter / #123; stopTimer()#59;\nsaveActiveWifiConfig()#59;\nstatusUpdate(UPDATE_WIFI_CONNECTED)#59; #125;

                WIFI_CONNECTED_STATE : exit / #123; clearEventParameters()#59; #125;

                WIFI_LOST_CONNECTION_STATE

                WIFI_LOST_CONNECTION_STATE : WIFI_LOST_CONNECTION_STATE

                WIFI_LOST_CONNECTION_STATE : enter / #123; retryActiveWiFiConnection()#59;\nstartWifiPollingTimer()#59; #125;

                state NETWORK_WIFI_ACTIVE_STATE.(ChoicePoint)() <<choice>>

                WIFI_USER_DISCONNECTED_STATE

                WIFI_USER_DISCONNECTED_STATE : WIFI_USER_DISCONNECTED_STATE

                WIFI_USER_DISCONNECTED_STATE : enter / #123; clearWifiConfig()#59;\nstatusUpdate(UPDATE_USER_DISCONNECT)#59; #125;

                WIFI_W4_IP_STATE

                WIFI_W4_IP_STATE : WIFI_W4_IP_STATE

                WIFI_W4_IP_STATE : enter / #123; startDhcpTimer()#59;\nLOGI("Connected, waiting for IP")#59; #125;

                WIFI_W4_IP_STATE : exit / #123; stopTimer()#59; #125;

        }

        state WIFI_IMPROV_STATE {

                IMPROV_AWAITING_AUTH_STATE

                IMPROV_AWAITING_AUTH_STATE : IMPROV_AWAITING_AUTH_STATE

                IMPROV_AWAITING_AUTH_STATE : enter / #123; setImprovAuthRequired()#59; #125;

                IMPROV_AUTHORIZED_STATE

                IMPROV_AUTHORIZED_STATE : IMPROV_AUTHORIZED_STATE

                IMPROV_AUTHORIZED_STATE : enter / #123; setImprovAuthorized()#59; #125;

                IMPROV_PROVISIONING_STATE

                IMPROV_PROVISIONING_STATE : IMPROV_PROVISIONING_STATE

                IMPROV_PROVISIONING_STATE : enter / #123; setImprovProvisioning()#59;\nstartImprovTimer()#59;\nstartWifiDhcpClient()#59;\nconnectWifi()#59; #125;

                IMPROV_PROVISIONING_STATE : exit / #123; stopTimer()#59;\nclearEventParameters()#59; #125;

                IMPROV_PROVISIONING_STATE : CONNECTED / #123; LOGI("Successfully connected to the new access point. Waiting for IP Address")#59; #125;

                IMPROV_PROVISIONED_STATE

                IMPROV_PROVISIONED_STATE : IMPROV_PROVISIONED_STATE

                IMPROV_PROVISIONED_STATE : enter / #123; saveActiveWifiConfig()#59;\nsetImprovWifiProvisioned()#59;\nvTaskDelay(pdMS_TO_TICKS(2000))#59;\ntrigger_reboot_event()#59; #125;

                IMPROV_INITIALIZING_STATE

                IMPROV_INITIALIZING_STATE : IMPROV_INITIALIZING_STATE

                IMPROV_INITIALIZING_STATE : enter / #123; startImprovWifi()#59; #125;

                %% Initial state name as "." so that it fits in black circle shape.
                %% See https://github.com/StateSmith/StateSmith/issues/404
                state "." as WIFI_IMPROV_STATE.(InitialState)

                IMPROV_STOPPED_STATE

                IMPROV_STOPPED_STATE : IMPROV_STOPPED_STATE

                IMPROV_STOPPED_STATE : enter / #123; setImprovStopped()#59; #125;

        }

}

REBOOT_STATE

REBOOT_STATE : REBOOT_STATE

REBOOT_STATE : enter / #123; reboot()#59; #125;

ROOT.(InitialState) --> NETWORK_STATE

NETWORK_STATE --> REBOOT_STATE : REBOOT

NETWORK_STATE --> REBOOT_STATE : NET_INIT_FAIL

NETWORK_STATE --> ETH_INITIALIZING_STATE : START [!isWifiPreferred()]

NETWORK_STATE --> WIFI_INITIALIZING_STATE : START [isWifiPreferred()]

NETWORK_ETH_ACTIVE_STATE --> REBOOT_STATE : TIMER

NETWORK_ETH_ACTIVE_STATE --> ETH_ACTIVE_LINKUP_STATE : ETH_LINK_UP

NETWORK_ETH_ACTIVE_STATE --> ETH_ACTIVE_LINKDOWN_STATE : ETH_LINK_DOWN

NETWORK_ETH_ACTIVE_STATE --> ETH_ACTIVE_CONNECTED_STATE : ETH_GOT_IP

NETWORK_ETH_ACTIVE_STATE --> ETH_CONNECTING_NEW_STATE : CONNECT_TO_AP

ETH_INITIALIZING_STATE --> ETH_STARTING_STATE : NET_INIT_SUCCESS

ETH_INITIALIZING_STATE --> WIFI_INITIALIZING_STATE : NET_INIT_FAIL

ETH_ACTIVE_LINKDOWN_STATE --> WIFI_INITIALIZING_STATE : TIMER [hasWifiConfig()]

ETH_CONNECTING_NEW_STATE --> ETH_ACTIVE_CONNECTED_STATE : ETH_FALLBACK

ETH_CONNECTING_NEW_STATE --> WIFI_CONNECTED_STATE : WIFI_GOT_IP

ETH_STARTING_STATE --> WIFI_INITIALIZING_STATE : TIMER

NETWORK_WIFI_ACTIVE_STATE --> ETH_ACTIVE_CONNECTED_STATE : ETH_FALLBACK

NETWORK_WIFI_ACTIVE_STATE --> WIFI_IMPROV_STATE : CONFIGURE_WIFI

NETWORK_WIFI_ACTIVE_STATE --> REBOOT_STATE : ETH_GOT_IP

NETWORK_WIFI_ACTIVE_STATE --> WIFI_CONNECTED_STATE : WIFI_GOT_IP

NETWORK_WIFI_ACTIVE_STATE --> WIFI_CONNECTING_NEW_STATE : CONNECT_TO_AP

NETWORK_WIFI_ACTIVE_STATE --> WIFI_USER_DISCONNECTED_STATE : DELETE_WIFI

WIFI_INITIALIZING_STATE --> WIFI_CONNECTING_STATE : NET_INIT_SUCCESS

WIFI_INITIALIZING_STATE --> WIFI_IMPROV_STATE : CONFIGURE_WIFI

WIFI_CONNECTING_STATE --> NETWORK_WIFI_ACTIVE_STATE.(ChoicePoint)() : TIMER

WIFI_CONNECTING_STATE --> WIFI_W4_IP_STATE : CONNECTED

WIFI_CONNECTING_STATE --> NETWORK_WIFI_ACTIVE_STATE.(ChoicePoint)() : LOST_CONNECTION / #123; statusUpdate(UPDATE_FAILED_ATTEMPT)#59; #125;

WIFI_CONNECTING_NEW_STATE --> WIFI_CONNECTING_NEW_FAILED_STATE : LOST_CONNECTION [!isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)]

WIFI_CONNECTING_NEW_FAILED_STATE --> WIFI_CONNECTED_STATE : WIFI_GOT_IP / #123; statusUpdate(UPDATE_FAILED_ATTEMPT_AND_RESTORE)#59; #125;

WIFI_CONNECTED_STATE --> WIFI_LOST_CONNECTION_STATE : LOST_CONNECTION / #123; statusUpdate(UPDATE_FAILED_ATTEMPT)#59; #125;

WIFI_LOST_CONNECTION_STATE --> WIFI_CONNECTING_STATE : TIMER / #123; LOGI("WiFi polling timeout, retry connection")#59; #125;

NETWORK_WIFI_ACTIVE_STATE.(ChoicePoint)() --> WIFI_LOST_CONNECTION_STATE : [shouldRetryActiveWifiConnection()]

NETWORK_WIFI_ACTIVE_STATE.(ChoicePoint)() --> REBOOT_STATE : else

WIFI_USER_DISCONNECTED_STATE --> WIFI_IMPROV_STATE : LOST_CONNECTION

WIFI_W4_IP_STATE --> NETWORK_WIFI_ACTIVE_STATE.(ChoicePoint)() : TIMER

WIFI_W4_IP_STATE --> WIFI_CONNECTED_STATE : WIFI_GOT_IP

WIFI_IMPROV_STATE --> REBOOT_STATE : ETH_GOT_IP

WIFI_IMPROV_STATE --> IMPROV_STOPPED_STATE : IMPROV_BLE_DISCONNECT

IMPROV_AWAITING_AUTH_STATE --> IMPROV_AUTHORIZED_STATE : BUTTON_PRESS

IMPROV_AUTHORIZED_STATE --> IMPROV_PROVISIONING_STATE : CONNECT_TO_AP

IMPROV_AUTHORIZED_STATE --> IMPROV_AWAITING_AUTH_STATE : IMPROV_AUTHORIZED_TIMEOUT

IMPROV_PROVISIONING_STATE --> IMPROV_PROVISIONED_STATE : WIFI_GOT_IP

IMPROV_PROVISIONING_STATE --> IMPROV_AUTHORIZED_STATE : LOST_CONNECTION / #123; onImprovConnectTimeout()#59; #125;

IMPROV_PROVISIONING_STATE --> IMPROV_AUTHORIZED_STATE : TIMER / #123; onImprovConnectTimeout()#59; #125;

IMPROV_INITIALIZING_STATE --> IMPROV_STOPPED_STATE : NET_INIT_SUCCESS

WIFI_IMPROV_STATE.(InitialState) --> IMPROV_INITIALIZING_STATE

IMPROV_STOPPED_STATE --> IMPROV_AWAITING_AUTH_STATE : IMPROV_BLE_CONNECT



        </pre>
    </div>

    <div class="pane sidebar">
        <div id="buttons">
            <div class="titlebar">Events            
              <div class='dropdown'>
                <span id='dropbtn' class='titlebar-icon dropbtn'>settings</span>
                <div id='myDropdown' class='dropdown-content'>
                  <div class='dropdown-item'>
                    <input type='checkbox' id='timestamps' name='timestamps' value='Timestamps'>
                    <label for='timestamps'>Timestamps</label>
                  </div>
                </div>
              </div>            
          </div>
        </div>

        <div class="history">
          <table class="console">
            <tbody>
            </tbody>
          </table>
        </div>

        <div class="gutter"></div>
    </div>
    </div>

<script>
// Autogenerated with StateSmith 0.17.1+9cb7486c1587230c52d22d8b6faadd8e2219313c.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class NetworkSm
{
// Null by default.
// May be overridden to override guard evaluation (eg. in a simulator)
evaluateGuard = null;
    static EventId = 
    {
        BUTTON_PRESS : 0,
        CONFIGURE_WIFI : 1,
        CONNECT_TO_AP : 2,
        CONNECTED : 3,
        DELETE_WIFI : 4,
        ETH_FALLBACK : 5,
        ETH_GOT_IP : 6,
        ETH_LINK_DOWN : 7,
        ETH_LINK_UP : 8,
        IMPROV_AUTHORIZED_TIMEOUT : 9,
        IMPROV_BLE_CONNECT : 10,
        IMPROV_BLE_DISCONNECT : 11,
        LOST_CONNECTION : 12,
        NET_INIT_FAIL : 13,
        NET_INIT_SUCCESS : 14,
        REBOOT : 15,
        START : 16,
        TIMER : 17,
        WIFI_GOT_IP : 18,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 19;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        NETWORK_STATE : 1,
        NETWORK_ETH_ACTIVE_STATE : 2,
        ETH_ACTIVE_CONNECTED_STATE : 3,
        ETH_ACTIVE_LINKDOWN_STATE : 4,
        ETH_ACTIVE_LINKUP_STATE : 5,
        ETH_CONNECTING_NEW_STATE : 6,
        ETH_INITIALIZING_STATE : 7,
        ETH_STARTING_STATE : 8,
        NETWORK_WIFI_ACTIVE_STATE : 9,
        WIFI_CONNECTED_STATE : 10,
        WIFI_CONNECTING_NEW_FAILED_STATE : 11,
        WIFI_CONNECTING_NEW_STATE : 12,
        WIFI_CONNECTING_STATE : 13,
        WIFI_INITIALIZING_STATE : 14,
        WIFI_LOST_CONNECTION_STATE : 15,
        WIFI_USER_DISCONNECTED_STATE : 16,
        WIFI_W4_IP_STATE : 17,
        WIFI_IMPROV_STATE : 18,
        IMPROV_AUTHORIZED_STATE : 19,
        IMPROV_AWAITING_AUTH_STATE : 20,
        IMPROV_INITIALIZING_STATE : 21,
        IMPROV_PROVISIONED_STATE : 22,
        IMPROV_PROVISIONING_STATE : 23,
        IMPROV_STOPPED_STATE : 24,
        REBOOT_STATE : 25,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 26;
    static { Object.freeze(this.StateIdCount); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition("edge0"); } TransitionTo(NETWORK_STATE)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition("edge0");`.
                this.tracer?.edgeTransition("edge0");
                
                // Step 3: Enter/move towards transition target `NETWORK_STATE`.
                this.#NETWORK_STATE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: NetworkSm
            case NetworkSm.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: NETWORK_STATE
            case NetworkSm.StateId.NETWORK_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break;
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break;
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break;
                }
                break;
            
            // STATE: NETWORK_ETH_ACTIVE_STATE
            case NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break;
                    case NetworkSm.EventId.TIMER: this.#NETWORK_ETH_ACTIVE_STATE_timer(); break;
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break;
                    case NetworkSm.EventId.ETH_LINK_DOWN: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break;
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break;
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ETH_ACTIVE_CONNECTED_STATE
            case NetworkSm.StateId.ETH_ACTIVE_CONNECTED_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.TIMER: this.#NETWORK_ETH_ACTIVE_STATE_timer(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_DOWN: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ETH_ACTIVE_LINKDOWN_STATE
            case NetworkSm.StateId.ETH_ACTIVE_LINKDOWN_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.TIMER: this.#ETH_ACTIVE_LINKDOWN_STATE_timer(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_DOWN: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ETH_ACTIVE_LINKUP_STATE
            case NetworkSm.StateId.ETH_ACTIVE_LINKUP_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.TIMER: this.#NETWORK_ETH_ACTIVE_STATE_timer(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_DOWN: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ETH_CONNECTING_NEW_STATE
            case NetworkSm.StateId.ETH_CONNECTING_NEW_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.LOST_CONNECTION: this.#ETH_CONNECTING_NEW_STATE_lost_connection(); break;
                    case NetworkSm.EventId.ETH_FALLBACK: this.#ETH_CONNECTING_NEW_STATE_eth_fallback(); break;
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#ETH_CONNECTING_NEW_STATE_wifi_got_ip(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.TIMER: this.#NETWORK_ETH_ACTIVE_STATE_timer(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_DOWN: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ETH_INITIALIZING_STATE
            case NetworkSm.StateId.ETH_INITIALIZING_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.NET_INIT_SUCCESS: this.#ETH_INITIALIZING_STATE_net_init_success(); break;
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#ETH_INITIALIZING_STATE_net_init_fail(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.TIMER: this.#NETWORK_ETH_ACTIVE_STATE_timer(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_DOWN: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ETH_STARTING_STATE
            case NetworkSm.StateId.ETH_STARTING_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.TIMER: this.#ETH_STARTING_STATE_timer(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_ETH_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_DOWN: this.#NETWORK_ETH_ACTIVE_STATE_eth_link_down(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_ETH_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_ETH_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: NETWORK_WIFI_ACTIVE_STATE
            case NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break;
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break;
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break;
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break;
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break;
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break;
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_CONNECTED_STATE
            case NetworkSm.StateId.WIFI_CONNECTED_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.LOST_CONNECTION: this.#WIFI_CONNECTED_STATE_lost_connection(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_CONNECTING_NEW_FAILED_STATE
            case NetworkSm.StateId.WIFI_CONNECTING_NEW_FAILED_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.CONNECTED: this.#WIFI_CONNECTING_NEW_FAILED_STATE_connected(); break;
                    case NetworkSm.EventId.LOST_CONNECTION: this.#WIFI_CONNECTING_NEW_FAILED_STATE_lost_connection(); break;
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#WIFI_CONNECTING_NEW_FAILED_STATE_wifi_got_ip(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_CONNECTING_NEW_STATE
            case NetworkSm.StateId.WIFI_CONNECTING_NEW_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.CONNECTED: this.#WIFI_CONNECTING_NEW_STATE_connected(); break;
                    case NetworkSm.EventId.LOST_CONNECTION: this.#WIFI_CONNECTING_NEW_STATE_lost_connection(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_CONNECTING_STATE
            case NetworkSm.StateId.WIFI_CONNECTING_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.TIMER: this.#WIFI_CONNECTING_STATE_timer(); break;
                    case NetworkSm.EventId.CONNECTED: this.#WIFI_CONNECTING_STATE_connected(); break;
                    case NetworkSm.EventId.LOST_CONNECTION: this.#WIFI_CONNECTING_STATE_lost_connection(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_INITIALIZING_STATE
            case NetworkSm.StateId.WIFI_INITIALIZING_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.NET_INIT_SUCCESS: this.#WIFI_INITIALIZING_STATE_net_init_success(); break;
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#WIFI_INITIALIZING_STATE_configure_wifi(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_LOST_CONNECTION_STATE
            case NetworkSm.StateId.WIFI_LOST_CONNECTION_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.TIMER: this.#WIFI_LOST_CONNECTION_STATE_timer(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_USER_DISCONNECTED_STATE
            case NetworkSm.StateId.WIFI_USER_DISCONNECTED_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.LOST_CONNECTION: this.#WIFI_USER_DISCONNECTED_STATE_lost_connection(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_W4_IP_STATE
            case NetworkSm.StateId.WIFI_W4_IP_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.TIMER: this.#WIFI_W4_IP_STATE_timer(); break;
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#WIFI_W4_IP_STATE_wifi_got_ip(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.DELETE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_delete_wifi(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_LINK_UP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_link_up(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#NETWORK_WIFI_ACTIVE_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#NETWORK_WIFI_ACTIVE_STATE_connect_to_ap(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_FALLBACK: this.#NETWORK_WIFI_ACTIVE_STATE_eth_fallback(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.CONFIGURE_WIFI: this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: WIFI_IMPROV_STATE
            case NetworkSm.StateId.WIFI_IMPROV_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.ETH_GOT_IP: this.#WIFI_IMPROV_STATE_eth_got_ip(); break;
                    case NetworkSm.EventId.IMPROV_BLE_DISCONNECT: this.#WIFI_IMPROV_STATE_improv_ble_disconnect(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_AUTHORIZED_STATE
            case NetworkSm.StateId.IMPROV_AUTHORIZED_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.CONNECT_TO_AP: this.#IMPROV_AUTHORIZED_STATE_connect_to_ap(); break;
                    case NetworkSm.EventId.IMPROV_AUTHORIZED_TIMEOUT: this.#IMPROV_AUTHORIZED_STATE_improv_authorized_timeout(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.IMPROV_BLE_DISCONNECT: this.#WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_AWAITING_AUTH_STATE
            case NetworkSm.StateId.IMPROV_AWAITING_AUTH_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.BUTTON_PRESS: this.#IMPROV_AWAITING_AUTH_STATE_button_press(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.IMPROV_BLE_DISCONNECT: this.#WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_INITIALIZING_STATE
            case NetworkSm.StateId.IMPROV_INITIALIZING_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.NET_INIT_SUCCESS: this.#IMPROV_INITIALIZING_STATE_net_init_success(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.IMPROV_BLE_DISCONNECT: this.#WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_PROVISIONED_STATE
            case NetworkSm.StateId.IMPROV_PROVISIONED_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.IMPROV_BLE_DISCONNECT: this.#WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_PROVISIONING_STATE
            case NetworkSm.StateId.IMPROV_PROVISIONING_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.CONNECTED: this.#IMPROV_PROVISIONING_STATE_connected(); break;
                    case NetworkSm.EventId.WIFI_GOT_IP: this.#IMPROV_PROVISIONING_STATE_wifi_got_ip(); break;
                    case NetworkSm.EventId.LOST_CONNECTION: this.#IMPROV_PROVISIONING_STATE_lost_connection(); break;
                    case NetworkSm.EventId.TIMER: this.#IMPROV_PROVISIONING_STATE_timer(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.IMPROV_BLE_DISCONNECT: this.#WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: IMPROV_STOPPED_STATE
            case NetworkSm.StateId.IMPROV_STOPPED_STATE:
                switch (eventId)
                {
                    case NetworkSm.EventId.IMPROV_BLE_CONNECT: this.#IMPROV_STOPPED_STATE_improv_ble_connect(); break;
                    case NetworkSm.EventId.REBOOT: this.#NETWORK_STATE_reboot(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.NET_INIT_FAIL: this.#NETWORK_STATE_net_init_fail(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.START: this.#NETWORK_STATE_start(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.ETH_GOT_IP: this.#WIFI_IMPROV_STATE_eth_got_ip(); break; // First ancestor handler for this event
                    case NetworkSm.EventId.IMPROV_BLE_DISCONNECT: this.#WIFI_IMPROV_STATE_improv_ble_disconnect(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: REBOOT_STATE
            case NetworkSm.StateId.REBOOT_STATE:
                // No events handled by this state (or its ancestors).
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case NetworkSm.StateId.NETWORK_STATE: this.#NETWORK_STATE_exit(); break;
                
                case NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE: this.#NETWORK_ETH_ACTIVE_STATE_exit(); break;
                
                case NetworkSm.StateId.ETH_ACTIVE_CONNECTED_STATE: this.#ETH_ACTIVE_CONNECTED_STATE_exit(); break;
                
                case NetworkSm.StateId.ETH_ACTIVE_LINKDOWN_STATE: this.#ETH_ACTIVE_LINKDOWN_STATE_exit(); break;
                
                case NetworkSm.StateId.ETH_ACTIVE_LINKUP_STATE: this.#ETH_ACTIVE_LINKUP_STATE_exit(); break;
                
                case NetworkSm.StateId.ETH_CONNECTING_NEW_STATE: this.#ETH_CONNECTING_NEW_STATE_exit(); break;
                
                case NetworkSm.StateId.ETH_INITIALIZING_STATE: this.#ETH_INITIALIZING_STATE_exit(); break;
                
                case NetworkSm.StateId.ETH_STARTING_STATE: this.#ETH_STARTING_STATE_exit(); break;
                
                case NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE: this.#NETWORK_WIFI_ACTIVE_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_CONNECTED_STATE: this.#WIFI_CONNECTED_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_CONNECTING_NEW_FAILED_STATE: this.#WIFI_CONNECTING_NEW_FAILED_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_CONNECTING_NEW_STATE: this.#WIFI_CONNECTING_NEW_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_CONNECTING_STATE: this.#WIFI_CONNECTING_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_INITIALIZING_STATE: this.#WIFI_INITIALIZING_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_LOST_CONNECTION_STATE: this.#WIFI_LOST_CONNECTION_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_USER_DISCONNECTED_STATE: this.#WIFI_USER_DISCONNECTED_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_W4_IP_STATE: this.#WIFI_W4_IP_STATE_exit(); break;
                
                case NetworkSm.StateId.WIFI_IMPROV_STATE: this.#WIFI_IMPROV_STATE_exit(); break;
                
                case NetworkSm.StateId.IMPROV_AUTHORIZED_STATE: this.#IMPROV_AUTHORIZED_STATE_exit(); break;
                
                case NetworkSm.StateId.IMPROV_AWAITING_AUTH_STATE: this.#IMPROV_AWAITING_AUTH_STATE_exit(); break;
                
                case NetworkSm.StateId.IMPROV_INITIALIZING_STATE: this.#IMPROV_INITIALIZING_STATE_exit(); break;
                
                case NetworkSm.StateId.IMPROV_PROVISIONED_STATE: this.#IMPROV_PROVISIONED_STATE_exit(); break;
                
                case NetworkSm.StateId.IMPROV_PROVISIONING_STATE: this.#IMPROV_PROVISIONING_STATE_exit(); break;
                
                case NetworkSm.StateId.IMPROV_STOPPED_STATE: this.#IMPROV_STOPPED_STATE_exit(); break;
                
                case NetworkSm.StateId.REBOOT_STATE: this.#REBOOT_STATE_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        this.stateId = NetworkSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state NETWORK_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #NETWORK_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.NETWORK_STATE;
        
        // NETWORK_STATE behavior
        // uml: enter / { this.tracer?.enterState('NETWORK_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('NETWORK_STATE');`
            this.tracer?.enterState('NETWORK_STATE');
        } // end of behavior for NETWORK_STATE
        
        // NETWORK_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "initNetwork();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "initNetwork();");`
            this.tracer?.log(" FSM would execute action: " + "initNetwork();");
        } // end of behavior for NETWORK_STATE
    }
    
    #NETWORK_STATE_exit()
    {
        // NETWORK_STATE behavior
        // uml: exit / { this.tracer?.exitState('NETWORK_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('NETWORK_STATE');`
            this.tracer?.exitState('NETWORK_STATE');
        } // end of behavior for NETWORK_STATE
        
        this.stateId = NetworkSm.StateId.ROOT;
    }
    
    #NETWORK_STATE_net_init_fail()
    {
        // NETWORK_STATE behavior
        // uml: NET_INIT_FAIL / { this.tracer?.edgeTransition("edge2"); } TransitionTo(REBOOT_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge2");`.
            this.tracer?.edgeTransition("edge2");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_STATE_reboot()
    {
        // NETWORK_STATE behavior
        // uml: REBOOT / { this.tracer?.edgeTransition("edge1"); } TransitionTo(REBOOT_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge1");`.
            this.tracer?.edgeTransition("edge1");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_STATE_start()
    {
        // NETWORK_STATE behavior
        // uml: START [this.tracer?.log(" User evaluating guard: " + "!isWifiPreferred()") || this.evaluateGuard("NETWORK_STATE","START [!isWifiPreferred()] TransitionTo(ETH_INITIALIZING_STATE)")] / { this.tracer?.edgeTransition("edge3"); } TransitionTo(ETH_INITIALIZING_STATE)
        if (this.tracer?.log(" User evaluating guard: " + "!isWifiPreferred()") || this.evaluateGuard("NETWORK_STATE","START [!isWifiPreferred()] TransitionTo(ETH_INITIALIZING_STATE)"))
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge3");`.
            this.tracer?.edgeTransition("edge3");
            
            // Step 3: Enter/move towards transition target `ETH_INITIALIZING_STATE`.
            this.#NETWORK_ETH_ACTIVE_STATE_enter();
            this.#ETH_INITIALIZING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_STATE
        
        // NETWORK_STATE behavior
        // uml: START [this.tracer?.log(" User evaluating guard: " + "isWifiPreferred()") || this.evaluateGuard("NETWORK_STATE","START [isWifiPreferred()] TransitionTo(WIFI_INITIALIZING_STATE)")] / { this.tracer?.edgeTransition("edge4"); } TransitionTo(WIFI_INITIALIZING_STATE)
        if (this.tracer?.log(" User evaluating guard: " + "isWifiPreferred()") || this.evaluateGuard("NETWORK_STATE","START [isWifiPreferred()] TransitionTo(WIFI_INITIALIZING_STATE)"))
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge4");`.
            this.tracer?.edgeTransition("edge4");
            
            // Step 3: Enter/move towards transition target `WIFI_INITIALIZING_STATE`.
            this.#NETWORK_WIFI_ACTIVE_STATE_enter();
            this.#WIFI_INITIALIZING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state NETWORK_ETH_ACTIVE_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #NETWORK_ETH_ACTIVE_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE;
        
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: enter / { this.tracer?.enterState('NETWORK_ETH_ACTIVE_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('NETWORK_ETH_ACTIVE_STATE');`
            this.tracer?.enterState('NETWORK_ETH_ACTIVE_STATE');
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_ETH_CONNECTING);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_ETH_CONNECTING);");`
            this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_ETH_CONNECTING);");
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
    }
    
    #NETWORK_ETH_ACTIVE_STATE_exit()
    {
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();");
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: exit / { this.tracer?.exitState('NETWORK_ETH_ACTIVE_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('NETWORK_ETH_ACTIVE_STATE');`
            this.tracer?.exitState('NETWORK_ETH_ACTIVE_STATE');
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_STATE;
    }
    
    #NETWORK_ETH_ACTIVE_STATE_connect_to_ap()
    {
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: CONNECT_TO_AP / { this.tracer?.edgeTransition("edge9"); } TransitionTo(ETH_CONNECTING_NEW_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge9");`.
            this.tracer?.edgeTransition("edge9");
            
            // Step 3: Enter/move towards transition target `ETH_CONNECTING_NEW_STATE`.
            this.#ETH_CONNECTING_NEW_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_ETH_ACTIVE_STATE_delete_wifi()
    {
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: DELETE_WIFI / { this.tracer?.log(" FSM would execute action: " + "clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT);");`
            this.tracer?.log(" FSM would execute action: " + "clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT);");
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_ETH_ACTIVE_STATE_eth_got_ip()
    {
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: ETH_GOT_IP / { this.tracer?.edgeTransition("edge8"); } TransitionTo(ETH_ACTIVE_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge8");`.
            this.tracer?.edgeTransition("edge8");
            
            // Step 3: Enter/move towards transition target `ETH_ACTIVE_CONNECTED_STATE`.
            this.#ETH_ACTIVE_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_ETH_ACTIVE_STATE_eth_link_down()
    {
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: ETH_LINK_DOWN / { this.tracer?.edgeTransition("edge7"); } TransitionTo(ETH_ACTIVE_LINKDOWN_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge7");`.
            this.tracer?.edgeTransition("edge7");
            
            // Step 3: Enter/move towards transition target `ETH_ACTIVE_LINKDOWN_STATE`.
            this.#ETH_ACTIVE_LINKDOWN_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_ETH_ACTIVE_STATE_eth_link_up()
    {
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: ETH_LINK_UP / { this.tracer?.edgeTransition("edge6"); } TransitionTo(ETH_ACTIVE_LINKUP_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge6");`.
            this.tracer?.edgeTransition("edge6");
            
            // Step 3: Enter/move towards transition target `ETH_ACTIVE_LINKUP_STATE`.
            this.#ETH_ACTIVE_LINKUP_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_ETH_ACTIVE_STATE_timer()
    {
        // NETWORK_ETH_ACTIVE_STATE behavior
        // uml: TIMER / { this.tracer?.edgeTransition("edge5"); } TransitionTo(REBOOT_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge5");`.
            this.tracer?.edgeTransition("edge5");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_ETH_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ETH_ACTIVE_CONNECTED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #ETH_ACTIVE_CONNECTED_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.ETH_ACTIVE_CONNECTED_STATE;
        
        // ETH_ACTIVE_CONNECTED_STATE behavior
        // uml: enter / { this.tracer?.enterState('ETH_ACTIVE_CONNECTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ETH_ACTIVE_CONNECTED_STATE');`
            this.tracer?.enterState('ETH_ACTIVE_CONNECTED_STATE');
        } // end of behavior for ETH_ACTIVE_CONNECTED_STATE
        
        // ETH_ACTIVE_CONNECTED_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "stopTimer();\nstatusUpdate(UPDATE_ETH_CONNECTED);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();\nstatusUpdate(UPDATE_ETH_CONNECTED);");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();\nstatusUpdate(UPDATE_ETH_CONNECTED);");
        } // end of behavior for ETH_ACTIVE_CONNECTED_STATE
    }
    
    #ETH_ACTIVE_CONNECTED_STATE_exit()
    {
        // ETH_ACTIVE_CONNECTED_STATE behavior
        // uml: exit / { this.tracer?.exitState('ETH_ACTIVE_CONNECTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ETH_ACTIVE_CONNECTED_STATE');`
            this.tracer?.exitState('ETH_ACTIVE_CONNECTED_STATE');
        } // end of behavior for ETH_ACTIVE_CONNECTED_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ETH_ACTIVE_LINKDOWN_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #ETH_ACTIVE_LINKDOWN_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.ETH_ACTIVE_LINKDOWN_STATE;
        
        // ETH_ACTIVE_LINKDOWN_STATE behavior
        // uml: enter / { this.tracer?.enterState('ETH_ACTIVE_LINKDOWN_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ETH_ACTIVE_LINKDOWN_STATE');`
            this.tracer?.enterState('ETH_ACTIVE_LINKDOWN_STATE');
        } // end of behavior for ETH_ACTIVE_LINKDOWN_STATE
        
        // ETH_ACTIVE_LINKDOWN_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "startEthLinkDownTimer();\nstatusUpdate(UPDATE_ETH_LINK_DOWN);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "startEthLinkDownTimer();\nstatusUpdate(UPDATE_ETH_LINK_DOWN);");`
            this.tracer?.log(" FSM would execute action: " + "startEthLinkDownTimer();\nstatusUpdate(UPDATE_ETH_LINK_DOWN);");
        } // end of behavior for ETH_ACTIVE_LINKDOWN_STATE
    }
    
    #ETH_ACTIVE_LINKDOWN_STATE_exit()
    {
        // ETH_ACTIVE_LINKDOWN_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();");
        } // end of behavior for ETH_ACTIVE_LINKDOWN_STATE
        
        // ETH_ACTIVE_LINKDOWN_STATE behavior
        // uml: exit / { this.tracer?.exitState('ETH_ACTIVE_LINKDOWN_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ETH_ACTIVE_LINKDOWN_STATE');`
            this.tracer?.exitState('ETH_ACTIVE_LINKDOWN_STATE');
        } // end of behavior for ETH_ACTIVE_LINKDOWN_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE;
    }
    
    #ETH_ACTIVE_LINKDOWN_STATE_timer()
    {
        let consume_event = false;
        
        // ETH_ACTIVE_LINKDOWN_STATE behavior
        // uml: TIMER [this.tracer?.log(" User evaluating guard: " + "hasWifiConfig()") || this.evaluateGuard("ETH_ACTIVE_LINKDOWN_STATE","TIMER [hasWifiConfig()] TransitionTo(WIFI_INITIALIZING_STATE)")] / { this.tracer?.edgeTransition("edge12"); } TransitionTo(WIFI_INITIALIZING_STATE)
        if (this.tracer?.log(" User evaluating guard: " + "hasWifiConfig()") || this.evaluateGuard("ETH_ACTIVE_LINKDOWN_STATE","TIMER [hasWifiConfig()] TransitionTo(WIFI_INITIALIZING_STATE)"))
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge12");`.
            this.tracer?.edgeTransition("edge12");
            
            // Step 3: Enter/move towards transition target `WIFI_INITIALIZING_STATE`.
            this.#NETWORK_WIFI_ACTIVE_STATE_enter();
            this.#WIFI_INITIALIZING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ETH_ACTIVE_LINKDOWN_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#NETWORK_ETH_ACTIVE_STATE_timer();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ETH_ACTIVE_LINKUP_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #ETH_ACTIVE_LINKUP_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.ETH_ACTIVE_LINKUP_STATE;
        
        // ETH_ACTIVE_LINKUP_STATE behavior
        // uml: enter / { this.tracer?.enterState('ETH_ACTIVE_LINKUP_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ETH_ACTIVE_LINKUP_STATE');`
            this.tracer?.enterState('ETH_ACTIVE_LINKUP_STATE');
        } // end of behavior for ETH_ACTIVE_LINKUP_STATE
        
        // ETH_ACTIVE_LINKUP_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "startDhcpTimer();\nstatusUpdate(UPDATE_ETH_LINK_UP);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "startDhcpTimer();\nstatusUpdate(UPDATE_ETH_LINK_UP);");`
            this.tracer?.log(" FSM would execute action: " + "startDhcpTimer();\nstatusUpdate(UPDATE_ETH_LINK_UP);");
        } // end of behavior for ETH_ACTIVE_LINKUP_STATE
    }
    
    #ETH_ACTIVE_LINKUP_STATE_exit()
    {
        // ETH_ACTIVE_LINKUP_STATE behavior
        // uml: exit / { this.tracer?.exitState('ETH_ACTIVE_LINKUP_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ETH_ACTIVE_LINKUP_STATE');`
            this.tracer?.exitState('ETH_ACTIVE_LINKUP_STATE');
        } // end of behavior for ETH_ACTIVE_LINKUP_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ETH_CONNECTING_NEW_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #ETH_CONNECTING_NEW_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.ETH_CONNECTING_NEW_STATE;
        
        // ETH_CONNECTING_NEW_STATE behavior
        // uml: enter / { this.tracer?.enterState('ETH_CONNECTING_NEW_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ETH_CONNECTING_NEW_STATE');`
            this.tracer?.enterState('ETH_CONNECTING_NEW_STATE');
        } // end of behavior for ETH_CONNECTING_NEW_STATE
        
        // ETH_CONNECTING_NEW_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "startWifiDhcpClient();\nconnectWifi();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "startWifiDhcpClient();\nconnectWifi();");`
            this.tracer?.log(" FSM would execute action: " + "startWifiDhcpClient();\nconnectWifi();");
        } // end of behavior for ETH_CONNECTING_NEW_STATE
    }
    
    #ETH_CONNECTING_NEW_STATE_exit()
    {
        // ETH_CONNECTING_NEW_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();");
        } // end of behavior for ETH_CONNECTING_NEW_STATE
        
        // ETH_CONNECTING_NEW_STATE behavior
        // uml: exit / { this.tracer?.exitState('ETH_CONNECTING_NEW_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ETH_CONNECTING_NEW_STATE');`
            this.tracer?.exitState('ETH_CONNECTING_NEW_STATE');
        } // end of behavior for ETH_CONNECTING_NEW_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE;
    }
    
    #ETH_CONNECTING_NEW_STATE_eth_fallback()
    {
        // ETH_CONNECTING_NEW_STATE behavior
        // uml: ETH_FALLBACK / { this.tracer?.edgeTransition("edge13"); } TransitionTo(ETH_ACTIVE_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#ETH_CONNECTING_NEW_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge13");`.
            this.tracer?.edgeTransition("edge13");
            
            // Step 3: Enter/move towards transition target `ETH_ACTIVE_CONNECTED_STATE`.
            this.#ETH_ACTIVE_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ETH_CONNECTING_NEW_STATE
        
        // No ancestor handles this event.
    }
    
    #ETH_CONNECTING_NEW_STATE_lost_connection()
    {
        // ETH_CONNECTING_NEW_STATE behavior
        // uml: LOST_CONNECTION / { this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);\ntrigger_eth_fallback_event();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);\ntrigger_eth_fallback_event();");`
            this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);\ntrigger_eth_fallback_event();");
        } // end of behavior for ETH_CONNECTING_NEW_STATE
        
        // No ancestor handles this event.
    }
    
    #ETH_CONNECTING_NEW_STATE_wifi_got_ip()
    {
        // ETH_CONNECTING_NEW_STATE behavior
        // uml: WIFI_GOT_IP / { this.tracer?.edgeTransition("edge14"); } TransitionTo(WIFI_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge14");`.
            this.tracer?.edgeTransition("edge14");
            
            // Step 3: Enter/move towards transition target `WIFI_CONNECTED_STATE`.
            this.#NETWORK_WIFI_ACTIVE_STATE_enter();
            this.#WIFI_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ETH_CONNECTING_NEW_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ETH_INITIALIZING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #ETH_INITIALIZING_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.ETH_INITIALIZING_STATE;
        
        // ETH_INITIALIZING_STATE behavior
        // uml: enter / { this.tracer?.enterState('ETH_INITIALIZING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ETH_INITIALIZING_STATE');`
            this.tracer?.enterState('ETH_INITIALIZING_STATE');
        } // end of behavior for ETH_INITIALIZING_STATE
        
        // ETH_INITIALIZING_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "initEthernet();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "initEthernet();");`
            this.tracer?.log(" FSM would execute action: " + "initEthernet();");
        } // end of behavior for ETH_INITIALIZING_STATE
    }
    
    #ETH_INITIALIZING_STATE_exit()
    {
        // ETH_INITIALIZING_STATE behavior
        // uml: exit / { this.tracer?.exitState('ETH_INITIALIZING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ETH_INITIALIZING_STATE');`
            this.tracer?.exitState('ETH_INITIALIZING_STATE');
        } // end of behavior for ETH_INITIALIZING_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE;
    }
    
    #ETH_INITIALIZING_STATE_net_init_fail()
    {
        let consume_event = false;
        
        // ETH_INITIALIZING_STATE behavior
        // uml: NET_INIT_FAIL / { this.tracer?.edgeTransition("edge11"); } TransitionTo(WIFI_INITIALIZING_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge11");`.
            this.tracer?.edgeTransition("edge11");
            
            // Step 3: Enter/move towards transition target `WIFI_INITIALIZING_STATE`.
            this.#NETWORK_WIFI_ACTIVE_STATE_enter();
            this.#WIFI_INITIALIZING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ETH_INITIALIZING_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#NETWORK_STATE_net_init_fail();
        }
    }
    
    #ETH_INITIALIZING_STATE_net_init_success()
    {
        // ETH_INITIALIZING_STATE behavior
        // uml: NET_INIT_SUCCESS / { this.tracer?.edgeTransition("edge10"); } TransitionTo(ETH_STARTING_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_ETH_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#ETH_INITIALIZING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge10");`.
            this.tracer?.edgeTransition("edge10");
            
            // Step 3: Enter/move towards transition target `ETH_STARTING_STATE`.
            this.#ETH_STARTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ETH_INITIALIZING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ETH_STARTING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #ETH_STARTING_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.ETH_STARTING_STATE;
        
        // ETH_STARTING_STATE behavior
        // uml: enter / { this.tracer?.enterState('ETH_STARTING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ETH_STARTING_STATE');`
            this.tracer?.enterState('ETH_STARTING_STATE');
        } // end of behavior for ETH_STARTING_STATE
        
        // ETH_STARTING_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "startEthLinkTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "startEthLinkTimer();");`
            this.tracer?.log(" FSM would execute action: " + "startEthLinkTimer();");
        } // end of behavior for ETH_STARTING_STATE
    }
    
    #ETH_STARTING_STATE_exit()
    {
        // ETH_STARTING_STATE behavior
        // uml: exit / { this.tracer?.exitState('ETH_STARTING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ETH_STARTING_STATE');`
            this.tracer?.exitState('ETH_STARTING_STATE');
        } // end of behavior for ETH_STARTING_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE;
    }
    
    #ETH_STARTING_STATE_timer()
    {
        let consume_event = false;
        
        // ETH_STARTING_STATE behavior
        // uml: TIMER / { this.tracer?.edgeTransition("edge15"); } TransitionTo(WIFI_INITIALIZING_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge15");`.
            this.tracer?.edgeTransition("edge15");
            
            // Step 3: Enter/move towards transition target `WIFI_INITIALIZING_STATE`.
            this.#NETWORK_WIFI_ACTIVE_STATE_enter();
            this.#WIFI_INITIALIZING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ETH_STARTING_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#NETWORK_ETH_ACTIVE_STATE_timer();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state NETWORK_WIFI_ACTIVE_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #NETWORK_WIFI_ACTIVE_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
        
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: enter / { this.tracer?.enterState('NETWORK_WIFI_ACTIVE_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('NETWORK_WIFI_ACTIVE_STATE');`
            this.tracer?.enterState('NETWORK_WIFI_ACTIVE_STATE');
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_exit()
    {
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();");
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: exit / { this.tracer?.exitState('NETWORK_WIFI_ACTIVE_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('NETWORK_WIFI_ACTIVE_STATE');`
            this.tracer?.exitState('NETWORK_WIFI_ACTIVE_STATE');
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_STATE;
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_configure_wifi()
    {
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: CONFIGURE_WIFI / { this.tracer?.edgeTransition("edge17"); } TransitionTo(WIFI_IMPROV_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge17");`.
            this.tracer?.edgeTransition("edge17");
            
            // Step 3: Enter/move towards transition target `WIFI_IMPROV_STATE`.
            this.#WIFI_IMPROV_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#WIFI_IMPROV_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_connect_to_ap()
    {
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: CONNECT_TO_AP / { this.tracer?.edgeTransition("edge20"); } TransitionTo(WIFI_CONNECTING_NEW_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge20");`.
            this.tracer?.edgeTransition("edge20");
            
            // Step 3: Enter/move towards transition target `WIFI_CONNECTING_NEW_STATE`.
            this.#WIFI_CONNECTING_NEW_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_delete_wifi()
    {
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: DELETE_WIFI / { this.tracer?.edgeTransition("edge21"); } TransitionTo(WIFI_USER_DISCONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge21");`.
            this.tracer?.edgeTransition("edge21");
            
            // Step 3: Enter/move towards transition target `WIFI_USER_DISCONNECTED_STATE`.
            this.#WIFI_USER_DISCONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_eth_fallback()
    {
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: ETH_FALLBACK / { this.tracer?.edgeTransition("edge16"); } TransitionTo(ETH_ACTIVE_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge16");`.
            this.tracer?.edgeTransition("edge16");
            
            // Step 3: Enter/move towards transition target `ETH_ACTIVE_CONNECTED_STATE`.
            this.#NETWORK_ETH_ACTIVE_STATE_enter();
            this.#ETH_ACTIVE_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_eth_got_ip()
    {
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: ETH_GOT_IP / { this.tracer?.edgeTransition("edge18"); } TransitionTo(REBOOT_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge18");`.
            this.tracer?.edgeTransition("edge18");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_eth_link_up()
    {
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: ETH_LINK_UP / { this.tracer?.log(" FSM would execute action: " + "LOGD(\"ETH link up in WiFi mode\");"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "LOGD(\"ETH link up in WiFi mode\");");`
            this.tracer?.log(" FSM would execute action: " + "LOGD(\"ETH link up in WiFi mode\");");
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip()
    {
        // NETWORK_WIFI_ACTIVE_STATE behavior
        // uml: WIFI_GOT_IP / { this.tracer?.edgeTransition("edge19"); } TransitionTo(WIFI_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge19");`.
            this.tracer?.edgeTransition("edge19");
            
            // Step 3: Enter/move towards transition target `WIFI_CONNECTED_STATE`.
            this.#WIFI_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE
        
        // No ancestor handles this event.
    }
    
    #NETWORK_WIFI_ACTIVE_STATE_ChoicePoint__transition()
    {
        // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() behavior
        // uml: [this.tracer?.log(" User evaluating guard: " + "shouldRetryActiveWifiConnection()") || this.evaluateGuard("NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()","[shouldRetryActiveWifiConnection()] TransitionTo(WIFI_LOST_CONNECTION_STATE)")] / { this.tracer?.edgeTransition("edge31"); } TransitionTo(WIFI_LOST_CONNECTION_STATE)
        if (this.tracer?.log(" User evaluating guard: " + "shouldRetryActiveWifiConnection()") || this.evaluateGuard("NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()","[shouldRetryActiveWifiConnection()] TransitionTo(WIFI_LOST_CONNECTION_STATE)"))
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge31");`.
            this.tracer?.edgeTransition("edge31");
            
            // Step 3: Enter/move towards transition target `WIFI_LOST_CONNECTION_STATE`.
            this.#WIFI_LOST_CONNECTION_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()
        
        // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() behavior
        // uml: else / { this.tracer?.edgeTransition("edge32"); } TransitionTo(REBOOT_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge32");`.
            this.tracer?.edgeTransition("edge32");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_CONNECTED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_CONNECTED_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_CONNECTED_STATE;
        
        // WIFI_CONNECTED_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_CONNECTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_CONNECTED_STATE');`
            this.tracer?.enterState('WIFI_CONNECTED_STATE');
        } // end of behavior for WIFI_CONNECTED_STATE
        
        // WIFI_CONNECTED_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "stopTimer();\nsaveActiveWifiConfig();\nstatusUpdate(UPDATE_WIFI_CONNECTED);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();\nsaveActiveWifiConfig();\nstatusUpdate(UPDATE_WIFI_CONNECTED);");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();\nsaveActiveWifiConfig();\nstatusUpdate(UPDATE_WIFI_CONNECTED);");
        } // end of behavior for WIFI_CONNECTED_STATE
    }
    
    #WIFI_CONNECTED_STATE_exit()
    {
        // WIFI_CONNECTED_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "clearEventParameters();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "clearEventParameters();");`
            this.tracer?.log(" FSM would execute action: " + "clearEventParameters();");
        } // end of behavior for WIFI_CONNECTED_STATE
        
        // WIFI_CONNECTED_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_CONNECTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_CONNECTED_STATE');`
            this.tracer?.exitState('WIFI_CONNECTED_STATE');
        } // end of behavior for WIFI_CONNECTED_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
    }
    
    #WIFI_CONNECTED_STATE_lost_connection()
    {
        // WIFI_CONNECTED_STATE behavior
        // uml: LOST_CONNECTION / { this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);");this.tracer?.edgeTransition("edge29"); } TransitionTo(WIFI_LOST_CONNECTION_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_CONNECTED_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);");this.tracer?.edgeTransition("edge29");`.
            this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);");this.tracer?.edgeTransition("edge29");
            
            // Step 3: Enter/move towards transition target `WIFI_LOST_CONNECTION_STATE`.
            this.#WIFI_LOST_CONNECTION_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_CONNECTED_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_CONNECTING_NEW_FAILED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_CONNECTING_NEW_FAILED_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_CONNECTING_NEW_FAILED_STATE;
        
        // WIFI_CONNECTING_NEW_FAILED_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_CONNECTING_NEW_FAILED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_CONNECTING_NEW_FAILED_STATE');`
            this.tracer?.enterState('WIFI_CONNECTING_NEW_FAILED_STATE');
        } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
        
        // WIFI_CONNECTING_NEW_FAILED_STATE behavior
        // uml: enter [this.tracer?.log(" User evaluating guard: " + "isWifiConnected()") || this.evaluateGuard("WIFI_CONNECTING_NEW_FAILED_STATE","enter [isWifiConnected()] / { connectActiveSsid(); }")] / { this.tracer?.log(" FSM would execute action: " + "connectActiveSsid();"); }
        if (this.tracer?.log(" User evaluating guard: " + "isWifiConnected()") || this.evaluateGuard("WIFI_CONNECTING_NEW_FAILED_STATE","enter [isWifiConnected()] / { connectActiveSsid(); }"))
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "connectActiveSsid();");`
            this.tracer?.log(" FSM would execute action: " + "connectActiveSsid();");
        } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
    }
    
    #WIFI_CONNECTING_NEW_FAILED_STATE_exit()
    {
        // WIFI_CONNECTING_NEW_FAILED_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();  clearEventParameters();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();  clearEventParameters();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();  clearEventParameters();");
        } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
        
        // WIFI_CONNECTING_NEW_FAILED_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_CONNECTING_NEW_FAILED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_CONNECTING_NEW_FAILED_STATE');`
            this.tracer?.exitState('WIFI_CONNECTING_NEW_FAILED_STATE');
        } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
    }
    
    #WIFI_CONNECTING_NEW_FAILED_STATE_connected()
    {
        // WIFI_CONNECTING_NEW_FAILED_STATE behavior
        // uml: CONNECTED / { this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the previous access point. Waiting for IP Address\");"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the previous access point. Waiting for IP Address\");");`
            this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the previous access point. Waiting for IP Address\");");
        } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
        
        // No ancestor handles this event.
    }
    
    #WIFI_CONNECTING_NEW_FAILED_STATE_lost_connection()
    {
        // WIFI_CONNECTING_NEW_FAILED_STATE behavior
        // uml: LOST_CONNECTION / { this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);");`
            this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);");
        } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
        
        // No ancestor handles this event.
    }
    
    #WIFI_CONNECTING_NEW_FAILED_STATE_wifi_got_ip()
    {
        let consume_event = false;
        
        // WIFI_CONNECTING_NEW_FAILED_STATE behavior
        // uml: WIFI_GOT_IP / { this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT_AND_RESTORE);");this.tracer?.edgeTransition("edge28"); } TransitionTo(WIFI_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_CONNECTING_NEW_FAILED_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT_AND_RESTORE);");this.tracer?.edgeTransition("edge28");`.
            this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT_AND_RESTORE);");this.tracer?.edgeTransition("edge28");
            
            // Step 3: Enter/move towards transition target `WIFI_CONNECTED_STATE`.
            this.#WIFI_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_CONNECTING_NEW_FAILED_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_CONNECTING_NEW_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_CONNECTING_NEW_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_CONNECTING_NEW_STATE;
        
        // WIFI_CONNECTING_NEW_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_CONNECTING_NEW_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_CONNECTING_NEW_STATE');`
            this.tracer?.enterState('WIFI_CONNECTING_NEW_STATE');
        } // end of behavior for WIFI_CONNECTING_NEW_STATE
        
        // WIFI_CONNECTING_NEW_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "startWifiDhcpClient();\nconnectWifi();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "startWifiDhcpClient();\nconnectWifi();");`
            this.tracer?.log(" FSM would execute action: " + "startWifiDhcpClient();\nconnectWifi();");
        } // end of behavior for WIFI_CONNECTING_NEW_STATE
    }
    
    #WIFI_CONNECTING_NEW_STATE_exit()
    {
        // WIFI_CONNECTING_NEW_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();\nclearEventParameters();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();\nclearEventParameters();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();\nclearEventParameters();");
        } // end of behavior for WIFI_CONNECTING_NEW_STATE
        
        // WIFI_CONNECTING_NEW_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_CONNECTING_NEW_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_CONNECTING_NEW_STATE');`
            this.tracer?.exitState('WIFI_CONNECTING_NEW_STATE');
        } // end of behavior for WIFI_CONNECTING_NEW_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
    }
    
    #WIFI_CONNECTING_NEW_STATE_connected()
    {
        // WIFI_CONNECTING_NEW_STATE behavior
        // uml: CONNECTED / { this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the new access point. Waiting for IP Address\");"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the new access point. Waiting for IP Address\");");`
            this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the new access point. Waiting for IP Address\");");
        } // end of behavior for WIFI_CONNECTING_NEW_STATE
        
        // No ancestor handles this event.
    }
    
    #WIFI_CONNECTING_NEW_STATE_lost_connection()
    {
        // WIFI_CONNECTING_NEW_STATE behavior
        // uml: LOST_CONNECTION [this.tracer?.log(" User evaluating guard: " + "isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)") || this.evaluateGuard("WIFI_CONNECTING_NEW_STATE","LOST_CONNECTION [isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)] / { LOGI(\"Successfully disconnected from the existing access point. \"); }")] / { this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully disconnected from the existing access point. \");"); }
        if (this.tracer?.log(" User evaluating guard: " + "isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)") || this.evaluateGuard("WIFI_CONNECTING_NEW_STATE","LOST_CONNECTION [isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)] / { LOGI(\"Successfully disconnected from the existing access point. \"); }"))
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully disconnected from the existing access point. \");");`
            this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully disconnected from the existing access point. \");");
        } // end of behavior for WIFI_CONNECTING_NEW_STATE
        
        // WIFI_CONNECTING_NEW_STATE behavior
        // uml: LOST_CONNECTION [this.tracer?.log(" User evaluating guard: " + "!isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)") || this.evaluateGuard("WIFI_CONNECTING_NEW_STATE","LOST_CONNECTION [!isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)] TransitionTo(WIFI_CONNECTING_NEW_FAILED_STATE)")] / { this.tracer?.edgeTransition("edge27"); } TransitionTo(WIFI_CONNECTING_NEW_FAILED_STATE)
        if (this.tracer?.log(" User evaluating guard: " + "!isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)") || this.evaluateGuard("WIFI_CONNECTING_NEW_STATE","LOST_CONNECTION [!isWifiErrReason(WIFI_REASON_ASSOC_LEAVE)] TransitionTo(WIFI_CONNECTING_NEW_FAILED_STATE)"))
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_CONNECTING_NEW_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge27");`.
            this.tracer?.edgeTransition("edge27");
            
            // Step 3: Enter/move towards transition target `WIFI_CONNECTING_NEW_FAILED_STATE`.
            this.#WIFI_CONNECTING_NEW_FAILED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_CONNECTING_NEW_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_CONNECTING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_CONNECTING_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_CONNECTING_STATE;
        
        // WIFI_CONNECTING_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_CONNECTING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_CONNECTING_STATE');`
            this.tracer?.enterState('WIFI_CONNECTING_STATE');
        } // end of behavior for WIFI_CONNECTING_STATE
        
        // WIFI_CONNECTING_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_WIFI_CONNECTING);\nstartWifiDhcpClient();\nconnectActiveSsid();\nstartWifiConnectedTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_WIFI_CONNECTING);\nstartWifiDhcpClient();\nconnectActiveSsid();\nstartWifiConnectedTimer();");`
            this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_WIFI_CONNECTING);\nstartWifiDhcpClient();\nconnectActiveSsid();\nstartWifiConnectedTimer();");
        } // end of behavior for WIFI_CONNECTING_STATE
    }
    
    #WIFI_CONNECTING_STATE_exit()
    {
        // WIFI_CONNECTING_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();");
        } // end of behavior for WIFI_CONNECTING_STATE
        
        // WIFI_CONNECTING_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_CONNECTING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_CONNECTING_STATE');`
            this.tracer?.exitState('WIFI_CONNECTING_STATE');
        } // end of behavior for WIFI_CONNECTING_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
    }
    
    #WIFI_CONNECTING_STATE_connected()
    {
        // WIFI_CONNECTING_STATE behavior
        // uml: CONNECTED / { this.tracer?.edgeTransition("edge25"); } TransitionTo(WIFI_W4_IP_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_CONNECTING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge25");`.
            this.tracer?.edgeTransition("edge25");
            
            // Step 3: Enter/move towards transition target `WIFI_W4_IP_STATE`.
            this.#WIFI_W4_IP_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_CONNECTING_STATE
        
        // No ancestor handles this event.
    }
    
    #WIFI_CONNECTING_STATE_lost_connection()
    {
        // WIFI_CONNECTING_STATE behavior
        // uml: LOST_CONNECTION / { this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);");this.tracer?.edgeTransition("edge26"); } TransitionTo(NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>())
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_CONNECTING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);");this.tracer?.edgeTransition("edge26");`.
            this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_FAILED_ATTEMPT);");this.tracer?.edgeTransition("edge26");
            
            // Step 3: Enter/move towards transition target `NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()`.
            // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            this.#NETWORK_WIFI_ACTIVE_STATE_ChoicePoint__transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for WIFI_CONNECTING_STATE
        
        // No ancestor handles this event.
    }
    
    #WIFI_CONNECTING_STATE_timer()
    {
        // WIFI_CONNECTING_STATE behavior
        // uml: TIMER / { this.tracer?.edgeTransition("edge24"); } TransitionTo(NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>())
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_CONNECTING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge24");`.
            this.tracer?.edgeTransition("edge24");
            
            // Step 3: Enter/move towards transition target `NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()`.
            // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            this.#NETWORK_WIFI_ACTIVE_STATE_ChoicePoint__transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for WIFI_CONNECTING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_INITIALIZING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_INITIALIZING_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_INITIALIZING_STATE;
        
        // WIFI_INITIALIZING_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_INITIALIZING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_INITIALIZING_STATE');`
            this.tracer?.enterState('WIFI_INITIALIZING_STATE');
        } // end of behavior for WIFI_INITIALIZING_STATE
        
        // WIFI_INITIALIZING_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "if (initWifi()) {\n  trigger_init_success_event();\n} else {\n  trigger_configure_wifi_event();\n}"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "if (initWifi()) {\n  trigger_init_success_event();\n} else {\n  trigger_configure_wifi_event();\n}");`
            this.tracer?.log(" FSM would execute action: " + "if (initWifi()) {\n  trigger_init_success_event();\n} else {\n  trigger_configure_wifi_event();\n}");
        } // end of behavior for WIFI_INITIALIZING_STATE
    }
    
    #WIFI_INITIALIZING_STATE_exit()
    {
        // WIFI_INITIALIZING_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_INITIALIZING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_INITIALIZING_STATE');`
            this.tracer?.exitState('WIFI_INITIALIZING_STATE');
        } // end of behavior for WIFI_INITIALIZING_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
    }
    
    #WIFI_INITIALIZING_STATE_configure_wifi()
    {
        let consume_event = false;
        
        // WIFI_INITIALIZING_STATE behavior
        // uml: CONFIGURE_WIFI / { this.tracer?.edgeTransition("edge23"); } TransitionTo(WIFI_IMPROV_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge23");`.
            this.tracer?.edgeTransition("edge23");
            
            // Step 3: Enter/move towards transition target `WIFI_IMPROV_STATE`.
            this.#WIFI_IMPROV_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#WIFI_IMPROV_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for WIFI_INITIALIZING_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#NETWORK_WIFI_ACTIVE_STATE_configure_wifi();
        }
    }
    
    #WIFI_INITIALIZING_STATE_net_init_success()
    {
        // WIFI_INITIALIZING_STATE behavior
        // uml: NET_INIT_SUCCESS / { this.tracer?.edgeTransition("edge22"); } TransitionTo(WIFI_CONNECTING_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_INITIALIZING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge22");`.
            this.tracer?.edgeTransition("edge22");
            
            // Step 3: Enter/move towards transition target `WIFI_CONNECTING_STATE`.
            this.#WIFI_CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_INITIALIZING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_LOST_CONNECTION_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_LOST_CONNECTION_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_LOST_CONNECTION_STATE;
        
        // WIFI_LOST_CONNECTION_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_LOST_CONNECTION_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_LOST_CONNECTION_STATE');`
            this.tracer?.enterState('WIFI_LOST_CONNECTION_STATE');
        } // end of behavior for WIFI_LOST_CONNECTION_STATE
        
        // WIFI_LOST_CONNECTION_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "retryActiveWiFiConnection();\nstartWifiPollingTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "retryActiveWiFiConnection();\nstartWifiPollingTimer();");`
            this.tracer?.log(" FSM would execute action: " + "retryActiveWiFiConnection();\nstartWifiPollingTimer();");
        } // end of behavior for WIFI_LOST_CONNECTION_STATE
    }
    
    #WIFI_LOST_CONNECTION_STATE_exit()
    {
        // WIFI_LOST_CONNECTION_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_LOST_CONNECTION_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_LOST_CONNECTION_STATE');`
            this.tracer?.exitState('WIFI_LOST_CONNECTION_STATE');
        } // end of behavior for WIFI_LOST_CONNECTION_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
    }
    
    #WIFI_LOST_CONNECTION_STATE_timer()
    {
        // WIFI_LOST_CONNECTION_STATE behavior
        // uml: TIMER / { this.tracer?.log(" FSM would execute action: " + "LOGI(\"WiFi polling timeout, retry connection\");");this.tracer?.edgeTransition("edge30"); } TransitionTo(WIFI_CONNECTING_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_LOST_CONNECTION_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.log(" FSM would execute action: " + "LOGI(\"WiFi polling timeout, retry connection\");");this.tracer?.edgeTransition("edge30");`.
            this.tracer?.log(" FSM would execute action: " + "LOGI(\"WiFi polling timeout, retry connection\");");this.tracer?.edgeTransition("edge30");
            
            // Step 3: Enter/move towards transition target `WIFI_CONNECTING_STATE`.
            this.#WIFI_CONNECTING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_LOST_CONNECTION_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_USER_DISCONNECTED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_USER_DISCONNECTED_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_USER_DISCONNECTED_STATE;
        
        // WIFI_USER_DISCONNECTED_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_USER_DISCONNECTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_USER_DISCONNECTED_STATE');`
            this.tracer?.enterState('WIFI_USER_DISCONNECTED_STATE');
        } // end of behavior for WIFI_USER_DISCONNECTED_STATE
        
        // WIFI_USER_DISCONNECTED_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT);");`
            this.tracer?.log(" FSM would execute action: " + "clearWifiConfig();\nstatusUpdate(UPDATE_USER_DISCONNECT);");
        } // end of behavior for WIFI_USER_DISCONNECTED_STATE
    }
    
    #WIFI_USER_DISCONNECTED_STATE_exit()
    {
        // WIFI_USER_DISCONNECTED_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_USER_DISCONNECTED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_USER_DISCONNECTED_STATE');`
            this.tracer?.exitState('WIFI_USER_DISCONNECTED_STATE');
        } // end of behavior for WIFI_USER_DISCONNECTED_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
    }
    
    #WIFI_USER_DISCONNECTED_STATE_lost_connection()
    {
        // WIFI_USER_DISCONNECTED_STATE behavior
        // uml: LOST_CONNECTION / { this.tracer?.edgeTransition("edge33"); } TransitionTo(WIFI_IMPROV_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.NETWORK_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge33");`.
            this.tracer?.edgeTransition("edge33");
            
            // Step 3: Enter/move towards transition target `WIFI_IMPROV_STATE`.
            this.#WIFI_IMPROV_STATE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#WIFI_IMPROV_STATE_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for WIFI_USER_DISCONNECTED_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_W4_IP_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_W4_IP_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_W4_IP_STATE;
        
        // WIFI_W4_IP_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_W4_IP_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_W4_IP_STATE');`
            this.tracer?.enterState('WIFI_W4_IP_STATE');
        } // end of behavior for WIFI_W4_IP_STATE
        
        // WIFI_W4_IP_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "startDhcpTimer();\nLOGI(\"Connected, waiting for IP\");"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "startDhcpTimer();\nLOGI(\"Connected, waiting for IP\");");`
            this.tracer?.log(" FSM would execute action: " + "startDhcpTimer();\nLOGI(\"Connected, waiting for IP\");");
        } // end of behavior for WIFI_W4_IP_STATE
    }
    
    #WIFI_W4_IP_STATE_exit()
    {
        // WIFI_W4_IP_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();");
        } // end of behavior for WIFI_W4_IP_STATE
        
        // WIFI_W4_IP_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_W4_IP_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_W4_IP_STATE');`
            this.tracer?.exitState('WIFI_W4_IP_STATE');
        } // end of behavior for WIFI_W4_IP_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE;
    }
    
    #WIFI_W4_IP_STATE_timer()
    {
        // WIFI_W4_IP_STATE behavior
        // uml: TIMER / { this.tracer?.edgeTransition("edge34"); } TransitionTo(NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>())
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_W4_IP_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge34");`.
            this.tracer?.edgeTransition("edge34");
            
            // Step 3: Enter/move towards transition target `NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>()`.
            // NETWORK_WIFI_ACTIVE_STATE.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            this.#NETWORK_WIFI_ACTIVE_STATE_ChoicePoint__transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for WIFI_W4_IP_STATE
        
        // No ancestor handles this event.
    }
    
    #WIFI_W4_IP_STATE_wifi_got_ip()
    {
        let consume_event = false;
        
        // WIFI_W4_IP_STATE behavior
        // uml: WIFI_GOT_IP / { this.tracer?.edgeTransition("edge35"); } TransitionTo(WIFI_CONNECTED_STATE)
        {
            // Step 1: Exit states until we reach `NETWORK_WIFI_ACTIVE_STATE` state (Least Common Ancestor for transition).
            this.#WIFI_W4_IP_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge35");`.
            this.tracer?.edgeTransition("edge35");
            
            // Step 3: Enter/move towards transition target `WIFI_CONNECTED_STATE`.
            this.#WIFI_CONNECTED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_W4_IP_STATE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#NETWORK_WIFI_ACTIVE_STATE_wifi_got_ip();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WIFI_IMPROV_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #WIFI_IMPROV_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.WIFI_IMPROV_STATE;
        
        // WIFI_IMPROV_STATE behavior
        // uml: enter / { this.tracer?.enterState('WIFI_IMPROV_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('WIFI_IMPROV_STATE');`
            this.tracer?.enterState('WIFI_IMPROV_STATE');
        } // end of behavior for WIFI_IMPROV_STATE
        
        // WIFI_IMPROV_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_WIFI_PROVISIONING);"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_WIFI_PROVISIONING);");`
            this.tracer?.log(" FSM would execute action: " + "statusUpdate(UPDATE_WIFI_PROVISIONING);");
        } // end of behavior for WIFI_IMPROV_STATE
    }
    
    #WIFI_IMPROV_STATE_exit()
    {
        // WIFI_IMPROV_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();");
        } // end of behavior for WIFI_IMPROV_STATE
        
        // WIFI_IMPROV_STATE behavior
        // uml: exit / { this.tracer?.exitState('WIFI_IMPROV_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('WIFI_IMPROV_STATE');`
            this.tracer?.exitState('WIFI_IMPROV_STATE');
        } // end of behavior for WIFI_IMPROV_STATE
        
        this.stateId = NetworkSm.StateId.NETWORK_STATE;
    }
    
    #WIFI_IMPROV_STATE_eth_got_ip()
    {
        // WIFI_IMPROV_STATE behavior
        // uml: ETH_GOT_IP / { this.tracer?.edgeTransition("edge36"); } TransitionTo(REBOOT_STATE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge36");`.
            this.tracer?.edgeTransition("edge36");
            
            // Step 3: Enter/move towards transition target `REBOOT_STATE`.
            this.#REBOOT_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE
        
        // No ancestor handles this event.
    }
    
    #WIFI_IMPROV_STATE_improv_ble_disconnect()
    {
        // WIFI_IMPROV_STATE behavior
        // uml: IMPROV_BLE_DISCONNECT / { this.tracer?.edgeTransition("edge37"); } TransitionTo(IMPROV_STOPPED_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(NetworkSm.StateId.WIFI_IMPROV_STATE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge37");`.
            this.tracer?.edgeTransition("edge37");
            
            // Step 3: Enter/move towards transition target `IMPROV_STOPPED_STATE`.
            this.#IMPROV_STOPPED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE
        
        // No ancestor handles this event.
    }
    
    #WIFI_IMPROV_STATE_InitialState_transition()
    {
        // WIFI_IMPROV_STATE.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge45"); } TransitionTo(IMPROV_INITIALIZING_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge45");`.
            this.tracer?.edgeTransition("edge45");
            
            // Step 3: Enter/move towards transition target `IMPROV_INITIALIZING_STATE`.
            this.#IMPROV_INITIALIZING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WIFI_IMPROV_STATE.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_AUTHORIZED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_AUTHORIZED_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.IMPROV_AUTHORIZED_STATE;
        
        // IMPROV_AUTHORIZED_STATE behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_AUTHORIZED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_AUTHORIZED_STATE');`
            this.tracer?.enterState('IMPROV_AUTHORIZED_STATE');
        } // end of behavior for IMPROV_AUTHORIZED_STATE
        
        // IMPROV_AUTHORIZED_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "setImprovAuthorized();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "setImprovAuthorized();");`
            this.tracer?.log(" FSM would execute action: " + "setImprovAuthorized();");
        } // end of behavior for IMPROV_AUTHORIZED_STATE
    }
    
    #IMPROV_AUTHORIZED_STATE_exit()
    {
        // IMPROV_AUTHORIZED_STATE behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_AUTHORIZED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_AUTHORIZED_STATE');`
            this.tracer?.exitState('IMPROV_AUTHORIZED_STATE');
        } // end of behavior for IMPROV_AUTHORIZED_STATE
        
        this.stateId = NetworkSm.StateId.WIFI_IMPROV_STATE;
    }
    
    #IMPROV_AUTHORIZED_STATE_connect_to_ap()
    {
        // IMPROV_AUTHORIZED_STATE behavior
        // uml: CONNECT_TO_AP / { this.tracer?.edgeTransition("edge39"); } TransitionTo(IMPROV_PROVISIONING_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#IMPROV_AUTHORIZED_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge39");`.
            this.tracer?.edgeTransition("edge39");
            
            // Step 3: Enter/move towards transition target `IMPROV_PROVISIONING_STATE`.
            this.#IMPROV_PROVISIONING_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IMPROV_AUTHORIZED_STATE
        
        // No ancestor handles this event.
    }
    
    #IMPROV_AUTHORIZED_STATE_improv_authorized_timeout()
    {
        // IMPROV_AUTHORIZED_STATE behavior
        // uml: IMPROV_AUTHORIZED_TIMEOUT / { this.tracer?.edgeTransition("edge40"); } TransitionTo(IMPROV_AWAITING_AUTH_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#IMPROV_AUTHORIZED_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge40");`.
            this.tracer?.edgeTransition("edge40");
            
            // Step 3: Enter/move towards transition target `IMPROV_AWAITING_AUTH_STATE`.
            this.#IMPROV_AWAITING_AUTH_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IMPROV_AUTHORIZED_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_AWAITING_AUTH_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_AWAITING_AUTH_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.IMPROV_AWAITING_AUTH_STATE;
        
        // IMPROV_AWAITING_AUTH_STATE behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_AWAITING_AUTH_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_AWAITING_AUTH_STATE');`
            this.tracer?.enterState('IMPROV_AWAITING_AUTH_STATE');
        } // end of behavior for IMPROV_AWAITING_AUTH_STATE
        
        // IMPROV_AWAITING_AUTH_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "setImprovAuthRequired();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "setImprovAuthRequired();");`
            this.tracer?.log(" FSM would execute action: " + "setImprovAuthRequired();");
        } // end of behavior for IMPROV_AWAITING_AUTH_STATE
    }
    
    #IMPROV_AWAITING_AUTH_STATE_exit()
    {
        // IMPROV_AWAITING_AUTH_STATE behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_AWAITING_AUTH_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_AWAITING_AUTH_STATE');`
            this.tracer?.exitState('IMPROV_AWAITING_AUTH_STATE');
        } // end of behavior for IMPROV_AWAITING_AUTH_STATE
        
        this.stateId = NetworkSm.StateId.WIFI_IMPROV_STATE;
    }
    
    #IMPROV_AWAITING_AUTH_STATE_button_press()
    {
        // IMPROV_AWAITING_AUTH_STATE behavior
        // uml: BUTTON_PRESS / { this.tracer?.edgeTransition("edge38"); } TransitionTo(IMPROV_AUTHORIZED_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#IMPROV_AWAITING_AUTH_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge38");`.
            this.tracer?.edgeTransition("edge38");
            
            // Step 3: Enter/move towards transition target `IMPROV_AUTHORIZED_STATE`.
            this.#IMPROV_AUTHORIZED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IMPROV_AWAITING_AUTH_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_INITIALIZING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_INITIALIZING_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.IMPROV_INITIALIZING_STATE;
        
        // IMPROV_INITIALIZING_STATE behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_INITIALIZING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_INITIALIZING_STATE');`
            this.tracer?.enterState('IMPROV_INITIALIZING_STATE');
        } // end of behavior for IMPROV_INITIALIZING_STATE
        
        // IMPROV_INITIALIZING_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "startImprovWifi();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "startImprovWifi();");`
            this.tracer?.log(" FSM would execute action: " + "startImprovWifi();");
        } // end of behavior for IMPROV_INITIALIZING_STATE
    }
    
    #IMPROV_INITIALIZING_STATE_exit()
    {
        // IMPROV_INITIALIZING_STATE behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_INITIALIZING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_INITIALIZING_STATE');`
            this.tracer?.exitState('IMPROV_INITIALIZING_STATE');
        } // end of behavior for IMPROV_INITIALIZING_STATE
        
        this.stateId = NetworkSm.StateId.WIFI_IMPROV_STATE;
    }
    
    #IMPROV_INITIALIZING_STATE_net_init_success()
    {
        // IMPROV_INITIALIZING_STATE behavior
        // uml: NET_INIT_SUCCESS / { this.tracer?.edgeTransition("edge44"); } TransitionTo(IMPROV_STOPPED_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#IMPROV_INITIALIZING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge44");`.
            this.tracer?.edgeTransition("edge44");
            
            // Step 3: Enter/move towards transition target `IMPROV_STOPPED_STATE`.
            this.#IMPROV_STOPPED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IMPROV_INITIALIZING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_PROVISIONED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_PROVISIONED_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.IMPROV_PROVISIONED_STATE;
        
        // IMPROV_PROVISIONED_STATE behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_PROVISIONED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_PROVISIONED_STATE');`
            this.tracer?.enterState('IMPROV_PROVISIONED_STATE');
        } // end of behavior for IMPROV_PROVISIONED_STATE
        
        // IMPROV_PROVISIONED_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "saveActiveWifiConfig();\nsetImprovWifiProvisioned();\nvTaskDelay(pdMS_TO_TICKS(2000));\ntrigger_reboot_event();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "saveActiveWifiConfig();\nsetImprovWifiProvisioned();\nvTaskDelay(pdMS_TO_TICKS(2000));\ntrigger_reboot_event();");`
            this.tracer?.log(" FSM would execute action: " + "saveActiveWifiConfig();\nsetImprovWifiProvisioned();\nvTaskDelay(pdMS_TO_TICKS(2000));\ntrigger_reboot_event();");
        } // end of behavior for IMPROV_PROVISIONED_STATE
    }
    
    #IMPROV_PROVISIONED_STATE_exit()
    {
        // IMPROV_PROVISIONED_STATE behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_PROVISIONED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_PROVISIONED_STATE');`
            this.tracer?.exitState('IMPROV_PROVISIONED_STATE');
        } // end of behavior for IMPROV_PROVISIONED_STATE
        
        this.stateId = NetworkSm.StateId.WIFI_IMPROV_STATE;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_PROVISIONING_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_PROVISIONING_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.IMPROV_PROVISIONING_STATE;
        
        // IMPROV_PROVISIONING_STATE behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_PROVISIONING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_PROVISIONING_STATE');`
            this.tracer?.enterState('IMPROV_PROVISIONING_STATE');
        } // end of behavior for IMPROV_PROVISIONING_STATE
        
        // IMPROV_PROVISIONING_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "setImprovProvisioning();\nstartImprovTimer();\nstartWifiDhcpClient();\nconnectWifi();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "setImprovProvisioning();\nstartImprovTimer();\nstartWifiDhcpClient();\nconnectWifi();");`
            this.tracer?.log(" FSM would execute action: " + "setImprovProvisioning();\nstartImprovTimer();\nstartWifiDhcpClient();\nconnectWifi();");
        } // end of behavior for IMPROV_PROVISIONING_STATE
    }
    
    #IMPROV_PROVISIONING_STATE_exit()
    {
        // IMPROV_PROVISIONING_STATE behavior
        // uml: exit / { this.tracer?.log(" FSM would execute action: " + "stopTimer();\nclearEventParameters();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "stopTimer();\nclearEventParameters();");`
            this.tracer?.log(" FSM would execute action: " + "stopTimer();\nclearEventParameters();");
        } // end of behavior for IMPROV_PROVISIONING_STATE
        
        // IMPROV_PROVISIONING_STATE behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_PROVISIONING_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_PROVISIONING_STATE');`
            this.tracer?.exitState('IMPROV_PROVISIONING_STATE');
        } // end of behavior for IMPROV_PROVISIONING_STATE
        
        this.stateId = NetworkSm.StateId.WIFI_IMPROV_STATE;
    }
    
    #IMPROV_PROVISIONING_STATE_connected()
    {
        // IMPROV_PROVISIONING_STATE behavior
        // uml: CONNECTED / { this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the new access point. Waiting for IP Address\");"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the new access point. Waiting for IP Address\");");`
            this.tracer?.log(" FSM would execute action: " + "LOGI(\"Successfully connected to the new access point. Waiting for IP Address\");");
        } // end of behavior for IMPROV_PROVISIONING_STATE
        
        // No ancestor handles this event.
    }
    
    #IMPROV_PROVISIONING_STATE_lost_connection()
    {
        // IMPROV_PROVISIONING_STATE behavior
        // uml: LOST_CONNECTION / { this.tracer?.log(" FSM would execute action: " + "onImprovConnectTimeout();");this.tracer?.edgeTransition("edge42"); } TransitionTo(IMPROV_AUTHORIZED_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#IMPROV_PROVISIONING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.log(" FSM would execute action: " + "onImprovConnectTimeout();");this.tracer?.edgeTransition("edge42");`.
            this.tracer?.log(" FSM would execute action: " + "onImprovConnectTimeout();");this.tracer?.edgeTransition("edge42");
            
            // Step 3: Enter/move towards transition target `IMPROV_AUTHORIZED_STATE`.
            this.#IMPROV_AUTHORIZED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IMPROV_PROVISIONING_STATE
        
        // No ancestor handles this event.
    }
    
    #IMPROV_PROVISIONING_STATE_timer()
    {
        // IMPROV_PROVISIONING_STATE behavior
        // uml: TIMER / { this.tracer?.log(" FSM would execute action: " + "onImprovConnectTimeout();");this.tracer?.edgeTransition("edge43"); } TransitionTo(IMPROV_AUTHORIZED_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#IMPROV_PROVISIONING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.log(" FSM would execute action: " + "onImprovConnectTimeout();");this.tracer?.edgeTransition("edge43");`.
            this.tracer?.log(" FSM would execute action: " + "onImprovConnectTimeout();");this.tracer?.edgeTransition("edge43");
            
            // Step 3: Enter/move towards transition target `IMPROV_AUTHORIZED_STATE`.
            this.#IMPROV_AUTHORIZED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IMPROV_PROVISIONING_STATE
        
        // No ancestor handles this event.
    }
    
    #IMPROV_PROVISIONING_STATE_wifi_got_ip()
    {
        // IMPROV_PROVISIONING_STATE behavior
        // uml: WIFI_GOT_IP / { this.tracer?.edgeTransition("edge41"); } TransitionTo(IMPROV_PROVISIONED_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#IMPROV_PROVISIONING_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge41");`.
            this.tracer?.edgeTransition("edge41");
            
            // Step 3: Enter/move towards transition target `IMPROV_PROVISIONED_STATE`.
            this.#IMPROV_PROVISIONED_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IMPROV_PROVISIONING_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IMPROV_STOPPED_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IMPROV_STOPPED_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.IMPROV_STOPPED_STATE;
        
        // IMPROV_STOPPED_STATE behavior
        // uml: enter / { this.tracer?.enterState('IMPROV_STOPPED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('IMPROV_STOPPED_STATE');`
            this.tracer?.enterState('IMPROV_STOPPED_STATE');
        } // end of behavior for IMPROV_STOPPED_STATE
        
        // IMPROV_STOPPED_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "setImprovStopped();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "setImprovStopped();");`
            this.tracer?.log(" FSM would execute action: " + "setImprovStopped();");
        } // end of behavior for IMPROV_STOPPED_STATE
    }
    
    #IMPROV_STOPPED_STATE_exit()
    {
        // IMPROV_STOPPED_STATE behavior
        // uml: exit / { this.tracer?.exitState('IMPROV_STOPPED_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('IMPROV_STOPPED_STATE');`
            this.tracer?.exitState('IMPROV_STOPPED_STATE');
        } // end of behavior for IMPROV_STOPPED_STATE
        
        this.stateId = NetworkSm.StateId.WIFI_IMPROV_STATE;
    }
    
    #IMPROV_STOPPED_STATE_improv_ble_connect()
    {
        // IMPROV_STOPPED_STATE behavior
        // uml: IMPROV_BLE_CONNECT / { this.tracer?.edgeTransition("edge46"); } TransitionTo(IMPROV_AWAITING_AUTH_STATE)
        {
            // Step 1: Exit states until we reach `WIFI_IMPROV_STATE` state (Least Common Ancestor for transition).
            this.#IMPROV_STOPPED_STATE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge46");`.
            this.tracer?.edgeTransition("edge46");
            
            // Step 3: Enter/move towards transition target `IMPROV_AWAITING_AUTH_STATE`.
            this.#IMPROV_AWAITING_AUTH_STATE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IMPROV_STOPPED_STATE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state REBOOT_STATE
    ////////////////////////////////////////////////////////////////////////////////
    
    #REBOOT_STATE_enter()
    {
        this.stateId = NetworkSm.StateId.REBOOT_STATE;
        
        // REBOOT_STATE behavior
        // uml: enter / { this.tracer?.enterState('REBOOT_STATE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('REBOOT_STATE');`
            this.tracer?.enterState('REBOOT_STATE');
        } // end of behavior for REBOOT_STATE
        
        // REBOOT_STATE behavior
        // uml: enter / { this.tracer?.log(" FSM would execute action: " + "reboot();"); }
        {
            // Step 1: execute action `this.tracer?.log(" FSM would execute action: " + "reboot();");`
            this.tracer?.log(" FSM would execute action: " + "reboot();");
        } // end of behavior for REBOOT_STATE
    }
    
    #REBOOT_STATE_exit()
    {
        // REBOOT_STATE behavior
        // uml: exit / { this.tracer?.exitState('REBOOT_STATE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('REBOOT_STATE');`
            this.tracer?.exitState('REBOOT_STATE');
        } // end of behavior for REBOOT_STATE
        
        this.stateId = NetworkSm.StateId.ROOT;
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case NetworkSm.StateId.ROOT: return "ROOT";
            case NetworkSm.StateId.NETWORK_STATE: return "NETWORK_STATE";
            case NetworkSm.StateId.NETWORK_ETH_ACTIVE_STATE: return "NETWORK_ETH_ACTIVE_STATE";
            case NetworkSm.StateId.ETH_ACTIVE_CONNECTED_STATE: return "ETH_ACTIVE_CONNECTED_STATE";
            case NetworkSm.StateId.ETH_ACTIVE_LINKDOWN_STATE: return "ETH_ACTIVE_LINKDOWN_STATE";
            case NetworkSm.StateId.ETH_ACTIVE_LINKUP_STATE: return "ETH_ACTIVE_LINKUP_STATE";
            case NetworkSm.StateId.ETH_CONNECTING_NEW_STATE: return "ETH_CONNECTING_NEW_STATE";
            case NetworkSm.StateId.ETH_INITIALIZING_STATE: return "ETH_INITIALIZING_STATE";
            case NetworkSm.StateId.ETH_STARTING_STATE: return "ETH_STARTING_STATE";
            case NetworkSm.StateId.NETWORK_WIFI_ACTIVE_STATE: return "NETWORK_WIFI_ACTIVE_STATE";
            case NetworkSm.StateId.WIFI_CONNECTED_STATE: return "WIFI_CONNECTED_STATE";
            case NetworkSm.StateId.WIFI_CONNECTING_NEW_FAILED_STATE: return "WIFI_CONNECTING_NEW_FAILED_STATE";
            case NetworkSm.StateId.WIFI_CONNECTING_NEW_STATE: return "WIFI_CONNECTING_NEW_STATE";
            case NetworkSm.StateId.WIFI_CONNECTING_STATE: return "WIFI_CONNECTING_STATE";
            case NetworkSm.StateId.WIFI_INITIALIZING_STATE: return "WIFI_INITIALIZING_STATE";
            case NetworkSm.StateId.WIFI_LOST_CONNECTION_STATE: return "WIFI_LOST_CONNECTION_STATE";
            case NetworkSm.StateId.WIFI_USER_DISCONNECTED_STATE: return "WIFI_USER_DISCONNECTED_STATE";
            case NetworkSm.StateId.WIFI_W4_IP_STATE: return "WIFI_W4_IP_STATE";
            case NetworkSm.StateId.WIFI_IMPROV_STATE: return "WIFI_IMPROV_STATE";
            case NetworkSm.StateId.IMPROV_AUTHORIZED_STATE: return "IMPROV_AUTHORIZED_STATE";
            case NetworkSm.StateId.IMPROV_AWAITING_AUTH_STATE: return "IMPROV_AWAITING_AUTH_STATE";
            case NetworkSm.StateId.IMPROV_INITIALIZING_STATE: return "IMPROV_INITIALIZING_STATE";
            case NetworkSm.StateId.IMPROV_PROVISIONED_STATE: return "IMPROV_PROVISIONED_STATE";
            case NetworkSm.StateId.IMPROV_PROVISIONING_STATE: return "IMPROV_PROVISIONING_STATE";
            case NetworkSm.StateId.IMPROV_STOPPED_STATE: return "IMPROV_STOPPED_STATE";
            case NetworkSm.StateId.REBOOT_STATE: return "REBOOT_STATE";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case NetworkSm.EventId.BUTTON_PRESS: return "BUTTON_PRESS";
            case NetworkSm.EventId.CONFIGURE_WIFI: return "CONFIGURE_WIFI";
            case NetworkSm.EventId.CONNECT_TO_AP: return "CONNECT_TO_AP";
            case NetworkSm.EventId.CONNECTED: return "CONNECTED";
            case NetworkSm.EventId.DELETE_WIFI: return "DELETE_WIFI";
            case NetworkSm.EventId.ETH_FALLBACK: return "ETH_FALLBACK";
            case NetworkSm.EventId.ETH_GOT_IP: return "ETH_GOT_IP";
            case NetworkSm.EventId.ETH_LINK_DOWN: return "ETH_LINK_DOWN";
            case NetworkSm.EventId.ETH_LINK_UP: return "ETH_LINK_UP";
            case NetworkSm.EventId.IMPROV_AUTHORIZED_TIMEOUT: return "IMPROV_AUTHORIZED_TIMEOUT";
            case NetworkSm.EventId.IMPROV_BLE_CONNECT: return "IMPROV_BLE_CONNECT";
            case NetworkSm.EventId.IMPROV_BLE_DISCONNECT: return "IMPROV_BLE_DISCONNECT";
            case NetworkSm.EventId.LOST_CONNECTION: return "LOST_CONNECTION";
            case NetworkSm.EventId.NET_INIT_FAIL: return "NET_INIT_FAIL";
            case NetworkSm.EventId.NET_INIT_SUCCESS: return "NET_INIT_SUCCESS";
            case NetworkSm.EventId.REBOOT: return "REBOOT";
            case NetworkSm.EventId.START: return "START";
            case NetworkSm.EventId.TIMER: return "TIMER";
            case NetworkSm.EventId.WIFI_GOT_IP: return "WIFI_GOT_IP";
            default: return "?";
        }
    }
}

</script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        import svgPanZoom from 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/+esm' ;
        mermaid.initialize({ startOnLoad: false });
        await mermaid.run();

        // svg-pan-zoom doesn't like the mermaid viewbox
        document.querySelector('svg').removeAttribute('viewBox');
        document.querySelector('svg').setAttribute('width', '100%');
        document.querySelector('svg').setAttribute('height', '100%');
        document.querySelector('svg').style["max-width"] = '';

        // don't scale the arrow when we scale the transition edge
        document.querySelectorAll('g defs marker[id$=barbEnd]').forEach(marker => {
            marker.setAttribute('markerUnits', 'userSpaceOnUse');
        });

        // https://github.com/StateSmith/StateSmith/issues/404
        // https://github.com/StateSmith/StateSmith/issues/294
        // rewrite $initial_state to a black circle
        document.querySelectorAll('g[data-id*="(InitialState)"]').forEach(g=> {
          g.innerHTML = '<circle transform="translate(0,3)" height="14" width="14" r="14" class="state - start"></circle>';
        })

        var panZoom = window.panZoom = svgPanZoom(document.querySelector('svg'), {
            zoomEnabled: true,
            controlIconsEnabled: true,
            fit: true,
            center: true
        });

        const diagramEventNamesArray = ['BUTTON_PRESS', 'CONFIGURE_WIFI', 'CONNECTED', 'CONNECT_TO_AP', 'DELETE_WIFI', 'ETH_FALLBACK', 'ETH_GOT_IP', 'ETH_LINK_DOWN', 'ETH_LINK_UP', 'IMPROV_AUTHORIZED_TIMEOUT', 'IMPROV_BLE_CONNECT', 'IMPROV_BLE_DISCONNECT', 'LOST_CONNECTION', 'NET_INIT_FAIL', 'NET_INIT_SUCCESS', 'REBOOT', 'START', 'TIMER', 'WIFI_GOT_IP', ];

        const leftPane = document.querySelector(".main");
        const rightPane = document.querySelector(".sidebar");
        const gutter = document.querySelector(".gutter");

        function resizer(e) {          
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);          
          let prevX = e.x;
          const rightPanel = rightPane.getBoundingClientRect();
                    
          function mousemove(e) {
            let newX = prevX - e.x;
            rightPane.style.width = rightPanel.width + newX + 'px';
            window.panZoom.resize();
            window.panZoom.fit();
            window.panZoom.center();
          }
          
          function mouseup() {
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
            
          }                  
        }

        gutter.addEventListener('mousedown', resizer);

        document.getElementById('timestamps').checked = document.querySelector('table.console').classList.contains('timestamps');
        document.getElementById('timestamps').addEventListener('change', function() {
          if(this.checked) {
            document.querySelector('table.console').classList.add('timestamps');
          } else {
            document.querySelector('table.console').classList.remove('timestamps');
          }
        });

        document.getElementById('dropbtn').addEventListener('click', myFunction);

        /* When the user clicks on the button, 
        toggle between hiding and showing the dropdown content */
        function myFunction() {
          document.getElementById('myDropdown').classList.toggle('show');
        }

        // Close the dropdown if the user clicks outside of it
        window.onclick = function(event) {
          if (!event.target.matches('.dropbtn')) {
            var dropdowns = document.getElementsByClassName('dropdown-content');
            var i;
            for (i = 0; i < dropdowns.length; i++) {
              var openDropdown = dropdowns[i];
              if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
              }
            }
          }
        }




        // Convert a date to a string in the format HH:MM:SS.sss
        function formatTime(date) {
            return date.getHours().toString().padStart(2, '0') + ':' +
                date.getMinutes().toString().padStart(2, '0') + ':' +
                date.getSeconds().toString().padStart(2, '0') + '.' +
                date.getMilliseconds().toString().padStart(3, '0');
        }

        // Add a row to the history table.
        function addHistoryRow(time, event, html = false) {
            var row = document.createElement('tr');
            var timeCell = document.createElement('td');
            timeCell.innerText = formatTime(time);
            timeCell.classList.add('timestamp');
            var eventCell = document.createElement('td');

            if(html) {
              eventCell.innerHTML = event;
            } else {
              eventCell.innerText = event;
            }

            row.appendChild(timeCell);
            row.appendChild(eventCell);
            document.querySelector('tbody').appendChild(row);
        }

        var sm = new NetworkSm();

        // prompt the user to evaluate guards manually
        sm.evaluateGuard = (vertexName, behaviorUml) => {
            return confirm(`Evaluate guard for\n${vertexName} behavior:\n${behaviorUml}.\n\nPress 'OK' to evaluate guard as true and 'Cancel' to evaluate it as false.`);
        }; 

        const highlightedEdges = new Set();
        function highlightEdge(edgeId) {
            var edge = document.getElementById(edgeId);
            if (edge) {
              edge.classList.add('active');
              highlightedEdges.add(edge);
            }
        }

        function clearHighlightedEdges() {
            for (const edge of highlightedEdges) {
              edge.classList.remove('active');
              const showOldTraversal = false;
              if (showOldTraversal) {
                  // shows that the edge was traversed. Optional, but kinda nice.
                  edge.style.stroke = 'green';
              }
            }
            highlightedEdges.clear();
        }

        // The simulator uses a tracer callback to perform operations such as 
        // state highlighting and logging. You do not need this functionality
        // when using NetworkSm.js in your own applications, although you may
        // choose to implement a tracer for debugging purposes.
        sm.tracer = {
            enterState: (mermaidName) => {
                var e = document.querySelector('g[data-id=' + mermaidName + ']');
                if(e) {
                  e.classList.add('active');
                  panOnScreen(e);
                }
                sm.tracer.log(' Entered ' + mermaidName);
            },
            exitState: (mermaidName) => {
                document.querySelector('g[data-id=' + mermaidName + ']')?.classList.remove('active');
            },
            edgeTransition: (edgeId) => {
                highlightEdge(edgeId);
            },
            log: (message, html=false) => {
                addHistoryRow(new Date(), message, html);
            }
        };

        // Wire up the buttons that dispatch events for the state machine.
        diagramEventNamesArray.forEach(diagramEventName => {
            var button = document.createElement('button');
            button.id = 'button_' + diagramEventName;
            button.innerText = diagramEventName;
            button.addEventListener('click', () => {
                clearHighlightedEdges();
                sm.tracer?.log('<span class="dispatched"><span class="trigger">' + diagramEventName + '</span> DISPATCHED</span>', true);
                const fsmEventName = diagramEventName.toUpperCase();
                sm.dispatchEvent(NetworkSm.EventId[fsmEventName]); 
            });
            document.getElementById('buttons').appendChild(button);
        });

        sm.tracer?.log('<span class="dispatched">START</span>', true);
        sm.start();


        function panOnScreen(element) {
          if(!element) return;

          var bounds = element.getBoundingClientRect();
          if(bounds.x<0 || bounds.y<0) {
              var x = Math.max(0, -bounds.x + 20);
              var y = Math.max(0, -bounds.y + 20);
              window.panZoom.panBy({x: x, y: y});
          }
          var panebounds = document.querySelector('svg').getBoundingClientRect();
          if(bounds.x>panebounds.width || bounds.y>panebounds.height) {
              var x = Math.min(0, panebounds.width - bounds.x - bounds.width - 20);
              var y = Math.min(0, panebounds.height - bounds.y - bounds.height - 20);
              window.panZoom.panBy({x: x, y: y});
          }
        }
    </script>


  </body>
</html>
